# -*- eval: (add-hook 'after-save-hook #'tangle-init-files nil t); evil-lookup-func: helpful-at-point; -*-
#+title: Emacs Configuration
#+author: Chris Barrett
#+property: header-args :results silent
#+property: header-args:emacs-lisp :tangle "config.el" :lexical yes
#+startup: fold

This file uses org-mode's tangle functionality to create both the
=early-init.el= and =init.el= files used by Emacs during the startup sequence.

Headings can be tagged with =:disabled:= to 'comment-out' those blocks.

* Early Init
:PROPERTIES:
:header-args:emacs-lisp: :tangle "early-init.el" :lexical yes
:END:
=early-init.el= is used to set certain variables very early in the startup
sequence. This lisp is evaluated before the graphical context and package
manager are initialised.

The tangled file is checked in to git to ensure this Emacs config starts up
correctly from a fresh checkout.

#+begin_src emacs-lisp
  ;;; early-init.el -- Run at the beginning of Emacs startup sequence.  -*- lexical-binding: t; buffer-read-only: t; -*-

  ;;; Commentary:

  ;; This file was generated by org-babel from config.org and should not be edited
  ;; directly.

  ;;; Code:
#+end_src

** Set an environment variable so children can detect that they're inside Emacs
#+begin_src emacs-lisp
  (setenv "INSIDE_EMACS" "true")
#+end_src

** Crank up the max size of subprocess output to read.
This is needed for language servers to perform well, since they communicate
using large chunks of JSON. See:
- [[https://emacs-lsp.github.io/lsp-mode/page/performance/][Performance - LSP Mode - LSP support for Emacs]]

#+begin_src emacs-lisp
  (setq read-process-output-max (* 1024 1024))
#+end_src

** Make this checkout directory the value for ~user-emacs-directory~
This makes it possible to run a version of this config checked out to a git
worktree, for instance, and have all lisp config resolved relative to this
early-init file.

#+begin_src emacs-lisp
  (setq user-emacs-directory (file-name-directory (or load-file-name (buffer-file-name))))
#+end_src

** Disable package.el to improve startup time
Disable =package.el=, since it increases startup time and I use
[[https://github.com/nix-community/emacs-overlay][nix-community/emacs-overlay]] to handle package installation.

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

** Increase GC limit to reduce collections during startup
Garbage collection runs slow down the Emacs startup sequence. Temporarily
increase settings. We will set final values at the end of the startup sequence.

#+begin_src emacs-lisp
  (setq gc-cons-threshold most-positive-fixnum)
  (setq gc-cons-percentage 0.7)
#+end_src

** Put the ELN cache directory in an XDG-conformant place
#+begin_src emacs-lisp
  (when (boundp 'comp-eln-load-path)
    (let ((cache-dir "~/.cache/emacs/eln-cache/"))
      (mkdir cache-dir t)
      (add-to-list 'comp-eln-load-path cache-dir)))
#+end_src

** Enable pixel-wise frame resizing
This helps tiling window managers apply the right size to Emacs frames.
#+begin_src emacs-lisp
  (setq frame-resize-pixelwise t)
#+end_src

** Disable menu bars, etc
Disable window chrome that doesn't make sense in a keyboard-driven UI.
#+begin_src emacs-lisp
  (custom-set-variables '(menu-bar-mode nil)
                        '(tool-bar-mode . nil)
                        '(scroll-bar-mode nil))

  (modify-all-frames-parameters '((vertical-scroll-bars)))
#+end_src

** Customise the titlebar

*** Show just 'Emacs' for window manager title bar
#+begin_src emacs-lisp
  (setq frame-title-format "Emacs")
#+end_src

*** Make the title bar more natural in macOS
#+begin_src emacs-lisp
  (when (equal system-type 'darwin)
    (setq ns-use-proxy-icon nil)
    (modify-all-frames-parameters '((ns-appearance . dark)
                                    (ns-transparent-titlebar . t))))
#+end_src

** Set source directory
Set the location where Emacs looks for its C source files. This is needed to
view the definitions of special forms implemented in C.

The path to sources in the nix-store is injected via an environment variable.

#+begin_src emacs-lisp
  (setq source-directory (expand-file-name emacs-version (getenv "NIX_EMACS_SRC_DIR")))
#+end_src

** Set PATH correctly on Darwin
macOS prevents PATH being modified for graphical apps, so the wrapper set up
with Nix won't work. Use another environment variable to pass through the
desired value.

#+begin_src emacs-lisp
  (autoload 'string-join "subr-x")

  (when (equal system-type 'darwin)
    (dolist (dir (split-string (getenv "NIX_EMACS_DARWIN_PATH_EXTRAS") ":"))
      (push dir exec-path))
    (setq exec-path (seq-uniq exec-path))

    (setenv "PATH" (string-join exec-path ":")))
#+end_src

* File header
#+begin_src emacs-lisp
  ;;; config.el -- User init file for Emacs.  -*- lexical-binding: t; buffer-read-only: t; -*-

  ;;; Commentary:

  ;; This file was generated by org-babel from config.org and should not be edited
  ;; directly.

  ;;; Code:
#+end_src

* Debugging
Hook into the startup lifecycle to report useful debugging information. Note
that these leverage the ~DEPTH~ argument so that subsequent functions added to
~after-init-hook~ are still ordered correctly.

** Show profiler report if startup took too long
#+begin_src emacs-lisp
  (require 'profiler)

  (defvar startup-debugger-report-enabled-p t
    "Whether to show the debugger if startup takes to long.

  This can be disabled in the site file.")

  (defvar startup-debugger-report-threshold-seconds 1)

  (defun config-start-debugger-on-startup ()
    (when startup-debugger-report-enabled-p
      (profiler-start 'cpu)))

  (defun config-stop-debugger-on-startup ()
    (when startup-debugger-report-enabled-p
      (profiler-stop)
      (let* ((now (current-time))
             (total-startup-time (float-time (time-subtract now emacs-start-time))))
        (unless (time-less-p total-startup-time
                             (seconds-to-time startup-debugger-report-threshold-seconds))
          (profiler-report)))))

  (unless noninteractive
    (add-hook 'after-init-hook #'config-start-debugger-on-startup -99)
    (add-hook 'after-init-hook #'config-stop-debugger-on-startup 99))
#+end_src

** Enable debugging for duration of startup sequence
#+begin_src emacs-lisp
  (setq debug-on-error t)

  (add-hook 'after-init-hook
            (lambda ()
              (setq debug-on-error nil))
            98)
#+end_src

** Log startup time duration
Note that tests refer to ~total-startup-duration~, so it should not be inlined.
#+begin_src emacs-lisp
  (defvar after-init-start-time)
  (defvar total-startup-duration)

  (add-hook 'after-init-hook (lambda ()
                               (setq after-init-start-time (current-time)))
            -97)

  (add-hook 'after-init-hook (lambda ()
                               (let* ((now (current-time))
                                      (after-init-duration (float-time (time-subtract now after-init-start-time))))
                                 (setq total-startup-duration (float-time (time-subtract now emacs-start-time)))
                                 (message "after-init completed (%.3f hook duration, %.3f seconds total startup time)"
                                          after-init-duration
                                          total-startup-duration)))
            97)
#+end_src

* Startup

** Tune garbage collection
See: [[https://bling.github.io/blog/2016/01/18/why-are-you-changing-gc-cons-threshold/][Why are you changing gc-cons-threshold?]]
#+begin_src emacs-lisp
  (defvar config-default-gc-threshold 800000)

  (defun config--inhibit-gc ()
    (setq gc-cons-threshold most-positive-fixnum))

  (defun config--enable-gc ()
    (setq gc-cons-threshold config-default-gc-threshold))
#+end_src

*** Restore GC settings after init sequence has completed
#+begin_src emacs-lisp
  (add-hook 'after-init-hook #'config--enable-gc)
#+end_src

*** Prevent GCs during user input in the minibuffer
#+begin_src emacs-lisp
  (add-hook 'minibuffer-setup-hook #'config--inhibit-gc)
  (add-hook 'minibuffer-exit-hook #'config--enable-gc)
#+end_src

** Start server
#+begin_src emacs-lisp
  (unless noninteractive
    (server-start))
#+end_src

** Define a function to select a value depending on the current OS theme
#+begin_src emacs-lisp
  (defun gtk-theme-class ()
    (with-temp-buffer
      (ignore-errors
        (call-process "gsettings" nil t nil
                      "get" "org.gnome.desktop.interface" "gtk-theme"))
      (if (string-match-p "dark" (buffer-string))
          'dark
        'light)))

  (defun macos-theme ()
    (with-temp-buffer
      (ignore-errors
        (call-process "defaults" nil t nil
                      "read" "-g" "AppleInterfaceStyle"))
      (if (string-match-p "dark" (buffer-string))
          'dark
        'light)))

  (cl-defun choose-by-system-theme (&key light dark)
    (let ((theme
           (pcase system-type
             ('gnu/linux (gtk-theme-class))
             ('darwin (macos-theme)))))
      (if (equal 'dark theme)
          dark
        light)))
#+end_src

** Set background colour based on OS theme
Set reasonable placeholder foreground and background colours until the theme is
loaded. Use the current WM theme to determine whether to use light or dark colours.

#+begin_src emacs-lisp
  (set-background-color (choose-by-system-theme :dark "#282c34" :light "#FDF6E3"))
  (set-foreground-color (choose-by-system-theme :dark "#bbc2cf" :light "#556b72"))
#+end_src

** =use-package= - DSL for Lisp package configuration
See: [[https://github.com/jwiegley/use-package][jwiegley/use-package]]
#+begin_src emacs-lisp
  (with-no-warnings
    (setq use-package-always-defer t)
    (setq use-package-minimum-reported-time 0.05)
    (setq use-package-compute-statistics t)
    (setq use-package-verbose (not noninteractive)))

  (eval-when-compile
    (require 'use-package))
  #+end_src

Define a helper function for loading files with =use-package='s timing functionality.

#+begin_src emacs-lisp
  (autoload 'use-package-require "use-package-core")

  (defun load-file-with-stats (file)
    (let ((name (intern (file-name-sans-extension (file-name-nondirectory file)))))
      (eval
       (macroexp-progn
        (use-package-concat
         (when use-package-compute-statistics
           `((use-package-statistics-gather :config ',name nil)))
         (use-package-require file)
         (when use-package-compute-statistics
           `((use-package-statistics-gather :config ',name nil))))))))
#+end_src

** =general= - Provides a rich key-binding DSL supported by =use-package=
See: [[https://github.com/noctuid/general.el][noctuid/general.el]]
#+begin_src emacs-lisp
  (use-package general
    :demand t)
#+end_src

** =delight= - Change or hide minor-mode lighters
#+begin_src emacs-lisp
  (use-package delight
    :demand t)
#+end_src

** Load features used often in config
#+begin_src emacs-lisp
  (require 'dash)
  (require 'f)
  (require 'subr-x)
  (require 'seq)
  (require 'seq-extras (expand-file-name "lisp/seq-extras.el" user-emacs-directory))
  (require 'ht)
#+end_src

** Load =cl= early to avoid warnings caused by reorganised functions in Emacs 27+
#+begin_src emacs-lisp
  (with-no-warnings
    (require 'cl))
#+end_src

** Load autoloads
I slam all package autoloads into a single file and read them in here.
#+begin_src emacs-lisp
  (load-file-with-stats (expand-file-name "config-autoloads.el" user-emacs-directory))
#+end_src

** Configure paths and config layout
#+begin_src emacs-lisp
  (require 'paths (ignore-errors (expand-file-name "paths.el" user-emacs-directory)))
  (paths-initialise)
#+end_src

*** Configure =no-littering= to use these paths
Customises many packages to create a cleaner =.emacs.d= layout.
See: [[https://github.com/emacscollective/no-littering][emacscollective/no-littering]]

#+begin_src emacs-lisp
  (use-package no-littering
    :demand t
    :init
    (setq no-littering-etc-directory paths-etc-directory)
    (setq no-littering-var-directory paths-cache-directory))
#+end_src

*** Teach =recentf= to use these paths
#+begin_src emacs-lisp
  (use-package recentf
    :after no-littering
    :config
    (add-to-list 'recentf-exclude no-littering-etc-directory)
    (add-to-list 'recentf-exclude no-littering-var-directory))
#+end_src

** Load site settings
Load host-specific settings, which are not checked into version control.
#+begin_src emacs-lisp
  (defconst user-site-file (expand-file-name "site.el" user-emacs-directory))

  (when (file-exists-p user-site-file)
    (load-file-with-stats user-site-file))
#+end_src

* 🖌️ Colour theme

** Define a quick-and-dirty utility for smashing face specs together
#+begin_src emacs-lisp
  (defun append-faces (&rest specs)
    `((t ,@(ht-to-plist (seq-reduce
                         (pcase-lambda (acc `((,_pred . ,attrs)))
                           (ht-merge acc (ht-from-plist attrs)))
                         specs
                         (ht-create))))))
#+end_src

** Define general theme settings
#+begin_src emacs-lisp
  (defun config-theme-apply-settings ()
    (let* ((dark-fg "#bbc2cf")
           (light-fg "#556b72")
           (title `((t :height 1.5)))
           (heading `((t :height 1.2)))
           (block-markup `((t :inherit font-lock-comment-face :background nil :italic nil :weight light :bold nil)))
           (outline-heading `((t :weight bold :foreground nil))))
      (custom-theme-set-faces 'user
                              `(org-transclusion-fringe
                                ((((background dark))
                                  (:foreground ,(doom-blend "#282c34" "#51afef" 0.5) :weight bold ))
                                 (((background light))
                                  (:foreground ,(doom-blend "#FDF6E3" "#268bd2" 0.4) :weight bold))))
                              `(org-roam-search-highlight
                                ((((background dark))
                                  (:foreground "#98be65" :background "#3e493d" :weight bold :inherit magit-diff-added-highlight))
                                 (((background light))
                                  (:foreground "#859900" :background "#e5e3b5" :weight bold :inherit magit-diff-added-highlight))))
                              `(org-superstar-header-bullet
                                ((((background light))
                                  (:foreground "#96A7A9"))
                                 (((background dark))
                                  (:foreground "#5B6268"))))
                              `(mu4e-highlight-face
                                ((((background light))
                                  (:foreground "#268bd2"))
                                 (((background dark))
                                  (:foreground "#51afef"))))
                              `(org-agenda-clocking
                                ((((background dark))
                                  (:foreground ,dark-fg :extend t))
                                 (((background light))
                                  (:foreground ,light-fg :extend t))))
                              '(org-document-info-keyword ((t :italic nil)) t)
                              '(org-meta-line ((t :italic nil)) t)
                              '(org-link ((t :weight unspecified :underline nil)) t)
                              '(compilation-warning ((t :italic nil)))
                              '(magit-header-line ((t :background nil :box nil)))
                              `(org-document-title ,title)
                              `(org-roam-header-line ((t :inherit org-document-title)))
                              `(selectrum-group-title ((t :inherit magit-section-heading)))
                              `(consult-line-number ((t :inherit font-lock-comment-face)))
                              `(shortdoc-section ((t :inherit fixed-pitch)))
                              `(org-roam-note-filter ((t :inherit magit-section-heading :bold nil)))
                              `(org-roam-review-heading ,outline-heading)
                              `(org-roam-review-heading-separator ,(append-faces outline-heading `((t :bold nil))))

                              `(outline-1 ,outline-heading)
                              `(outline-2 ,outline-heading)
                              `(outline-3 ,outline-heading)
                              `(outline-4 ,outline-heading)
                              `(outline-5 ,outline-heading)
                              `(outline-6 ,outline-heading)
                              `(outline-7 ,outline-heading)
                              `(outline-8 ,outline-heading)
                              `(org-roam-title ((t :inherit outline-2 :weight semi-bold)))
                              `(org-roam-olp ((t :inherit org-roam-title :weight bold)))
                              `(org-agenda-structure ,(append-faces outline-heading heading))
                              '(link ((t :weight unspecified)) t)
                              '(highlight ((t :inherit nil :foreground nil :background nil :bold t)))
                              `(org-drawer ,block-markup)
                              '(org-list-dt ((t :italic t :foreground nil)))
                              '(org-agenda-done ((t :inherit org-done :bold nil)) t)
                              '(org-todo ((t :weight light)))
                              '(org-done ((t :weight light)))
                              '(mode-line ((t :inherit default)))
                              '(font-lock-builtin-face ((t :italic nil)) t)
                              '(font-lock-keyword-face ((t :weight normal :bold nil)) t)
                              `(org-transclusion-keyword ((t :inherit org-meta-line)))
                              `(org-block-begin-line ,block-markup)
                              '(org-block ((t :background nil)))
                              `(org-block-end-line ,block-markup))))

  (config-theme-apply-settings)
#+end_src

KLUDGE: Something weird is clobbering settings in org-mode. Reapply the user
theme when starting up org-mode.

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook #'config-theme-apply-settings)
#+end_src

** =doom-themes= - Enable appropriate theme for OS theme
#+begin_src emacs-lisp
  (use-package doom-themes
    :demand t
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :config
    (load-theme (choose-by-system-theme :light 'doom-solarized-light :dark 'doom-one) t))
#+end_src

** Define Lisp functions for switching theme via emacsclient
I have =dark= and =light= scripts I execute to change theme across all my
applications. The following functions will be invoked by those scripts over
=emacsclient=.

#+begin_src emacs-lisp
  (defun config-themes-light ()
    (dolist (theme custom-enabled-themes)
      (disable-theme theme))
    (load-theme 'doom-solarized-light t))

  (defun config-themes-dark ()
    (dolist (theme custom-enabled-themes)
      (disable-theme theme))
    (load-theme 'doom-one t))
#+end_src

* 🪟 display-buffer customisations

** Define a full-frame display-buffer action
#+begin_src emacs-lisp
  (defun display-buffer-fullframe (buffer alist)
    (when-let* ((window (or (display-buffer-reuse-window buffer alist)
                            (display-buffer-same-window buffer alist)
                            (display-buffer-pop-up-window buffer alist)
                            (display-buffer-use-some-window buffer alist))))
      (delete-other-windows window)
      window))
#+end_src

** Prevent display-buffer from creating new frames
#+begin_src emacs-lisp
  (defun config--display-buffer-fallback (buffer &rest _)
    (when-let* ((win (split-window-sensibly)))
      (with-selected-window win
        (switch-to-buffer buffer)
        (help-window-setup (selected-window))))
    t)

  (setq display-buffer-fallback-action
        '((display-buffer--maybe-same-window
           display-buffer-reuse-window
           display-buffer-in-previous-window
           display-buffer-use-some-window
           display-buffer-pop-up-window
           config--display-buffer-fallback)))
#+end_src

** Define helper to update =display-buffer-alist= entries
#+begin_src emacs-lisp
  (defun display-buffer-set (regexp-or-predicate actions)
    (setf (alist-get regexp-or-predicate display-buffer-alist nil nil #'equal) actions))
#+end_src

** compilation
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*compilation*" eos)
                      '((display-buffer-in-direction)
                        (side . bottom)
                        (inhibit-same-window . t)
                        (window-height . 0.4)))
#+end_src

** lisp debugger
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*Backtrace*" eos)
                      '((display-buffer-in-direction)
                        (inhibit-same-window . t)
                        (side . bottom)
                        (window-height . 0.4)))
#+end_src

** =flycheck=
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*Flycheck errors*" eos)
                      '((display-buffer-in-side-window)
                        (inhibit-same-window . t)
                        (side . bottom)
                        (window-height . 0.4)))
#+end_src

** help
#+begin_src emacs-lisp
  (display-buffer-set (rx bos (or (and "*Help*" eos)
                                  "*helpful "))
                      '((display-buffer-reuse-mode-window
                         display-buffer-pop-up-window)
                        (dedicated . t)
                        (modes . (helpful-mode help-mode Info-mode))
                        (side . rightmost)
                        (window-width . 80)))

  (display-buffer-set (rx bos "*lsp-help*" eos)
                      '((display-buffer-at-bottom)
                        (inhibit-same-window . t)
                        (window-height   . 0.4)))
#+end_src

** =ielm=
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*ielm*" eos)
                      '((display-buffer-in-direction)
                        (inhibit-same-window . t)
                        (slot . 1)
                        (side . rightmost)
                        (window-height . 0.4)
                        (window-width . 80)))
#+end_src

** =cider=
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*cider-repl ")
                      '((display-buffer-in-direction)
                        (inhibit-same-window . t)
                        (slot . 1)
                        (side . rightmost)
                        (window-height . 0.4)
                        (window-width . 80)))
#+end_src

** ledger
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*Ledger Report*" eos)
                      '((display-buffer-in-direction)
                        (inhibit-same-window . t)
                        (side . rightmost)
                        (window-width . fit-window-to-buffer)))
#+end_src

** mu4e
#+begin_src emacs-lisp
  (display-buffer-set (rx bos " *mu4e-main*" eos)
                      '((display-buffer-fullframe)))
#+end_src

** nix-repl
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*Nix-REPL*" eos)
                      '((display-buffer-at-bottom)
                        (inhibit-same-window . t)
                        (window-height   . 0.4)))
#+end_src

** pass
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*Password-Store*" eos)
                      '((display-buffer-fullframe)))
#+end_src

** org-roam
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*org-roam: " (+ nonl))
                      '((display-buffer-in-side-window)
                        (inhibit-same-window . t)
                        (slot . 1)
                        (side . left)
                        (window-width . 50)))

  (display-buffer-set (rx bos "*org-roam*" eos)
                      '((display-buffer-in-side-window)
                        (inhibit-same-window . t)
                        (slot . 1)
                        (side . left)
                        (window-height . 20)
                        (window-width . 50)
                        (body-function . (lambda (win)
                                           (save-window-excursion
                                             (select-window win)
                                             (goto-char (point-min))
                                             (magit-section-hide-children (magit-current-section)))))))
#+end_src

** org-roam-review
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*org-roam-review*" eos)
                      '((display-buffer-in-side-window)
                        (inhibit-same-window . t)
                        (side . left)
                        (window-width . 50)))
#+end_src

** org-roam-search
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*org-roam-search*" eos)
                      '((display-buffer-in-direction)
                        (inhibit-same-window . t)
                        (side . rightmost)
                        (window-width . fit-window-to-buffer)))
#+end_src

** org-roam-links
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*org-roam-links*" eos)
                      '((display-buffer-in-direction)
                        (inhibit-same-window . t)
                        (side . rightmost)
                        (window-width . fit-window-to-buffer)))
#+end_src

** pp
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*Pp Eval Output*" eos)
                      '((display-buffer-at-bottom)
                        (inhibit-same-window . t)
                        (window-height . 0.4)))
#+end_src

** vlc
#+begin_src emacs-lisp
  (display-buffer-set (rx bos "*vlc*" eos)
                      '((display-buffer-in-side-window)
                        (inhibit-same-window . t)
                        (side . bottom)
                        (window-height . 0.1)))

  (display-buffer-set (rx bos "*vlc-debug*" eos)
                      '((display-buffer-reuse-mode-window
                         display-buffer-pop-up-window)
                        (dedicated . t)
                        (modes . (helpful-mode help-mode Info-mode))
                        (side . rightmost)
                        (window-width . 80)))
#+end_src

* mode-line and header-line
Use a header line instead of a mode line.

#+begin_src emacs-lisp
  (defvar selected-window-for-mode-line-format)

  (defun update-selected-window-for-mode-line-format (windows)
    (when (not (minibuffer-window-active-p (frame-selected-window)))
      (setq selected-window-for-mode-line-format (selected-window))))

  (add-function :before pre-redisplay-function #'update-selected-window-for-mode-line-format)

  (defconst mode-line-selected-window-indicator '(:eval (if (equal (get-buffer-window) selected-window-for-mode-line-format)
                                                            "● "
                                                          "   ")))

  (setq-default header-line-format
                (let ((env-info 'mode-line-modified)
                      (buffer-info '(mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position))
                      (additional-info '(mode-line-modes mode-line-misc-info)))
                  `("%e" mode-line-front-space mode-line-selected-window-indicator ,env-info ,@buffer-info (vc-mode vc-mode) "  " ,@additional-info mode-line-end-spaces)))

  (setq-default mode-line-format nil)
#+end_src

** =minions= - Hides most minor modes behind a menu
#+begin_src emacs-lisp
  (use-package minions
    :demand t
    :custom
    (minions-mode-line-lighter "...")
    (minions-direct '(auto-revert-mode git-auto-commit-mode flycheck-mode))
    :config
    (define-minor-mode minions-header-line-mode
      "Change the display of minor modes in the header line."
      :global t
      (if minions-header-line-mode
          (setq-default header-line-format
                        (cl-subst 'minions-mode-line-modes
                                  'mode-line-modes
                                  (default-value 'header-line-format)
                                  :test #'equal))
        (cl-nsubst 'mode-line-modes 'minions-mode-line-modes header-line-format)))
    (minions-header-line-mode +1))
#+end_src

* Common advice
#+begin_src emacs-lisp
  (defun advice-ignore-errors (f &rest args)
    (ignore-errors
      (apply f args)))

  (defun advice-inhibit-logging (f &rest args)
    (let ((message-log-max))
      (apply f args)))

  (defun advice-clear-minibuffer (&rest _)
    (message ""))
#+end_src

** Run a hook when the theme changes
#+begin_src emacs-lisp
  (defvar after-load-theme-functions nil)

  (defun config-run-after-load-theme-hook (theme &rest _)
    (run-hook-with-args 'after-load-theme-functions theme))

  (advice-add 'load-theme :after #'config-run-after-load-theme-hook)
#+end_src

* Definitions needed for config

** Org-roam index
#+begin_src emacs-lisp
  (defconst org-roam-index-node-id "0F0670F7-A280-4DD5-8FAC-1DB3D38CD37F")
#+end_src

** Utility functions
#+begin_src emacs-lisp
  (defun face-ancestors (face)
    "List all faces that FACE transitively inherits from."
    (let (result)
      (while (and face (not (equal face 'unspecified)))
        (setq result (cons face result))
        (setq face (face-attribute face :inherit)))
      (nreverse result)))
#+end_src

#+begin_src emacs-lisp
  (defun bounds-of-surrounding-lines (lines-before lines-after)
    (let ((start
           (save-excursion
             (ignore-errors
               (forward-line (- lines-before)))
             (line-beginning-position)))
          (end
           (save-excursion
             (ignore-errors
               (forward-line lines-after))
             (line-end-position))))
      (list start end)))
#+end_src

** Overlay management
#+begin_src emacs-lisp
  (autoload 'emacs-overlay-update "emacs-overlay" nil t)
#+end_src

* Customise builtin features

** Use UTF-8 everywhere by default
Source: [[https://www.reddit.com/r/emacs/comments/siuvpu/isnt_there_a_better_way_to_set_utf8/hvbns5f/?utm_source=reddit&utm_medium=web2x&context=3][Isn't there a better way to set UTF-8 ? : emacs]]
#+begin_src emacs-lisp
  (set-language-environment "UTF-8")
  (set-locale-environment "en_NZ.UTF-8")
#+end_src

** Always use one-char =y-or-n-p=
#+begin_src emacs-lisp
  (defalias #'yes-or-no-p #'y-or-n-p)
#+end_src

** Don't use the system trash can
#+begin_src emacs-lisp
  (setq delete-by-moving-to-trash nil)
#+end_src

** Do not truncate the results of =eval-expression=
#+begin_src emacs-lisp
  (setq eval-expression-print-length nil)
  (setq eval-expression-print-level nil)
#+end_src

** Instantly display current keystrokes in mini buffer
#+begin_src emacs-lisp
 (setq echo-keystrokes 0.02)
#+end_src

** Save cookies to a cache file.
#+begin_src emacs-lisp
  (use-package url
    :custom
    (url-cookie-file (expand-file-name "cookies" paths-cache-directory)))
#+end_src

** Prefer more recent Lisp files to outdated ELC files when loading
#+begin_src emacs-lisp
  (setq load-prefer-newer t)
#+end_src

** Automatically disconnect insecure connections
#+begin_src emacs-lisp
  (use-package nsm
    :custom
    (nsm-noninteractive t))
#+end_src

** Disable file dialogs
#+begin_src emacs-lisp
  (setq use-file-dialog nil)
  (setq use-dialog-box nil)
#+end_src

** Enable useful commands that are disabled by default
#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'erase-buffer 'disabled nil)
#+end_src

** Set global keybindings for =toggle-debug-on-error= and friends
#+begin_src emacs-lisp
  (general-define-key "C-c e e" 'toggle-debug-on-error)
  (general-define-key "C-c e q" 'toggle-debug-on-quit)
#+end_src

** General file formatting

*** Always insert a final newline, as per the Unix convention.
#+begin_src emacs-lisp
  (setq require-final-newline t)
#+end_src

*** Set reasonable default indentation settings
#+begin_src emacs-lisp
  (setq-default fill-column 80)
  (setq-default indent-tabs-mode nil)
#+end_src

*** Make scripts executable after save
#+begin_src emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+end_src

*** Don't require two spaces to signal the end of a sentence
I don't use sentence-based commands that often anyway.
#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src

*** Don't nag when trying to create a new file or buffer
#+begin_src emacs-lisp
  (setq confirm-nonexistent-file-or-buffer nil)
#+end_src

** Whitespace handling

*** Insert a leading space after comment start for new comment lines
#+begin_src emacs-lisp
  (autoload 'thing-at-point-looking-at "thingatpt")

  (defun config--comment-insert-space (&rest _)
    (when (and comment-start
               (thing-at-point-looking-at (regexp-quote comment-start)))
      (unless (or (thing-at-point-looking-at (rx (+ space))))
        (just-one-space))))

  (advice-add #'comment-indent-new-line :after #'config--comment-insert-space)
#+end_src

*** Bind =cycle-spacing= to ~M-SPC~
#+begin_src emacs-lisp
  (general-define-key "M-SPC" 'cycle-spacing)
#+end_src

** Disable unwanted features

*** Inhibit the default startup screen
#+begin_src emacs-lisp
  (setq initial-scratch-message nil)
  (setq inhibit-startup-message t)
  (setq initial-major-mode 'fundamental-mode)
#+end_src

*** Disable cursor blinking
#+begin_src emacs-lisp
  (blink-cursor-mode -1)
#+end_src

*** Never show the useless hello file
#+begin_src emacs-lisp
  (defalias #'view-hello-file #'ignore)
#+end_src

*** Unset 2-window scrolling shortcuts
#+begin_src emacs-lisp
  (global-unset-key (kbd "<f2>"))
  (global-unset-key (kbd "S-<f2>"))
#+end_src

*** Disable audible bell
#+begin_src emacs-lisp
  (setq ring-bell-function #'ignore)
#+end_src

*** Don't pollute directories with lockfiles
I only run one instance of Emacs and never need to prevent concurrent file access.
#+begin_src emacs-lisp
  (setq create-lockfiles nil)
#+end_src

*** Don't nag when following symlinks to files under version control
#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
#+end_src

*** Don't try to ping things that look like domain names
#+begin_src emacs-lisp
  (use-package ffap
    :custom
    (ffap-machine-p-known 'reject))
#+end_src

*** Disable warnings from obsolete advice system
These are caused by packages and are generally not actionable by me.
#+begin_src emacs-lisp
  (setq ad-redefinition-action 'accept)
#+end_src

*** Don't confirm before killing subprocesses on exit
#+begin_src emacs-lisp
  (setq confirm-kill-processes nil)

  (defun config--suppress-no-process-prompt (fn &rest args)
    (cl-labels ((process-list () nil))
      (apply fn args)))

  (advice-add #'save-buffers-kill-emacs :around #'config--suppress-no-process-prompt)
#+end_src

*** Disable suspend-frame on C-z
#+begin_src emacs-lisp
  (global-unset-key (kbd "C-z"))
#+end_src

** Convert ANSI color codes to text properties in shell output
#+begin_src emacs-lisp
  (autoload 'ansi-color-apply-on-region "ansi-color")

  (defun config--display-ansi-codes (buf &rest _)
    (and (bufferp buf)
         (string= (buffer-name buf) "*Shell Command Output*")
         (with-current-buffer buf
           (ansi-color-apply-on-region (point-min) (point-max)))))

  (advice-add #'display-message-or-buffer :before #'config--display-ansi-codes)
#+end_src

** Minibuffer settings

*** Keep a longer history by default
#+begin_src emacs-lisp
  (setq history-length 1000)
#+end_src

*** Hide files with boring extensions from find-file
#+begin_src emacs-lisp
  (defun config--ff-hide-boring-files-in-completion (result)
    "Filter RESULT using `completion-ignored-extensions'."
    (if (and (listp result) (stringp (car result)) (cdr result))
        (let ((matches-boring (rx-to-string `(and (or "."
                                                      ".."
                                                      ".DS_Store"
                                                      "__pycache__/"
                                                      ".cache/"
                                                      ".ensime_cache/"
                                                      ,@completion-ignored-extensions)
                                                  eos))))
          (seq-remove (lambda (it)
                        (and (stringp it) (string-match-p matches-boring it)))
                      result))
      result))

  (advice-add #'completion--file-name-table :filter-return #'config--ff-hide-boring-files-in-completion)
#+end_src

*** Remove lingering =*completions*= buffer whenever we exit the minibuffer
#+begin_src emacs-lisp
  (defun config--cleanup-completions-buffer ()
    (when-let* ((buf (get-buffer "*Completions*")))
      (kill-buffer buf)))

  (add-hook 'minibuffer-exit-hook #'config--cleanup-completions-buffer)
#+end_src

** Backup settings

*** Disable backup files
Meh, I use git.
#+begin_src emacs-lisp
  (setq make-backup-files nil)
  ;; (setq kept-new-versions 6)
  ;; (setq delete-old-versions t)
  ;; (setq version-control t)
#+end_src

*** Create autosave files inside the XDG cache directory.
#+begin_src emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,(expand-file-name "auto-save" paths-cache-directory) t)))
#+end_src

** Write custom settings to a separate file
Keep custom settings in a separate file. This keeps =init.el= clean.
#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))

  (when (file-exists-p custom-file)
    (load custom-file nil t))
#+end_src

** Copy-paste & clipboard settings

*** Share the Emacs kill ring with the host OS clipboard
#+begin_src emacs-lisp
  (setq select-enable-clipboard t)
  (setq save-interprogram-paste-before-kill t)
#+end_src

*** Prevent duplicated entries in the kill ring
#+begin_src emacs-lisp
  (setq kill-do-not-save-duplicates t)
#+end_src

*** Clean up whitespace when inserting yanked text
#+begin_src emacs-lisp
  (defun config--yank-ws-cleanup (&rest _)
    (whitespace-cleanup)
    (delete-trailing-whitespace))

  (advice-add #'insert-for-yank :after #'config--yank-ws-cleanup)
#+end_src

** Smooth scrolling
Anchor the cursor to the top or bottom of the window during scrolling, rather
than paginating through the buffer.

#+begin_src emacs-lisp
  (setq scroll-preserve-screen-position t)
  (setq scroll-conservatively 101)
#+end_src

** Disable font-panel keybinding in macOS
#+begin_src emacs-lisp
  (global-set-key (kbd "s-t") nil)
#+end_src

** =comint= - Base package for interpreter inferior processes
#+begin_src emacs-lisp
  (use-package comint
    :custom
    (comint-prompt-read-only t))
#+end_src

** Help

*** Always focus on help windows
#+begin_src emacs-lisp
  (setq help-window-select t)
#+end_src

*** Don't show 'press q to close' message
#+begin_src emacs-lisp
  (advice-add 'help-window-display-message :override #'ignore)
#+end_src

** =apropos= - searches for symbols matching a pattern
Extend =apropos= to search for more kinds of symbols.
#+begin_src emacs-lisp
  (use-package apropos
    :custom
    (apropos-do-all t))
#+end_src

** =saveplace= - Persist the last location visited in a buffer
#+begin_src emacs-lisp
  (use-package saveplace
    :demand t
    :config (save-place-mode +1))
#+end_src

** =savehist= - Save the minibuffer history across sessions
#+begin_src emacs-lisp
  (use-package savehist
    :demand t
    :config (savehist-mode +1)
    :custom
    (savehist-additional-variables '(kill-ring
                                     compile-command
                                     search-ring
                                     regexp-search-ring)))
#+end_src

** Bidirectional text editing
Configure Emacs so that each paragraph may have a difference text direction.
#+begin_src emacs-lisp
  (setq-default bidi-paragraph-separate-re "^")
  (setq-default bidi-paragraph-start-re "^")
#+end_src

** Large file support
#+begin_src emacs-lisp
  (defconst config--large-file-allowed-extensions
    '("pdf" "png" "jpg" "jpeg"))

  (defun config--dont-abort-if-allowed-extension (f &rest args)
    (-let [(_size _op filename) args]
      (unless (--any-p (f-ext-p filename it) config--large-file-allowed-extensions)
        (apply f args))))

  (advice-add #'abort-if-file-too-large :around #'config--dont-abort-if-allowed-extension)
#+end_src

** =recentf= - Recent files
#+begin_src emacs-lisp
  (use-package recentf
    :hook (after-init . recentf-mode)
    :custom
    (recentf-filename-handlers '(abbreviate-file-name))
    (recentf-max-saved-items 100))
#+end_src

*** Specify which files to exclude
#+begin_src emacs-lisp
  (use-package recentf
    :custom
    (recentf-exclude '(config-recentf--boring-filename-p
                       config-recentf--boring-extension-p
                       file-remote-p
                       config-recentf--sudo-file-p
                       config-recentf--child-of-boring-relative-dir-p
                       config-recentf--child-of-boring-abs-dir-p))
    :config
    (defun config-recentf--boring-filename-p (f)
      (memq (f-filename f) '("TAGS" ".DS_Store")))

    (defun config-recentf--boring-extension-p (f)
      (seq-intersection (f-ext f) '("gz" "zip" "tar")))

    (defun config-recentf--sudo-file-p (f)
      (string-prefix-p "/sudo:root@" f))

    (defun config-recentf--child-of-boring-relative-dir-p (f)
      (string-match-p (rx "/" (or ".g8" ".git" "Maildir" "build" "dist" "target" "vendor")
                          "/")
                      f))

    (defconst config-recentf--abs-dirs
      (seq-map (lambda (it) (f-slash (file-truename it)))
               (list "/var/folders/"
                     "/usr/local/Cellar/"
                     "/tmp/"
                     "/nix/store/"
                     paths-cache-directory
                     paths-etc-directory)))

    (defun config-recentf--child-of-boring-abs-dir-p (f)
      (let ((ignore-case (eq system-type 'darwin)))
        (seq-find (lambda (d)
                    (or
                     (string-prefix-p d f ignore-case)
                     (string-prefix-p d (file-truename f) ignore-case)))
                  config-recentf--abs-dirs))))
#+end_src

** Multilingual input support
Set up LaTeX-style input method and add extra MULE rules for common chars.
#+begin_src emacs-lisp
  (use-package mule
    :custom
    (default-input-method "TeX")

    :config
    (defun config-mule--set-tex-method-vars ()
      (when-let* ((quail-current-package (assoc "TeX" quail-package-alist)))
        (quail-defrule ";" (quail-lookup-key "\\"))
        ;; NOTE: Use hex literals instead of unicode chars so Nix doesn't choke
        ;; parsing this form.
        (quail-define-rules ((append . t))
                            ("\\ou" #x16f) ; ů
                            ("\\null" #x2205) ; ∅
                            ("\\rarr" #x2192) ; →
                            ("\\larr" #x2190) ; ←
                            ("\\lr" #x2194) ; ↔
                            ("\\lam" #x3bb) ; λ
                            ("\\Lam" #x39b) ; Λ
                            ("\\all" #x2200) ; ∀
                            ("\\rtack" #x22a2) ; ⊢
                            )))
    (add-hook 'input-method-activate-hook #'config-mule--set-tex-method-vars))
#+end_src

** =autorevert= - Revert buffers automatically if the file changes on disk
#+begin_src emacs-lisp
  (use-package autorevert
    :delight (auto-revert-mode " auto-revert")
    :hook (after-init . global-auto-revert-mode)
    :custom
    (auto-revert-verbose nil))
#+end_src

** =goto-addr= - Turns URLs and mailto links into clickable buttons
#+begin_src emacs-lisp
  (use-package goto-addr
    :hook (prog-mode . goto-address-prog-mode))
#+end_src

** =shr= - Built-in HTML renderer
#+begin_src emacs-lisp
  (use-package shr
    :config
    ;; Undefine key that prevents forward-word in evil
    (define-key shr-map (kbd "w") nil))
#+end_src

** =hideshow= - Basic code folding

*** Enable hideshow in all programming buffers
#+begin_src emacs-lisp
  (use-package hideshow
    :hook (prog-mode . hs-minor-mode))
#+end_src

*** Use advice to ignore some boring errors
#+begin_src emacs-lisp
  (use-package hideshow
    :config
    (advice-add 'hs-hide-all :around #'advice-ignore-errors)
    (advice-add 'hs-hide-block :around 'advice-ignore-errors)
    (advice-add 'hs-minor-mode :around #'advice-ignore-errors)
    (advice-add 'hs-show-all :around #'advice-ignore-errors)
    (advice-add 'hs-show-block :around #'advice-ignore-errors)
    (advice-add 'hs-toggle-hiding :around #'advice-ignore-errors))
#+end_src

** =authinfo= - Store sensitive keys & passwords in an encrypted file
#+begin_src emacs-lisp
  (use-package auth-source
    :custom
    (auth-sources '("~/.authinfo.gpg")))
#+end_src

** =pixel-scroll= - Enables pixel-wise scrolling
#+begin_src emacs-lisp
  (use-package pixel-scroll
    :demand t
    :config (pixel-scroll-mode +1))
#+end_src

** Manuals

*** =man= - Manpages
#+begin_src emacs-lisp
  (use-package man
    :general (:keymaps 'Man-mode-map
              "M-n" #'Man-next-section
              "M-p" #'Man-previous-section))
#+end_src

*** =woman= - system manual page reader
#+begin_src emacs-lisp
  (use-package woman
    :custom
    (woman-fill-frame t)
    (woman-default-indent 7))
#+end_src

*** =info= - Info manual system
Emacs and many packages provide manuals in the =info= format. Configure this
system below.

#+begin_src emacs-lisp
  (use-package info
    :general
    (:states 'normal :keymaps 'Info-mode-map
     "^" 'Info-up
     "C-n" 'Info-forward-node
     "C-p" 'Info-backward-node))
#+end_src

*** =info+= - adds extra functionality to Info                     :disabled:
Temporarily disabled because it throws an error on load.

#+begin_src emacs-lisp
  (use-package info+
    :after info
    :demand t
    :custom
    (Info-fontify-angle-bracketed-flag nil))
#+end_src

** Image viewing
#+begin_src emacs-lisp
  (use-package image
    :general (:keymaps 'image-mode-map :states '(normal motion)
              "-" #'image-decrease-size
              "+" #'image-increase-size))
#+end_src

** =compile= - Mode for compilation buffers
#+begin_src emacs-lisp
  (use-package compile
    :custom
    (compilation-environment '("TERM=screen-256color"))
    (compilation-always-kill t)
    (compilation-ask-about-save nil)
    (compilation-scroll-output 'first-error))
#+end_src

*** Colourise compilation output
#+begin_src emacs-lisp
  (use-package compile
    :config
    (defun colourise-compilation-output ()
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region (save-excursion
                                      (goto-char compilation-filter-start)
                                      (line-beginning-position))
                                    (point))))

    (add-hook 'compilation-filter-hook 'colourise-compilation-output))
#+end_src

** =ediff= - Interactive diff interface
Configure how =ediff= should display windows when started.
#+begin_src emacs-lisp
  (use-package ediff
    :custom
    (ediff-window-setup-function #'ediff-setup-windows-plain)
    (ediff-split-window-function #'split-window-horizontally))
#+end_src

*** Teach =ediff= how to copy contents from both buffers in a three-way merge
#+begin_src emacs-lisp
  (use-package ediff
    :functions
    (ediff-setup-windows-plain ediff-copy-diff ediff-get-region-contents)
    :config
    (defun ediff-copy-both-to-C ()
      "Copy both ediff buffers in a 3-way merge to the target buffer."
      (interactive)
      (let ((str
             (concat
              (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
              (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
        (ediff-copy-diff ediff-current-difference nil 'C nil str)))

    (defun config-ediff--setup-keybinds ()
      (define-key ediff-mode-map (kbd "B") #'ediff-copy-both-to-C))

    (add-hook 'ediff-keymap-setup-hook #'config-ediff--setup-keybinds))
#+end_src

*** Reveal the context around the selected hunk when diffing org buffers
#+begin_src emacs-lisp
  (use-package ediff
    :config
    (autoload 'org-reveal "org")

    (defun config-ediff--org-reveal-around-difference (&rest _)
      (dolist (buf (list ediff-buffer-A ediff-buffer-B ediff-buffer-C))
        (when (and buf (buffer-live-p buf))
          (with-current-buffer buf
            (when (derived-mode-p 'org-mode)
              (org-reveal t))))))

    (advice-add 'ediff-next-difference :after #'config-ediff--org-reveal-around-difference)
    (advice-add 'ediff-previous-difference :after #'config-ediff--org-reveal-around-difference))
#+end_src

** =world-time-mode= - World clock UI
#+begin_src emacs-lisp
  (use-package world-time-mode
    :general
    (:states 'normal :keymaps 'world-time-table-mode-map "q" 'quit-window)
    :custom
    (display-time-world-list '(("Pacific/Auckland" "NZT")
                               ("America/Los_Angeles" "Pacific Time")
                               ("Europe/Istanbul" "Turkey")
                               ("Asia/Beirut" "Lebanon")
                               ("Europe/Berlin" "Euro Central")
                               ("UTC" "UTC")))
    :config
    (add-hook 'world-time-table-mode-hook 'hl-line-mode))
#+end_src

** =eldoc= - Show documentation in the minibuffer
#+begin_src emacs-lisp
  (use-package eldoc
    :hook (emacs-lisp-mode . eldoc-mode)
    :custom
    (eldoc-idle-delay 0.2))
#+end_src

*** TODO Suppress eldoc when point is at a flycheck error

** =M-n= to end in =completing-read= will use the thing at point
#+begin_src emacs-lisp
  (autoload 'ffap-guesser "ffap")

  (defun config--minibuffer-default-add-function ()
    (with-selected-window (minibuffer-selected-window)
      (delete-dups
       (delq nil
             (list (thing-at-point 'symbol)
                   (thing-at-point 'list)
                   (ffap-guesser)
                   (thing-at-point-url-at-point))))))

  (setq minibuffer-default-add-function #'config--minibuffer-default-add-function)
#+end_src

** Registers

*** Utility for reading registers via =consult=
#+begin_src emacs-lisp
  (defun config-read-register (&optional prompt include-strings)
    (require 'consult)
    (if-let* ((registers  (-keep (lambda (reg)
                                   (cond (include-strings
                                          (consult-register-format reg 'completion))
                                         ((stringp (cdr reg)) nil)
                                         (t
                                          (consult-register-format reg 'completion))))
                                 (consult-register--alist))))
        (consult--read registers
                       :prompt (or prompt "Register: ")
                       :category 'multi-category
                       :state
                       (let ((preview (consult--jump-preview)))
                         (lambda (action cand)
                           ;; Preview only markers
                           (funcall preview action
                                    (when-let (reg (get-register cand))
                                      (and (markerp reg) reg)))))
                       :group (consult--type-group consult-register--narrow)
                       :narrow (consult--type-narrow consult-register--narrow)
                       :sort nil
                       :require-match t
                       :history t ;; disable history
                       :lookup #'consult--lookup-candidate)
      (user-error "No non-string registers set")))
#+end_src

*** Add a command to delete registers (excluding strings)
#+begin_src emacs-lisp
  (defun config-delete-register (register)
    (interactive (list (config-read-register "Delete register: ")))
    (set-register register nil))
#+end_src

*** Add a command to look up registers (excluding strings)
#+begin_src emacs-lisp
  (defun config-consult-register-no-strings (&optional arg)
    (interactive "P")
    (consult-register-load (config-read-register) arg))
#+end_src

* Better eval-expression
Define an alternative version of =eval-expression= that uses =emacs-lisp-mode= to
provide font-locking, and handles =smartparens= better.

See: [[https://lists.gnu.org/archive/html/help-gnu-emacs/2014-07/msg00135.html][Re: How properly utilize the minibuffer and inactive minibuffer startup]]

#+begin_src emacs-lisp
  (defvar eval-expression-interactively-map
    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map read-expression-map)
      (define-key map (kbd "<escape>") #'abort-minibuffers)
      (define-key map (kbd "C-g") #'abort-minibuffers)
      map))

  (defun eval-expression-interactively--read (prompt &optional initial-contents)
    (let ((minibuffer-completing-symbol t))
      (minibuffer-with-setup-hook
          (lambda ()
            (let ((inhibit-message t))
              (emacs-lisp-mode)
              (use-local-map eval-expression-interactively-map)
              (setq font-lock-mode t)
              (funcall font-lock-function 1)))
        (read-from-minibuffer prompt initial-contents
                              eval-expression-interactively-map nil
                              'read-expression-history))))

  (autoload 'pp-display-expression "pp")
  (autoload 'pp-to-string "pp")

  (defun eval-expression-interactively (expression &optional arg)
    "Like `eval-expression' with nicer input handling.

  - Use `emacs-lisp-mode' to provide font locking and better
    integration with other packages.

  - Use the `pp' library to display the output in a readable form.

  EXPRESSION is a Lisp form to evaluate.

  With optional prefix ARG, insert the results into the buffer at
  point."
    (interactive (list (read (eval-expression-interactively--read "Eval: "))
                       current-prefix-arg))
    (condition-case _
        (if arg
            (insert (pp-to-string (eval expression lexical-binding)))
          (pp-display-expression (eval expression lexical-binding)
                                 "*Pp Eval Output*" t))
      (error
       (eval-expression expression arg))))
#+end_src

** Bind this command to ~M-:~
#+begin_src emacs-lisp
  (general-define-key :keymaps 'override :states '(normal motion visual)
    "M-:" 'eval-expression-interactively)
#+end_src

** Use this command for evaluating expressions in the Lisp debugger too
#+begin_src emacs-lisp
  (use-package debug
    :config
    (advice-add 'debugger-record-expression
                :around
                (lambda (f exp)
                  (interactive (list (read (eval-expression-interactively--read "Eval: "))))
                  (funcall f exp))
                '((name . use-eval-expression-interactively--read))))
#+end_src

* Improve basic editing configuration for all modes

** Use control key to transpose lines up and down
#+begin_src emacs-lisp
  (autoload 'org-move-item-down "org-list")
  (autoload 'org-move-item-up "org-list")

  (defun transpose-line-up ()
    "Move the current line up."
    (interactive)
    (if (derived-mode-p 'org-mode)
        (org-move-item-up)

      (transpose-lines 1)
      (forward-line -2)
      (indent-according-to-mode)))

  (defun transpose-line-down ()
    "Move the current line up."
    (interactive)
    (if (derived-mode-p 'org-mode)
        (org-move-item-down)

      (forward-line 1)
      (transpose-lines 1)
      (forward-line -1)
      (indent-according-to-mode)))

  (global-set-key (kbd "C-<up>") #'transpose-line-up)
  (global-set-key (kbd "C-<down>") #'transpose-line-down)
#+end_src

** Useful interactive functions
#+begin_src emacs-lisp
  (defun insert-uuid (&optional upcase-p)
    "Insert a UUID at point.

  Prefix arg UPCASE-P determines whether the UUID is downcased or
  upcased on insertion."
    (interactive "*P")
    (let ((uuid (string-trim (shell-command-to-string "uuidgen"))))
      (insert (if upcase-p (upcase uuid) (downcase uuid)))))
#+end_src

#+begin_src emacs-lisp
  (defun insert-date (str)
    "Read date string STR interactively and insert it at point."
    (interactive (list
                  (if (not current-prefix-arg)
                      (format-time-string "%F")
                    (let ((formats (seq-map #'format-time-string
                                            '("%F"
                                              "%F %R"
                                              "%X"
                                              "%c"))))
                      (completing-read "Format: " formats nil t)))))
    (insert str))
#+end_src

Define a command for reversing the characters isrc

*** Define a command to indent every line in the buffer
This should really be a thing out-of-the-box.
#+begin_src emacs-lisp
  (defun indent-buffer ()
    "Indent the entire buffer."
    (interactive "*")
    (save-excursion
      (delete-trailing-whitespace)
      (indent-region (point-min) (point-max) nil)
      (untabify (point-min) (point-max))))
#+end_src

*** Define a command to perform indentation in a context-sensitive way
#+begin_src emacs-lisp
  (autoload 'lsp-format-region "lsp-mode")
  (autoload 'lsp-format-buffer "lsp-mode")

  (defun config-indent-dwim (&optional justify)
    "Indent the thing at point.

  Knows how to fill strings and comments, or indent code.

  Optional arg JUSTIFY will justify comments and strings."
    (interactive "*P")
    (-let [(_ _ _ string-p comment-p) (syntax-ppss)]
      (cond
       (string-p
        (let ((progress (make-progress-reporter "Filling paragraph")))
          (fill-paragraph justify)
          (progress-reporter-done progress)))
       (comment-p
        (let ((progress (make-progress-reporter "Filling comment")))
          (fill-comment-paragraph justify)
          (progress-reporter-done progress)))

       ((region-active-p)
        (cond
         ((bound-and-true-p lsp-mode)
          (lsp-format-region (region-beginning) (region-end)))
         (t
          (indent-region (region-beginning) (region-end)))))
       (t
        (let ((progress (make-progress-reporter "Indenting buffer")))
          (cond
           ((bound-and-true-p format-all-mode)
            (format-all-buffer))
           ((bound-and-true-p lsp-mode)
            (lsp-format-buffer))
           (t
            (indent-buffer)))
          (progress-reporter-done progress))))))

  (define-key prog-mode-map (kbd "M-q") #'config-indent-dwim)
#+end_src

** =ws-butler= - Automatic whitespace cleanup while editing
#+begin_src emacs-lisp
  (use-package ws-butler
    :hook
    (prog-mode . ws-butler-mode)
    (text-mode . ws-butler-mode))
#+end_src

** =unfill= - Paragraph fill/unfill
=unfill= provides a command that is the opposite of fill-paragraph.
#+begin_src emacs-lisp
  (use-package unfill
    :commands (unfill-region unfill-paragraph unfill-toggle))
#+end_src

** =align= - Provides useful functions for aligning text
#+begin_src emacs-lisp
  (use-package align
    :general ("C-x a a" #'align-regexp))
#+end_src

** =hide-comnt= - Toggle whether comments are visible
#+begin_src emacs-lisp
  (use-package hide-comnt
    :commands (hide/show-comments-toggle))
#+end_src

** =dumb-jump= - Generic jump-to-definition support
=dump-jump= provides a good fallback for navigating to definitions in the absence
of an LSP or semantic analysis.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :custom
    (dumb-jump-selector 'completing-read)
    :config
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

** =auto-insert= - File templates
=autoinsert= provides file templates.
#+begin_src emacs-lisp
  (use-package autoinsert
    :preface
    (defvar auto-insert-alist nil)
    :hook (find-file . auto-insert)
    :custom
    (auto-insert-query nil))
#+end_src

Extend =auto-insert= to use the more intuitive =yasnippet= DSL.

#+begin_src emacs-lisp
  (use-package autoinsert-files
    :after (autoinsert)
    :demand t
    :commands (autoinsert-files-populate-templates)
    :init
    (defun autoinsert-maybe-enter-snippet-mode ()
      (require 'autoinsert)
      (when (string-prefix-p auto-insert-directory (buffer-file-name))
        (snippet-mode)))
    (add-hook 'find-file-hook #'autoinsert-maybe-enter-snippet-mode)
    :config
    (advice-add 'auto-insert :before (lambda (&rest _)
                                       (autoinsert-files-populate-templates))))
#+end_src

** =ispell= - Spellchecking commands
#+begin_src emacs-lisp
  (use-package ispell
    :commands (ispell-check-version ispell-find-aspell-dictionaries)

    :custom
    (ispell-program-name "aspell")
    (ispell-dictionary "en_GB")
    (ispell-silently-savep t)

    :config
    (ispell-check-version)
    (setq ispell-dictionary-alist (ispell-find-aspell-dictionaries)))
#+end_src

** =flyspell= - Incremental spellchecking
#+begin_src emacs-lisp
  (use-package flyspell
    :hook
    (markdown-mode . flyspell-mode)
    (org-mode . flyspell-mode)
    :custom
    (flyspell-issue-welcome-flag nil)
    (flyspell-default-dictionary "en_GB"))
#+end_src

*** Prevent =flyspell= from showing suggestions in more contexts
#+begin_src emacs-lisp
  (use-package flyspell
    :after (org)
    :config
    (defun flyspell-on-org-verify (result)
      (and result
           (not (seq-intersection (face-at-point nil t)
                                  '(org-link verb-header)))))
    (advice-add 'org-mode-flyspell-verify :filter-return #'flyspell-on-org-verify))
#+end_src

** =undo-tree= - Visual graph for undo history
#+begin_src emacs-lisp
  (use-package undo-tree
    :hook (org-mode . undo-tree-mode)
    :custom
    (undo-tree-auto-save-history nil)
    :general
    ("C-x t" 'undo-tree-visualize)
    (:states 'normal :keymaps 'org-mode-map
     "C-r" 'undo-tree-redo
     "u" 'undo-tree-undo))
#+end_src

** =format-all= - Generic format-on-save system
#+begin_src emacs-lisp
  (use-package format-all
    :hook
    (typescript-mode . format-all-mode)
    (typescript-mode . format-all-ensure-formatter)
    (nix-mode . format-all-mode)
    (nix-mode . format-all-ensure-formatter)
    (terraform-mode . format-all-mode)
    (terraform-mode . format-all-ensure-formatter)
    :custom
    (format-all-show-errors 'never))
#+end_src

** =emojify= - Render emoji
#+begin_src emacs-lisp
  (use-package emojify
    :hook (after-init . global-emojify-mode)
    :custom
    (emojify-display-style 'image)
    (emojify-emoji-styles '(github))
    (emojify-program-contexts '(comments))
    (emojify-point-entered-behaviour 'uncover)
    :config
    (defun emojify-at-org-drawer-p (&rest _)
      (when (derived-mode-p 'org-mode 'org-agenda-mode)
        (save-excursion
          (goto-char (line-beginning-position))
          (or (org-at-drawer-p) (org-at-property-p)))))

    (add-to-list 'emojify-inhibit-functions #'emojify-at-org-drawer-p))
#+end_src

*** Remove checkbox unicode emoji that conflicts with org-superstar
#+begin_src emacs-lisp
  (defun config-emojify-modify-emojis ()
    (remhash "☑" emojify-emojis))

  (add-hook 'emojify-mode-hook #'config-emojify-modify-emojis)
#+end_src

** =company-emoji= - Provide a nice interface for inserting emoji
#+begin_src emacs-lisp
  (use-package company-emoji
    :after company
    :config
    (add-to-list 'company-backends 'company-emoji))
#+end_src

** =yasnippet= - Text snippets
=yasnippet= provides expandable text snippets. I use them extensively to cut
down on typing.

#+begin_src emacs-lisp
  (use-package yasnippet
    :hook
    (prog-mode . (lambda () (require 'yasnippet)))
    (text-mode . (lambda () (require 'yasnippet)))

    :custom
    (yas-wrap-around-region t)
    (yas-alias-to-yas/prefix-p nil)
    (yas-prompt-functions '(yas-completing-prompt))
    (yas-verbosity 0)
    (yas-minor-mode-map (make-sparse-keymap))

    :general
    (:keymaps 'yas-minor-mode-map :states 'insert
     "TAB"
     (general-predicate-dispatch 'indent-for-tab-command
       (yas-maybe-expand-abbrev-key-filter t) 'yas-expand))
    (:keymaps 'yas-keymap :states 'insert
     "SPC"
     (general-predicate-dispatch 'self-insert-command
       (yas--maybe-clear-field-filter t) 'yas-skip-and-clear-field)
     "<backspace>"
     (general-predicate-dispatch 'backward-delete-char
       (yas--maybe-clear-field-filter t) 'yas-skip-and-clear-field
       (bound-and-true-p smartparens-mode) 'sp-backward-delete-char))

    :config
    (yas-global-mode +1))
#+end_src

*** Customise backwards cycling behaviour
When cycling backward through fields, place point at the end of the previous field.
#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (defun config-yasnippet--end-of-field ()
      (when-let* ((field (yas-current-field)))
        (marker-position (yas--field-end field))))

    (defun config-yasnippet--maybe-goto-field-end ()
      "Move to the end of the current field if it has been modified."
      (when-let* ((field (yas-current-field)))
        (when (and (yas--field-modified-p field)
                   (yas--field-contains-point-p field))
          (goto-char (config-yasnippet--end-of-field)))))

    (defun yasnippet-goto-field-end (&rest _)
      (config-yasnippet--maybe-goto-field-end)
      (when (and (boundp 'evil-mode) evil-mode (fboundp 'evil-insert-state))
        (evil-insert-state)))

    (advice-add 'yas-next-field :after #'yasnippet-goto-field-end)
    (advice-add 'yas-prev-field :after #'yasnippet-goto-field-end))
#+end_src

*** Snippet functions
These functions are used in the definitions of snippets.

**** General
#+begin_src emacs-lisp
  (defun yas-funcs-bolp ()
    "Non-nil if point is on an empty line or at the first word.
  The rest of the line must be blank."
    (let ((line (buffer-substring (line-beginning-position) (line-end-position))))
      (string-match-p (rx bol (* space) (* word) (* space) eol)
                      line)))

  (defmacro yas-funcs-line-rx-p (&rest rx-forms)
    `(let ((line (buffer-substring (line-beginning-position) (line-end-position))))
       (string-match-p (rx-to-string '(and ,@rx-forms))
                       line)))
#+end_src

**** emacs-lisp
#+begin_src emacs-lisp
  (defun yas-funcs-el-custom-group ()
    "Find the first group defined in the current file.
  Fall back to the file name sans extension."
    (or
     (cadr (s-match (rx "(defgroup" (+ space) (group (+ (not space))))
                    (buffer-string)))
     (cadr (s-match (rx ":group" (+ space) "'" (group (+ (any "-" alnum))))
                    (buffer-string)))
     (file-name-sans-extension (file-name-nondirectory buffer-file-name))))

  (defun yas-funcs-el-autoload-file (sym)
    (if-let* ((file (symbol-file (if (stringp sym) (intern sym) sym))))
        (file-name-sans-extension (file-name-nondirectory file))
      ""))

  (defun yas-funcs-el-at-line-above-decl-p ()
    (save-excursion
      (forward-line)
      (back-to-indentation)
      (thing-at-point-looking-at (rx (* space) "("
                                     (or "cl-defun" "defun" "defvar" "defconst"
                                         "define-minor-mode"
                                         "define-globalized-minor-mode"
                                         "define-derived-mode")))))

  (defun yas-funcs-el-package-prefix ()
    (cond
     ((string-prefix-p "*Org Src" (buffer-name))
      "")
     ((bound-and-true-p nameless-current-name)
      (format "%s-" nameless-current-name))
     (t
      (format "%s-" (f-base (or (buffer-file-name) (buffer-name)))))))

  (defun yas-funcs-buttercup-file-p ()
    (string-match-p "^test-" (file-name-nondirectory (buffer-file-name))))
#+end_src

**** TypeScript/JavaScript
#+begin_src emacs-lisp
  (defcustom yas-funcs-js-import-to-module-alist '()
    "Map the name of a default import to a module.

  Expected to be set via directory variable."
    :type '(alist :key-type string :value-type string)
    :group 'yas-funcs
    :safe (lambda (it)
            (and (listp it)
                 (seq-every-p #'car #'stringp)
                 (seq-every-p #'cdr #'stringp))))

  (use-package yasnippet
    :config

    (cl-defun yas-funcs-js-module-name-for-binding (&optional (text yas-text))
      (pcase text
        ('nil      "")
        (""        "")
        ((guard (assoc (string-trim text) yas-funcs-js-import-to-module-alist))
         (cdr (assoc (string-trim text) yas-funcs-js-import-to-module-alist)))
        ("VError"
         "verror")
        ("memoize"
         "promise-memoize")
        ((or "aws" "AWS")
         "aws-sdk")
        ("_"
         "lodash")
        ("rt"
         "runtypes")
        ("z"
         "zod")
        ("thunk"
         "thunky/promise")
        ("cdk"
         "aws-cdk-lib")
        ("dynamodb"
         "aws-cdk-lib/aws-dynamodb")
        ("lambda"
         "aws-cdk-lib/aws-lambda")

        ((guard (s-contains? "{" text))
         "")
        (s
         (-if-let* ((match-binding (rx (* space) "*" (+ space) "as" (+ space) (group (+ (not (any space))))))
                    ((_ name) (s-match match-binding text)))
             (yas-funcs-js-module-name-for-binding name)
           (s-downcase (s-dashed-words s))))))

    (defun yas-funcs-js-ctor-body (argstring)
      (when argstring
        (thread-last argstring
          (s-split (rx (or "," ".")))
          (-map #'s-trim)
          (-remove #'s-blank?)
          (--map (format "this.%s = %s;" it it))
          (s-join "\n"))))

    (defun yas-funcs-js-buffer-imports-logger-p ()
      (let ((str (buffer-substring-no-properties (point-min) (point-max))))
        (string-match-p (rx bol "import" (+ space) symbol-start "logger" symbol-end) str)))

    (defun yas-funcs-js-inside-describe-p ()
      (save-excursion
        (search-backward-regexp (rx bol (* space) symbol-start "describe" symbol-end) nil t))))
#+end_src

*** Don't warn if snippet modifies buffer
I sometimes want to do just-one-space. There's no nice way to do this. The hacky
solution other is to add an inline lisp call inline to =just-one-space=.

#+begin_src emacs-lisp
  (add-to-list 'warning-suppress-types '(yasnippet))
  (add-to-list 'warning-suppress-log-types '(yasnippet))
#+end_src

** =editorconfig= - Support editorconfig files
#+begin_src emacs-lisp
  (use-package editorconfig
    :hook (after-init . editorconfig-mode))
#+end_src

** =direnv= - Support direnv files
Teach Emacs how to load environment variables from [[https://direnv.net/][direnv]].
See: [[https://github.com/wbolster/emacs-direnv][wbolster/emacs-direnv]]

#+begin_src emacs-lisp
  (use-package direnv
    :hook (after-init . direnv-mode)
    :custom
    (direnv-always-show-summary nil))
#+end_src

** =rainbow-mode= - Apply colours to hex strings in buffers
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :hook
    (help-mode . rainbow-mode)
    (emacs-lisp-mode . rainbow-mode)
    (css-mode . rainbow-mode))
#+end_src

** =string-inflection= - Command to change string case at point
#+begin_src emacs-lisp
  (use-package string-inflection
    :general ("M-s" 'string-inflection-all-cycle))
#+end_src

* =evil= - Vim-style modal editing
=evil= provides macros that I want to use in ~:config~ blocks, so teach the
byte-compiler about them to avoid warnings.

#+begin_src emacs-lisp
  (cl-eval-when (compile)
    (require 'evil))
#+end_src

** Customise global vars and keybindings
#+begin_src emacs-lisp
  (autoload 'man-completing "man-completing")

  (use-package evil
    :hook (after-init . evil-mode)
    :custom
    (evil-lookup-func #'man-completing)
    (evil-mode-line-format nil)
    (evil-shift-width 2)
    (evil-undo-system 'undo-redo)
    (evil-symbol-word-search t)
    (evil-want-visual-char-semi-exclusive t)
    (evil-want-Y-yank-to-eol t)
    (evil-motion-state-cursor '("plum3" box))
    (evil-visual-state-cursor '("gray" hbar))
    (evil-normal-state-cursor '("IndianRed" box))
    (evil-insert-state-cursor '("chartreuse3" bar))
    (evil-emacs-state-cursor  '("SkyBlue2" (box . t)))
    :general
    (:states 'normal "go" #'browse-url-at-point))
#+end_src

** Prevent visual state from updating the clipboard
#+begin_src emacs-lisp
  (advice-add 'evil-visual-update-x-selection :override #'ignore)
#+end_src

** Prevent evil's own keybindings from loading
We use =evil-collection= to manage these instead.
#+begin_src emacs-lisp
  (use-package evil
    :custom
    (evil-want-keybinding nil)
    (evil-want-integration t))
#+end_src

** Execute macro bound to ~q~ with ~Q~
Use =Q= in normal state to execute the macro bound to =q= register. This is a
convenient way to quickly define a macro, then execute it immediately--just
double-tap =q= to record, then hit =Q= to execute.

#+begin_src emacs-lisp
  (use-package evil
    :general (:states 'normal "Q" #'config-evil--execute-Q-macro)
    :preface
    (defun config-evil--execute-Q-macro (count)
      "Execute the macro bound to the Q register.

  COUNT is the number of repetitions."
      (interactive (list
                    (if current-prefix-arg
                        (if (numberp current-prefix-arg) current-prefix-arg 0)
                      1)))
      (evil-execute-macro count (evil-get-register ?Q t))))
#+end_src

** Invert motions in RTL languages                                :disabled:
Make motions make more sense by following RTL text direction in Arabic, Farsi
etc.

#+begin_src emacs-lisp
  (use-package evil-bidi
    :after (evil)
    :demand t)
#+end_src

** Customise navigation in help buffers
#+begin_src emacs-lisp
  (use-package evil
    :general
    (:states 'motion :keymaps 'help-mode-map
     "<escape>" 'quit-window
     "^" 'help-go-back
     "gh" 'help-follow-symbol))
#+end_src

** Customise initial states of different modes
#+begin_src emacs-lisp
  (use-package evil
    :config
    (evil-set-initial-state 'anaconda-mode-view-mode 'motion)
    (evil-set-initial-state 'diff-mode 'motion)
    (evil-set-initial-state 'ert-simple-view-mode 'motion)
    (evil-set-initial-state 'eshell-mode 'insert)
    (evil-set-initial-state 'flycheck-error-list-mode 'motion)
    (evil-set-initial-state 'grep-mode 'normal)
    (evil-set-initial-state 'haskell-debug-mode 'motion)
    (evil-set-initial-state 'helpful-mode 'motion)
    (evil-set-initial-state 'ibuffer-mode 'motion)
    (evil-set-initial-state 'nix-repl-mode 'insert)
    (evil-set-initial-state 'occur-mode 'normal)
    (evil-set-initial-state 'org-agenda-mode 'motion)
    (evil-set-initial-state 'prodigy-mode 'motion)
    (evil-set-initial-state 'profiler-report-mode 'motion)
    (evil-set-initial-state 'racer-help-mode 'motion)
    (evil-set-initial-state 'tabulated-list-mode 'motion)
    (evil-set-initial-state 'vterm-mode 'emacs)
    (evil-set-initial-state 'wdired-mode 'normal)

    (with-eval-after-load 'replace
      (evil-add-hjkl-bindings occur-mode-map)))
#+end_src

** Customise pdf navigation
#+begin_src emacs-lisp
  (use-package pdf-tools
    :general
    (:states '(normal) :keymaps 'pdf-view-mode-map
     "+" 'pdf-view-enlarge
     "-" 'pdf-view-shrink
     "0" 'pdf-view-scale-reset
     "j" 'pdf-view-next-line-or-next-page
     "k" 'pdf-view-previous-line-or-previous-page
     "n" 'pdf-view-next-page-command
     "p" 'pdf-view-previous-page-command
     "gr" 'revert-buffer
     "gg" 'pdf-view-first-page
     "gG" 'pdf-view-last-page
     "J" 'pdf-view-goto-page
     "q" 'kill-this-buffer)
    :config
    (evil-set-initial-state 'pdf-view-mode 'normal))
#+end_src

** Archive navigation integration
#+begin_src emacs-lisp
  (use-package evil
    :after (tar-mode)
    :config
    (evil-set-initial-state 'tar-mode 'emacs)
    (evil-add-hjkl-bindings tar-mode-map))
#+end_src

#+begin_src emacs-lisp
  (use-package evil
    :after (arc-mode)
    :general
    (:states 'motion :keymaps 'archive-mode-map
     "q" 'kill-this-buffer
     "o" 'archive-extract-other-window
     "m" 'archive-mark
     "x" 'archive-expunge
     "U" 'archive-unmark-all-files
     "j" 'archive-next-line
     "k" 'archive-previous-line
     "<return>" 'archive-extract)
    :config
    (evil-set-initial-state 'archive-mode 'emacs))
#+end_src

** =compilation= integration
Disable ~h~ (help) binding in =compilation-mode=, which interferes with evil
navigation.

#+begin_src emacs-lisp
  (use-package evil
    :general (:states 'motion :keymaps 'compilation-mode-map
              "h" #'evil-backward-char))
#+end_src

** =hydra= integration
=evil= breaks cursor settings when combined with hydra. To work around this, never
show the cursor in deselected windows.

#+begin_src emacs-lisp
  (setq-default cursor-in-non-selected-windows nil)
#+end_src

** Spellchecker integration

*** Add vim-style ~:spell~ and ~:nospell~ ex commands
#+begin_src emacs-lisp
  (use-package evil
    :config
    (defun evil-flyspell-on ()
      "Enable flyspell."
      (interactive)
      (turn-on-flyspell))

    (defun evil-flyspell-off ()
      "Disable flyspell."
      (interactive)
      (turn-off-flyspell))

    (evil-ex-define-cmd "nospell" #'evil-flyspell-off)
    (evil-ex-define-cmd "spell" #'evil-flyspell-on))
#+end_src

*** Add more key bindings to work with spell-checker from normal state
#+begin_src emacs-lisp
  (use-package evil-ispell
    :after evil
    :general (:states 'normal
              "z SPC" #'flyspell-auto-correct-word
              "zU" #'evil-ispell-correct-word
              "zg" #'evil-ispell-mark-word-as-good
              "zG" #'evil-ispell-mark-word-as-locally-good
              "zn" #'evil-ispell-next-spelling-error
              "zp" #'evil-ispell-previous-spelling-error))
#+end_src

** Use escape key as =keyboard-quit=
#+begin_src emacs-lisp
  (general-define-key :keymaps '(minibuffer-local-map
                                 minibuffer-local-ns-map
                                 minibuffer-local-completion-map
                                 minibuffer-local-must-match-map
                                 minibuffer-local-isearch-map)
    "<escape>" 'keyboard-escape-quit)
#+end_src

** =link-hint= - Teach =evil= how to navigate using links in org buffers and the agenda
#+begin_src emacs-lisp
  (use-package link-hint
    :after (evil)
    :config
    (put 'link-hint-org-link :vars '(org-mode org-agenda-mode)))
#+end_src

** =evil-surround= - Teach =evil= how to wrap objects with matched pairs
#+begin_src emacs-lisp
  (use-package evil-surround
    :after (evil)
    :demand t
    :config (global-evil-surround-mode +1)
    :general
    (:states 'visual :keymaps 'evil-surround-mode-map
     "s" #'evil-surround-region
     "S" #'evil-substitute)
    :custom
    (evil-surround-pairs-alist '((?\( . ("(" . ")"))
                                 (?\[ . ("[" . "]"))
                                 (?\{ . ("{" . "}"))

                                 (?\) . ("(" . ")"))
                                 (?\] . ("[" . "]"))
                                 (?\} . ("{" . "}"))

                                 (?# . ("#{" . "}"))
                                 (?b . ("(" . ")"))
                                 (?B . ("{" . "}"))
                                 (?> . ("<" . ">"))
                                 (?t . evil-surround-read-tag)
                                 (?< . evil-surround-read-tag)
                                 (?f . evil-surround-function))))
#+end_src

*** Prevent evil-surround from interfering with magit-section
The Evil Surround keybinding interferes with selecting lines in a hunk and
staging them in magit.

#+begin_src emacs-lisp
  (use-package evil-surround
    :preface
    (defun config-evil-surround-inhibit-in-magit-section-mode (&rest args)
      (if (derived-mode-p 'magit-section-mode)
          (list -1)
        args))
    :config
    (advice-add 'evil-surround-mode :filter-args #'config-evil-surround-inhibit-in-magit-section-mode))
#+end_src

*** Define an extra =`sym'= pair for =emacs-lisp-mode=
#+begin_src emacs-lisp
  (use-package evil-surround
    :after (evil)
    :preface
    (defun config-evil--init-evil-surround-pairs ()
      (make-local-variable 'evil-surround-pairs-alist)
      (push '(?\` . ("`" . "'")) evil-surround-pairs-alist))
    :hook
    (emacs-lisp-mode-hook . config-evil--init-evil-surround-pairs))
#+end_src

** =evil-collection= - Community-maintained bindings
#+begin_src emacs-lisp
  (use-package evil-collection
    :after (evil)
    :demand t
    :config
    (evil-collection-init))
#+end_src

*** Add alias for renamed function
#+begin_src emacs-lisp
  (defalias 'mu4e--main-action-str 'mu4e~main-action-str)
#+end_src

** =evil-args= - Text motions for function parameter lists
#+begin_src emacs-lisp
  (use-package evil-args
    :after (evil)
    :general (:keymaps
              'evil-inner-text-objects-map "a" #'evil-inner-arg
              :keymaps
              'evil-outer-text-objects-map "a" #'evil-outer-arg))
#+end_src

** =evil-matchit= - Teach ~%~ how to match more kinds of pairs
#+begin_src emacs-lisp
  (use-package evil-matchit
    :after (evil)
    :demand t
    :config
    (global-evil-matchit-mode +1))
#+end_src

** =evil-numbers= - Use ~+~ and ~-~ to change number at point
#+begin_src emacs-lisp
  (use-package evil-numbers
    :after (evil)
    :demand t
    :general (:states 'normal
              "+" #'evil-numbers/inc-at-pt
              "-" #'evil-numbers/dec-at-pt))
#+end_src

** Teach ~<~ and ~>~ to shift text in a context-sensitive way
#+begin_src emacs-lisp
  (use-package evil
    :general (:states 'visual
              "<" #'config-evil--shift-left
              ">" #'config-evil--shift-right)
    :preface
    (defun config-evil--shift-left (&optional beg end)
      "Shift left, keeping the region active.

  BEG and END are the bounds of the active region."
      (interactive "r")
      (evil-shift-left beg end)
      (evil-normal-state)
      (evil-visual-restore))

    (defun config-evil--shift-right (&optional beg end)
      "Shift right, keeping the region active.

  BEG and END are the bounds of the active region."
      (interactive "r")
      (evil-shift-right beg end)
      (evil-normal-state)
      (evil-visual-restore)))
#+end_src

** Replace rectangle-mark-mode binding with insert-char
Since I have visual state for block selection, I don't need a rectangle
selection key. But a nice way to insert Unicode chars would be good.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x SPC") 'insert-char)
#+end_src

** =evil-iedit-state= - Easy renaming of symbol at point
=iedit= adds useful mass-renaming functionality. This package provides evil
compatibility.

#+begin_src emacs-lisp
  (use-package evil-iedit-state
    :commands (evil-iedit-state/iedit-mode))
#+end_src

*** HACK: work around missing function
https://github.com/syl20bnr/evil-iedit-state/issues/36
#+begin_src emacs-lisp
  (defalias 'evil-redirect-digit-argument #'ignore)
#+end_src

* =lsp-mode= - language-server support

** Set which modes use LSP
#+begin_src emacs-lisp
  (defconst lsp-enabled-modes
    '(graphql-mode
      js-mode
      json-mode
      nix-mode
      sh-mode
      terraform-mode
      typescript-mode
      yaml-mode))

  (dolist (mode lsp-enabled-modes)
    (add-hook (intern (format "%s-hook" mode))
              'lsp-deferred))
#+end_src

** Configure lsp-mode variables
#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :general
    (:keymaps 'lsp-mode-map
     "C-c C-c" 'lsp-execute-code-action
     "C-c r" 'lsp-rename
     [remap evil-lookup] 'lsp-describe-thing-at-point
     [remap jump-to-definition] 'lsp-find-definition)
    :custom
    (lsp-headerline-breadcrumb-enable nil)
    (lsp-modeline-code-actions-enable nil)
    (lsp-modeline-diagnostics-enable nil)
    (lsp-modeline-workspace-status-enable nil)
    (lsp-auto-execute-action nil)
    (lsp-enable-on-type-formatting nil)
    (lsp-restart 'auto-restart))
#+end_src

** Inject LSP servers from nix build

#+begin_src emacs-lisp
  (use-package lsp-mode
    :custom
    (lsp-clients-typescript-tls-path (getenv "NIX_EMACS_TS_LANGUAGE_SERVER"))
    (lsp-eslint-validate '("typescript" "javascript" "javascriptreact"))
    (lsp-eslint-server-command (list (getenv "NIX_EMACS_LSP_ESLINT_NODE_PATH")
                                     (getenv "NIX_EMACS_ESLINT_SERVER_SCRIPT")
                                     "--stdio")))
#+end_src

#+begin_src emacs-lisp
  (use-package lsp-json
    :config
    (lsp-dependency 'vscode-json-languageserver
                    `(:system ,(getenv "NIX_EMACS_JSON_LANGUAGE_SERVER"))))
#+end_src

** Make company completions more proactive when an lsp is active

#+begin_src emacs-lisp
  (use-package lsp-mode
    :init
    (defun config-lsp-set-vars ()
      (setq-local company-minimum-prefix-length 0))
    :hook (lsp-mode . config-lsp-set-vars))
#+end_src

** =lsp-ui= - Additional package providing richer UI elements for lsp-mode
#+begin_src emacs-lisp
  (use-package lsp-ui
    :after lsp-mode
    :general
    (:keymaps 'lsp-ui-mode-map
     [remap lsp-describe-thing-at-point] 'lsp-ui-show
     [remap imenu] 'lsp-ui-imenu
     [remap consult-imenu] 'lsp-ui-imenu)
    :custom
    (lsp-ui-imenu-auto-refresh 'after-save)
    (lsp-ui-doc-enable nil)
    :hook
    (json-mode . lsp-ui-doc-mode)
    (yaml-mode . lsp-ui-doc-mode))
#+end_src

* =eshell= - built-in rudimentary shell
#+begin_src emacs-lisp
  (use-package eshell
    :general
    (:states 'insert :keymaps 'eshell-mode-map
     [remap indent-for-tab-command] 'completion-at-point
     "C-n" 'eshell-next-matching-input-from-input
     "C-p" 'eshell-previous-matching-input-from-input
     "C-a" 'eshell-bol
     "C-e" 'end-of-line))
#+end_src

** Prompt
#+begin_src emacs-lisp
  (use-package eshell
    :custom
    (eshell-prompt-function 'config-eshell-prompt)
    (eshell-skip-prompt-function 'config-eshell-skip-prompt)
    (eshell-prompt-regexp (rx bol (* (not (any "#$\n"))) space (any "#$λ") space))
    :init
    (defun config-eshell-skip-prompt ()
      (goto-char (line-beginning-position))
      (skip-chars-forward "#$λ "))

    (defun config-eshell-prompt ()
      (concat (propertize (abbreviate-file-name (eshell/pwd))
                          'face 'font-lock-comment-face)
              "\n"
              (if (= (user-uid) 0) " # " " λ "))))
#+end_src

** Custom commands

*** fasd
#+begin_src emacs-lisp
  (defun eshell/j (&rest query)
    (let* ((command `("fasd" "-ld" ,@(mapcar #'shell-quote-argument query)))
           (output (shell-command-to-string (string-join command " ")))
           (matches (nreverse (split-string output "\n" t))))
      (if-let* ((dir (car matches)))
          (eshell/cd dir)
        (let ((message-log-match))
          (message "No fasd match")))))
#+end_src

*** git root
#+begin_src emacs-lisp
  (defun eshell/g ()
    (let (message-log-max)
      (if-let* ((dir (locate-dominating-file default-directory ".git")))
          (progn
            (message "Moving to git repository root")
            (eshell/cd dir))
        (if-let* ((dir (projectile-project-root)))
            (progn
              (message "Moving to project root")
              (eshell/cd dir))
          (user-error "Not in a project or git repo")))))
#+end_src

* ⌨️ Set up leader keys
Note that we ensure evil is loaded first before binding any keys below,
otherwise =general= is pathologically slow.

See:
- [[https://github.com/noctuid/general.el/issues/180][general.el/issues/180]]
- [[https://github.com/hlissner/doom-emacs/blob/3d21f4ef5ea79de77e32c85b6bdae18bee4d7d73/core/core-keybinds.el#L151][doom-emacs/core/core-keybinds.el]]

** Use ~SPC~ as the global leader key
#+begin_src emacs-lisp
  (use-package general
    :after evil
    :demand t
    :config
    (general-define-key :states '(normal motion) "SPC" nil))

  (defmacro leader-set-key (&rest args)
    (declare (indent defun))
    `(use-package general
       :after evil
       :demand t
       :config
       (,'general-def ,@args ,@'(:keymaps 'override :states
                                 '(normal motion visual)
                                 :prefix "SPC"))))
#+end_src

*** Top-level leader keybindings
#+begin_src emacs-lisp
  (defun alternate-buffer (&optional window)
    "Toggle back and forth between two buffers.

  WINDOW sets the window in which to toggle, and defaults to the
  current window."
    (interactive)
    (let ((current-buffer (window-buffer window))
          (buffer-predicate (frame-parameter (window-frame window) 'buffer-predicate)))
      ;; switch to first buffer previously shown in this window that matches
      ;; frame-parameter `buffer-predicate'
      (switch-to-buffer
       (or (car (seq-filter (lambda (buffer)
                              (and (not (eq buffer current-buffer))
                                   (or (null buffer-predicate) (funcall buffer-predicate buffer))))
                            (seq-map #'car (window-prev-buffers window))))
           ;; `other-buffer' honors `buffer-predicate' so no need to filter
           (other-buffer current-buffer t)))))
#+end_src

#+begin_src emacs-lisp
  (autoload 'selectrum-repeat "selectrum")

  (leader-set-key
    "$" '(popper-toggle-latest :wk "toggle popups")
    "+" '(popper-toggle-type :wk "toggle popup or normal")
    "-" '(popper-kill-latest-popup :wk "kill latest popup")
    "!" '(async-shell-command :wk "shell cmd (async)")
    "'" (general-predicate-dispatch 'poporg-dwim
          (bound-and-true-p poporg-mode) 'poporg-edit-exit
          (bound-and-true-p edit-indirect--overlay) 'edit-indirect-commit
          (equal (buffer-name) "*Edit Formulas*") 'org-table-fedit-finish
          (derived-mode-p 'org-mode) 'org-edit-special
          (and (derived-mode-p 'markdown-mode) (markdown-code-block-at-point-p)) 'markdown-edit-code-block
          (bound-and-true-p org-src-mode) 'org-edit-src-exit)
    "/" (list (general-predicate-dispatch 'consult-ripgrep
                (and (bound-and-true-p org-roam-directory)
                     (or (f-same-p default-directory org-roam-directory)
                         (f-child-of-p default-directory org-roam-directory)))
                'org-roam-search)
              :wk "search...")
    ":" '(eval-expression-interactively :wk "eval")
    ";" '(ielm :wk "Lisp REPL")
    "<tab>" (list (general-predicate-dispatch 'alternate-buffer
                    (and (bound-and-true-p popper-popup-status) (memq popper-popup-status '(popup user-popup))) 'popper-cycle)
                  :wk "other buf")
    "?" '(general-describe-keybindings :wk "show bindings")
    "@" '(consult-bookmark :wk "bookmark")
    "|" '(rotate-layout :wk "rotate window layout")
    "SPC" '(consult-buffer :wk "switch buf")
    "C" #'compile
    "D" '(dired-other-window :wk "dired (other)")
    "S" '(deadgrep :wk "rg (deadgrep)")
    "d" #'dired
    "i" (list (general-predicate-dispatch 'consult-imenu
                (bound-and-true-p lsp-ui-mode) 'lsp-ui-imenu
                (derived-mode-p 'lsp-ui-imenu-mode) 'lsp-ui-imenu--kill)
              :wk "imenu")
    "q" '(delete-window :wk "delete window")
    "r" 'selectrum-repeat
    "s" '(evil-iedit-state/iedit-mode :wk "iedit")
    "u" '(universal-argument :wk "prefix arg")
    "x" '(execute-extended-command :wk "M-x"))
#+end_src

*** ~,~ - Parens
#+begin_src emacs-lisp
  (leader-set-key :infix ","
    "" '(nil :wk "parens")
    "h" '(sp-beginning-of-sexp :wk "go to start")
    "l" '(sp-end-of-sexp :wk "go to end")
    "n" '(sp-next-sexp :wk "next")
    "p" '(sp-previous-sexp :wk "prev")
    "<" '(sp-backward-up-sexp :wk "backward up")
    ">" '(sp-up-sexp :wk "up")
    "c" '(sp-convolute-sexp :wk "convolute")
    "d" '(sp-kill-sexp :wk "kill")
    "D" '(sp-backward-kill-sexp :wk "kill backward")
    "k" '(sp-splice-sexp-killing-forward :wk "splice (forward)")
    "K" '(sp-splice-sexp-killing-backward :wk "splice (back)")
    "s" '(sp-splice-sexp-killing-around :wk "splice (around)")
    "r" '(sp-raise-sexp :wk "raise")
    "a" '(sp-add-to-next-sexp :wk "add to next")
    "A" '(sp-add-to-previous-sexp :wk "add to prev")
    "b" '(sp-forward-barf-sexp :wk "barf (forward)")
    "B" '(sp-backward-barf-sexp :wk "barf (back)")
    "m" '(sp-forward-slurp-sexp :wk "slurp (forward)")
    "M" '(sp-backward-slurp-sexp :wk "slurp (back)")
    "e" '(sp-emit-sexp :wk "emit")
    "j" '(sp-join-sexp :wk "joi")
    "t" '(sp-transpose-sexp :wk "transpose")
    "U" '(sp-backward-unwrap-sexp :wk "unwrap (back)")
    "u" '(sp-unwrap-sexp :wk "unwrap (forward)")
    "w" '(sp-rewrap-sexp :wk "rewrap")
    "x" '(sp-split-sexp :wk "split")
    "y" '(sp-copy-sexp :wk "copy (forward)")
    "Y" '(sp-backward-copy-sexp :wk "copy (back)"))
#+end_src

*** ~a~ - Applications
#+begin_src emacs-lisp
  (defun profiler-stop-and-report (&optional continue-p)
    "Stop the profiler and show results.

  With optional prefix arg CONTINUE-P, keep profiling."
    (interactive "P")
    (let ((ran-p (profiler-running-p)))

      (unless continue-p
        (profiler-stop))
      (profiler-report)
      (when ran-p
        (if continue-p
            (message "Profiler still recording")
          (message "Profiler stopped")))))

  (leader-set-key :infix "a"
    "" '(nil :wk "apps")
    "c" #'quick-calc
    "C" #'full-calc
    "e" #'eshell
    "m" #'mu4e
    "p" #'pass
    "r" (general-predicate-dispatch 'profiler-start
          (and (featurep 'profiler) (profiler-running-p)) 'profiler-stop-and-report)
    "w" #'world-time-list)
#+end_src

*** ~b~ - Buffers
#+begin_src emacs-lisp
  (leader-set-key :infix "b"
    "" '(nil :wk "bufs")
    "n" '(next-buffer :wk "next")
    "p" '(previous-buffer :wk "prev")
    "l" '(bufler :wk "list")
    "s" '(consult-buffer :wk "switch...")
    "S" '(consult-buffer-other-window :wk "switch... (other window)")
    "b" '(bury-buffer :wk "bury")
    "d" '(kill-current-buffer :wk "kill")
    "w" '(save-buffer :wk "save"))
#+end_src

*** ~c~ - Commenting
#+begin_src emacs-lisp
  (autoload 'sp-mark-sexp "smartparens")

  (defun comment-sexp ()
    "Comment the sexp at point."
    (interactive)
    (sp-mark-sexp)
    (call-interactively #'comment-region))
#+end_src

#+begin_src emacs-lisp
  (leader-set-key :infix "c"
    "" '(nil :wk "comments")
    "l" '(evilnc-comment-or-uncomment-lines :wk "line")
    "r" '(comment-or-uncomment-region :wk "region")
    "s" '(comment-sexp :wk "sexp"))
#+end_src

*** ~e~ - Errors and Flycheck
#+begin_src emacs-lisp
  (autoload 'flycheck-list-errors "flycheck")

  (defun flycheck-toggle-error-list ()
    "Show or hide the error list."
    (interactive)
    (if-let* ((window (seq-find (lambda (it)
                                  (equal flycheck-error-list-buffer
                                         (buffer-name (window-buffer it))))
                                (window-list))))
        (delete-window window)
      (flycheck-list-errors)))
#+end_src

#+begin_src emacs-lisp
  (leader-set-key :infix "e"
    "" '(nil :wk "errors")
    "n" '(flycheck-next-error :wk "next")
    "p" '(flycheck-previous-error :wk "prev")
    "l" '(flycheck-toggle-error-list :wk "list")
    "r" '(flycheck-buffer :wk "run checks")
    "c" '(flycheck-clear :wk "clear")
    "e" '(flycheck-explain-error-at-point :wk "explain at pt")
    "h" '(flycheck-describe-checker :wk "describe checker")
    "s" '(flycheck-select-checker :wk "select checker")
    "v" '(flycheck-verify-setup :wk "verify setup"))
#+end_src

*** ~f~ - Files
#+begin_src emacs-lisp
  (autoload 'projectile-project-p "projectile")
  (autoload 'projectile-invalidate-cache "projectile")

  (defun delete-current-buffer-and-file ()
    "Remove the file associated with the current buffer, then kill it."
    (interactive)
    (let ((file (buffer-file-name)))
      (cond
       ((null file)
        (kill-buffer))
       ((not (file-exists-p file))
        (kill-buffer))
       ((yes-or-no-p "Delete this file? ")
        (delete-file file t)
        (kill-buffer)

        (when (projectile-project-p)
          (call-interactively #'projectile-invalidate-cache))

        (message "File deleted: %s" file)))))

  (defun sudo-edit (&optional arg)
    "Reopen the current file as sudo for editing.

  With prefix argument ARG, prompt for a file."
    (interactive "p")
    (let* ((fname (if (or arg (not buffer-file-name))
                      (read-file-name "File: ")
                    buffer-file-name))
           (target (cond ((string-match-p "^/ssh:" fname)
                          (with-temp-buffer
                            (insert fname)
                            (search-backward ":")
                            (let ((last-match-end nil)
                                  (last-ssh-hostname nil))
                              (while (string-match "@\\\([^:|]+\\\)" fname last-match-end)
                                (setq last-ssh-hostname (or (match-string 1 fname)
                                                            last-ssh-hostname))
                                (setq last-match-end (match-end 0)))
                              (insert (format "|sudo:%s" (or last-ssh-hostname "localhost"))))
                            (buffer-string)))
                         (t (concat "/sudo:root@localhost:" fname)))))
      (find-file target)))

  (defun assert-file-exists-for-buffer (&optional buf)
    (let ((cur (buffer-file-name buf)))
      (if (not (and cur (file-exists-p cur)))
          (error "Buffer is not visiting a file!")
        cur)))

  (defun rename-file-and-buffer--vc-rename (src dest)
    (condition-case err
        (when (vc-backend src)
          (vc-rename-file src dest)
          t)
      (error
       (let ((msg (error-message-string err)))
         (cond
          ((string-match-p "New file already exists" msg) nil)
          ((string-match-p "Please update files" msg)
           (unless (y-or-n-p "VC cannot track this change automatically.  Continue? ")
             (error msg)))
          (t
           (error msg)))))))

  (autoload 'recentf-cleanup "recentf")
  (require 'subr-x)

  (defun rename-file-and-buffer--try (src dest)
    (when (and (file-exists-p dest) (not (y-or-n-p "File exists.  Overwrite? ")))
      (user-error "Aborted"))
    (rename-file src dest t)
    (when-let* ((buf (get-file-buffer src)))
      (with-current-buffer buf
        (rename-buffer dest)
        (set-visited-file-name dest)
        (set-buffer-modified-p nil))

      (recentf-cleanup)
      (when (projectile-project-p)
        (projectile-invalidate-cache nil))))

  (autoload 'f-join "f")

  ;;;###autoload
  (defun rename-file-and-buffer (buffer dest-dir dest-filename)
    "Rename the current buffer and file it is visiting.
  Performs basic VC cleanup.

  BUFFER is the buffer to rename.

  DEST-DIR is the directory to move the underlying file to.

  DEST-FILENAME is the new filename for the underlying file."
    (interactive (let ((cur (assert-file-exists-for-buffer)))
                   (list (current-buffer)
                         (read-directory-name "Move to directory: " (file-name-directory cur))
                         (read-string "New name: " (file-name-nondirectory cur)))))
    (let ((src (assert-file-exists-for-buffer buffer))
          (dest-path (f-join dest-dir dest-filename)))
      (or (rename-file-and-buffer--vc-rename src dest-path)
          (rename-file-and-buffer--try src dest-path))
      (when (and (fboundp 'projectile-project-p) (projectile-project-p))
        (call-interactively #'projectile-invalidate-cache))
      (message "File '%s' moved to '%s'"
               (abbreviate-file-name (file-name-nondirectory src))
               (abbreviate-file-name dest-path))))

  (defun reload-file ()
    "Revisit the current file."
    (interactive)
    (when-let* ((path (buffer-file-name)))
      (find-alternate-file path)))

  (defun copy-buffer-path ()
    "Show and copy the full path to the current file in the minibuffer."
    (interactive)
    ;; list-buffers-directory is the variable set in dired buffers
    (if-let* ((path (or (buffer-file-name) list-buffers-directory)))
        (message (kill-new path))
      (error "Buffer not visiting a file")))

  (defun copy-buffer-name ()
    "Show and copy the full path to the current file in the minibuffer."
    (interactive)
    (let ((name (if-let* ((path (buffer-file-name)))
                    (file-name-nondirectory path)
                  (buffer-name))))
      (message (kill-new name))))

  (defun copy-buffer-directory ()
    "Show and copy the directory of the current file in the minibuffer."
    (interactive)
    ;; list-buffers-directory is the variable set in dired buffers
    (if-let* ((path (or (ignore-errors (file-name-directory (buffer-file-name))) list-buffers-directory)))
        (message (kill-new path))
      (error "Buffer not visiting a file")))
#+end_src

#+begin_src emacs-lisp
  (leader-set-key :infix "f"
    "" '(nil :wk "files")
    "d" '(copy-buffer-directory :wk "copy dir")
    "y" '(copy-buffer-path :wk "copy path")
    "Y" '(copy-buffer-name :wk "copy name")
    "D" '(delete-current-buffer-and-file :wk "delete buf & file")
    "e" 'sudo-edit
    "f" '(find-file :wk "find...")
    "F" '(find-file-other-window :wk "find... (other window)")
    "s" '(save-buffer :wk "save")
    "S" '(save-some-buffers :wk "save... (interactive)")
    "l" '(find-file-literally :wk "find literally...")
    "l" '(hexl-find-file :wk "find as hex...")
    "w" '(write-file :wk "write copy...")
    "v" '(reload-file :wk "reload from disk")
    "r" '(consult-recent-file :wk "recent files...")
    "R" '(rename-file-and-buffer :wk "rename..."))
#+end_src

*** ~g~ - Git & Goto
#+begin_src emacs-lisp
  (require 's)
  (require 'xref)
  (autoload 'projectile-find-file "projectile")
  (autoload 'xref-push-marker-stack "xref")

  (defun jump-to-file (file &optional pos)
    (xref-push-marker-stack)
    (let ((buf (or (get-buffer file) (find-file-noselect file))))
      (switch-to-buffer buf)
      (when pos
        (goto-char pos))))

  (defun jump-to-config-file ()
    "Jump to the config.org file."
    (interactive)
    (jump-to-file (expand-file-name "config.org" user-emacs-directory)))

  (defun jump-to-tangled-config-file ()
    "Jump to the config.el file."
    (interactive)
    (jump-to-file (expand-file-name "config.el" user-emacs-directory)))

  (defun jump-to-packages-file ()
    "Jump to the packages.nix file."
    (interactive)
    (jump-to-file (expand-file-name "packages.nix" user-emacs-directory)))

  (defun jump-to-init-file ()
    "Open the Emacs init.el file."
    (interactive)
    (jump-to-file (expand-file-name "init.el" user-emacs-directory)))

  (defun jump-to-nix-config ()
    "Open a nix config file."
    (interactive)
    (let ((default-directory paths-nix-directory))
      (projectile-find-file)))

  (defun hostname ()
    (cadr (s-match (rx (group (+? nonl)) (? "-" (+ digit)) (? ".local") eos)
                   (downcase (system-name)))))

  (defun jump-to-nix-system-config ()
    "Open the nix system config file."
    (interactive)
    (jump-to-file (format (f-join paths-nix-directory (concat (hostname) ".nix")))))

  (defun jump-to-site-file ()
    "Open the Emacs site config file."
    (interactive)
    (jump-to-file user-site-file))

  (defun jump-to-messages ()
    "Open the messages buffer."
    (interactive)
    (display-buffer "*Messages*"))
#+end_src

#+begin_src emacs-lisp
  (leader-set-key :infix "g"
    "" '(nil :wk "git/goto")
    "c" '(jump-to-config-file :wk "to config.org")
    "C" '(jump-to-tangled-config-file :wk "to tangled config")
    "i" '(jump-to-init-file :wk "to init file")
    "n" '(jump-to-nix-config :wk "to Nix config")
    "S" '(jump-to-nix-system-config :wk "to system Nix config")
    "p" '(jump-to-packages-file :wk "to packages.nix")
    "?" '(jump-to-messages :wk "to messages buf")
    "S" '(jump-to-site-file :wk "to site.el")
    "s" '(magit-status :wk "magit")
    "d" '(magit-diff-buffer-file :wk "git diff of file")
    "b" '(magit-blame :wk "git blame")
    "r" '(browse-at-remote :wk "git remote: browse")
    "y" '(browse-at-remote-kill :wk " git remote: copy")
    "l" '(magit-log-buffer-file :wk "git log")
    "w" '(magit-worktree-status :wk "git worktree...")
    "W" '(magit-worktree :wk "git worktree popup...")
    "g" '(xref-find-definitions :wk "find defs")
    "G" '(xref-find-definitions-other-window :wk "find def (other window)")
    "m" '(xref-find-references :wk "find references")
    "SPC" 'pop-tag-mark)
#+end_src

*** ~h~ - Help
#+begin_src emacs-lisp
  (leader-set-key :infix "h"
    "" '(nil :wk "help")
    "i" #'info
    "m" #'man
    "d" '(nil :wk "describe")
    "d c" '(describe-face :wk "face...")
    "d C" '(helpful-command :wk "command...")
    "d f" '(helpful-callable :wk "function...")
    "d k" '(helpful-key :wk "key...")
    "d m" '(describe-mode :wk "mode")
    "d p" '(describe-text-properties :wk "properties at pt")
    "d v" '(helpful-variable :wk "variable...")
    "f" '(nil :wk "find")
    "f c" '(find-face-definition :wk "face...")
    "f f" '(find-function :wk "function...")
    "f l" '(find-library :wk "lisp library...")
    "f v" '(find-variable :wk "variable..."))
#+end_src

*** ~k~ - Killing
#+begin_src emacs-lisp
  (leader-set-key :infix "k"
    "" '(nil :wk "kill")
    "b" 'kill-this-buffer
    "w" 'delete-window
    "r" 'consult-yank-pop)
#+end_src

*** ~l~ - LSP
#+begin_src emacs-lisp
  (leader-set-key :infix "l"
    "" '(:keymap lsp-command-map :package lsp-mode :wk "lsp"))
#+end_src

**** Use which-key replacements                                 :disabled:
Disabled for now since this breaks insert state in evil :/
#+begin_src emacs-lisp
  (use-package lsp-mode
    :custom
    (lsp-keymap-prefix "SPC l")
    :hook
    (lsp-mode . lsp-enable-which-key-integration))
#+end_src

*** ~n~ - Narrowing
#+begin_src emacs-lisp
  (leader-set-key :infix "n"
    "" '(nil :wk "narrow")
    "e" '(edit-indirect-region :wk "edit (indirect)")
    "f" '(narrow-to-defun :wk "defun")
    "r" '(narrow-to-region :wk "region")
    "w" 'widen
    "s" '(org-narrow-to-subtree :wk "subtree")
    "S" '(org-tree-to-indirect-buffer :wk "tree to indirect buffer"))
#+end_src

*** ~o~ - org-mode
#+begin_src emacs-lisp
  (defun jump-to-index-file ()
    (interactive)
    (org-roam-node-visit (org-roam-node-from-id org-roam-index-node-id)))

  (leader-set-key :infix "o"
    "" '(nil :wk "org")
    "SPC" '(org-roam-dailies-capture-today :wk "capture note...")
    "$" '(org-funcs-goto-accounts :wk "accounts")
    "/" '(org-ql-search :wk "search...")
    "a" '(org-funcs-agenda-dwim :wk "agenda")

    "c" '(nil :wk "clock")
    "c i" '(timekeep-start :wk "punch in")
    "c o" '(timekeep-stop :wk "punch out")
    "c r" '(org-resolve-clocks :wk "resolve clocks")
    "c g" '(org-clock-goto :wk "goto last clock")

    "i" '(jump-to-index-file :wk "index file")

    "k" '(org-capture :wk "capture...")
    "K" '(org-roam-capture :wk "capture... (roam)")
    "l" '(org-store-link :wk "store link")
    "s" '(org-roam-search-view :wk "search...")
    "f" '(org-funcs-roam-node-find :wk "roam file...")
    "n" '(org-roam-dailies-goto-today :wk "dailies: today")
    "T" '(org-roam-dailies-goto-tomorrow :wk "dailies: tomorrow")
    "y" '(org-roam-dailies-goto-yesterday :wk "dailies: yesterday")
    "d" '(org-roam-dailies-goto-date :wk "dailies: date...")

    "r" '(nil :wk "review...")
    "ra" '(org-roam-review-list-authors :wk "review authors")
    "rd" '(org-roam-review-list-recently-added :wk "recently added")
    "ro" '(org-roam-review-visit-outline :wk "outlines...")
    "rr" '(org-roam-review :wk "review due evergreens")
    "rt" '(org-roam-search-tags :wk "search (tags)...")
    "ru" '(org-roam-review-list-uncategorised :wk "uncategorised notes")
    "rl" '(org-roam-links-view :wk "show links")

    "p" '(org-funcs-goto-todos :wk "todos")
    "g" '(org-capture-goto-last-stored :wk "last captured")
    "t" '(org-funcs-todo-list :wk "todo list")
    "v" '(org-tags-view :wk "tags")
    "w" '(timekeep-find-client-buffer :wk "work"))
#+end_src

*** ~p~ - Projects
#+begin_src emacs-lisp
  (leader-set-key :infix "p"
    "" '(nil :wk "projects")
    "<tab>" '(projectile-toggle-between-implementation-and-test :wk "toggle impl/test")
    "<backtab>" '(projectile-find-implementation-or-test-other-window :wk "find impl/test")
    "!" '(projectile-run-async-shell-command-in-root :wk "shell command...")
    "c" '(projectile-compile-project :wk "compile...")
    "u" '(projectile-run-project :wk "run...")
    "t" '(projectile-test-project :wk "test...")
    "p" '(projectile-switch-project :wk "switch...")
    "f" '(projectile-find-file :wk "find file...")
    "d" '(projectile-find-dir :wk "find dir...")
    "b" '(projectile-switch-to-buffer :wk "switch buffer...")
    "D" '(projectile-dired :wk "dired")
    "/" '(consult-ripgrep :wk "search (rg)")
    "r" '(projectile-replace :wk "replace"))
#+end_src

*** ~r~ - registers
#+begin_src emacs-lisp
  (leader-set-key :infix "j"
    "" '(nil :wk "registers")
    "j" '(config-consult-register-no-strings :wk "select")
    "x" '(config-delete-register :wk "delete")
    "w" '(window-configuration-to-register :wk "store... (windows)")
    "p" '(point-to-register :wk "store... (point)"))
#+end_src

*** ~t~ - Toggles
#+begin_src emacs-lisp
  (leader-set-key :infix "t"
    "" '(nil :wk "toggle")
    "i" '(toggle-input-method :wk "input method")
    "c" '(hide/show-comments-toggle :wk "comments")
    "m" '(global-hide-mode-line-mode :wk "mode line"))
#+end_src

*** ~w~ - Windows
#+begin_src emacs-lisp
  (defun split-window-horizontally-dwim (&optional arg)
    "When splitting window, show the other buffer in the new window.

  With prefix arg ARG, don't select the new window."
    (interactive "P")
    (split-window-horizontally)
    (let ((target-window (next-window)))
      (set-window-buffer target-window (other-buffer))
      (unless arg
        (select-window target-window))))

  (defun split-window-vertically-dwim (&optional arg)
    "When splitting window, show the other buffer in the new window.

  With prefix arg ARG, don't select the new window."
    (interactive "P")
    (split-window-vertically)
    (let ((target-window (next-window)))
      (set-window-buffer target-window (other-buffer))
      (unless arg
        (select-window target-window))))

  (defun toggle-window-dedication ()
    "Toggle whether the current window is dedicated to its current buffer."
    (interactive)
    (let* ((window (selected-window))
           (was-dedicated (window-dedicated-p window)))
      (set-window-dedicated-p window (not was-dedicated))
      (message "Window %sdedicated to %s"
               (if was-dedicated "no longer " "")
               (buffer-name))))
#+end_src

#+begin_src emacs-lisp
  (leader-set-key :infix "w"
    "" '(nil :wk "window")
    "SPC" '(window-toggle-side-windows :wk "toggle side windows")
    "w" '(evil-window-next :wk "next")
    "r" '(evil-window-rotate-downwards :wk "rotate")
    "/" '(split-window-horizontally-dwim :wk "split (horizontal)")
    "-" '(split-window-vertically-dwim :wk "split (vertical)")
    "=" '(balance-windows :wk "balance")
    "d" '(delete-window :wk "delete")
    "o" '(delete-other-windows :wk "delete others")
    "t" '(toggle-window-dedication :wk "toggle dedication"))
#+end_src

*** ~y~ - Text snippets
#+begin_src emacs-lisp
  (leader-set-key :infix "y"
    "" '(nil :wk "snippets")
    "n" '(yas-new-snippet :wk "new")
    "e" '(yas-expand :wk "expand")
    "f" '(yas-visit-snippet-file :wk "open...")
    "y" '(yas-insert-snippet :wk "insert..."))
#+end_src

*** ~z~ - Text Scale
#+begin_src emacs-lisp
  (leader-set-key :infix "z"
    "" '(nil :wk "zoom")
    "+" '(default-text-scale-increase :wk "increase text scale")
    "-" '(default-text-scale-decrease :wk "decrease text scale")
    "=" '(default-text-scale-reset :wk "reset text scale"))
#+end_src

*** Unbind SPC in magit-section for compatability
#+begin_src emacs-lisp
  (use-package magit-section
    :general (:keymaps 'magit-section-mode-map "SPC" nil))
#+end_src

** Use ~,~ for mode-specific commands
#+begin_src emacs-lisp
  (use-package general
    :after evil
    :demand t
    :config
    (general-define-key :states '(normal motion) "," nil))

  (defmacro mode-leader-set-key (&rest args)
    (declare (indent defun))
    `(use-package general
       :after evil
       :demand t
       :config
       (,'general-def ,@args ,@'(:keymaps 'override :states
                                 '(normal motion visual)
                                 :prefix ","))))
#+end_src

* Search & replace

** =deadgrep= - Ripgrep (=rg=) frontend
#+begin_src emacs-lisp
  (use-package deadgrep
    :general (:keymaps 'deadgrep-mode-map "C-c C-w" #'deadgrep-edit-mode)
    :init
    (defalias 'rg #'deadgrep)
    :config
    (setq-default deadgrep--search-type 'regexp))
#+end_src

*** Use ~c~ in the =deadgrep= buffer to change the search term
#+begin_src emacs-lisp
  (use-package deadgrep
    :preface
    (defun config-deadgrep--requery ()
      (interactive)
      (let ((button (save-excursion
                      (goto-char (point-min))
                      (forward-button 1))))
        (button-activate button)))
    :general (:states 'normal :keymaps 'deadgrep-mode-map
              "c" #'config-deadgrep--requery))
#+end_src

*** Provide feedback in the echo area on entering and exiting =deadgrep-edit-mode=
#+begin_src emacs-lisp
  (use-package deadgrep
    :config
    (defun config-deadgrep--on-exit-edit-mode (&rest _)
      (when (derived-mode-p 'deadgrep-edit-mode)
        (let ((message-log-max))
          (message "Exiting edit mode."))))

    (defun config-deadgrep--on-enter-edit-mode (&rest _)
      (let ((message-log-max))
        (message "Entering edit mode. Changes will be made to underlying files as you edit.")))

    (advice-add 'deadgrep-mode :before #'config-deadgrep--on-exit-edit-mode)
    (advice-add 'deadgrep-edit-mode :after #'config-deadgrep--on-enter-edit-mode))
#+end_src

** =wgrep= - Directly edit =grep= results
Enable =wgrep=, which provides editable grep buffers.
#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src

* Prompts and UI enhancements

** =historian= - Persistent input history
#+begin_src emacs-lisp
  (use-package historian
    :hook (after-init . historian-mode))
#+end_src

*** Fix text encoding issues
#+begin_src emacs-lisp
  (use-package historian
    :init
    (defun config-historian-force-text-encoding (f &rest args)
      (let ((coding-system-for-write 'binary))
        (apply f args)))
    :config
    (advice-add 'historian-save :around #'config-historian-force-text-encoding))
#+end_src

** =orderless= - order-insensitive matching algorithm
https://github.com/oantolin/orderless
#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless)))
#+end_src

** =selectrum= - Incremental search and narrowing
#+begin_src emacs-lisp
  (use-package selectrum
    :hook (after-init . selectrum-mode)
    :general (:keymaps 'selectrum-minibuffer-map "C-<return>" 'selectrum-submit-exact-input))
#+end_src

*** Integrate =selectrum= with =orderless=
#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (orderless-skip-highlighting (lambda () (bound-and-true-p selectrum-is-active)))
    (selectrum-highlight-candidates-function #'orderless-highlight-matches))
#+end_src

*** KLUDGE: Use C-h in find-file to traverse up a dir
It would be nice if this was an out-of-the-box thing.
See: [[https://github.com/raxod502/selectrum/issues/498#issuecomment-876424791][Add dedicated command to move up a directory in find-file · Issue #498 · raxo...]]

#+begin_src emacs-lisp
  (defun selectrum-up (&optional arg)
    (interactive "p")
    (save-restriction
      (narrow-to-region (minibuffer-prompt-end) (point-max))
      (let ((start (point)))
        (forward-sexp (- (or arg 1)))
        (delete-region start (point)))))
#+end_src

#+begin_src emacs-lisp
  (use-package selectrum
    :general
    (:keymaps 'selectrum-minibuffer-map "C-h" 'selectrum-up))
#+end_src

**** TODO Teach find-file to understand =~= and =//=

**** TODO Teach find-file how to navigate up past the home dir

*** =consult= - Commands built on top of selectrum
#+begin_src emacs-lisp
  (use-package consult
    :custom
    (consult-project-function 'projectile-project-root)
    (xref-show-xrefs-function #'consult-xref)
    (xref-show-definitions-function #'consult-xref)
    :general (:states 'normal "/" 'consult-line))
#+end_src

** =marginalia= - adds helpful annotations to completion prompts
#+begin_src emacs-lisp
  (use-package marginalia
    :hook (after-init . marginalia-mode))
#+end_src

* Window management

** =winner= - Window state history
=winner-mode= saves the window and buffer layout history, allowing you to cycle
forward and back through layout states. This is useful for recovering a layout
after editing actions have changed what windows are shown.

#+begin_src emacs-lisp
  (use-package winner
    :general ("<C-left>" 'winner-undo
              "<C-right>"'winner-redo)
    :hook (after-init . winner-mode)
    :custom
    (winner-boring-buffers '("*Completions*"
                             "*Compile-Log*"
                             "*inferior-lisp*"
                             "*Fuzzy Completions*"
                             "*Apropos*"
                             "*Help*"
                             "*cvs*"
                             "*Buffer List*"
                             "*Bufler*"
                             "*esh command on file*")))
#+end_src

** =rotate= - Rotate buffers within window layout
=rotate= provides handy commands for manipulating the window layout.
#+begin_src emacs-lisp
  (use-package rotate
    :commands (rotate-layout))
#+end_src

** =popper= - Categorise buffers for window assignments
#+begin_src emacs-lisp
  (use-package popper
    :hook (after-init . popper-mode)
    :custom
    (popper-mode-line nil)
    (popper-group-function 'popper-group-by-projectile)
    (popper-display-control nil)
    (popper-reference-buffers (list (rx bol "*Messages*" eol)
                                    (rx bol "*ielm*" eol)
                                    (rx bol "*" (? "Async ") "Shell Command")
                                    'org-roam-mode
                                    'org-roam-review-mode
                                    'help-mode
                                    'occur-mode
                                    'compilation-mode)))
#+end_src

* Text completion engines

** =hippie-expand= - generic text completion
=hippie-expand= is a generic completion engine that works in most buffers without
any special language-level support.

*** Use =hippie-expand= as the default completion command for evil
#+begin_src emacs-lisp
  (use-package hippie-exp
    :general ("M-/" 'hippie-expand
              :states 'insert
              [remap evil-complete-previous] 'hippie-expand))
#+end_src

*** Set the default heuristic for completing symbols
#+begin_src emacs-lisp
  (use-package hippie-exp
    :custom
    (hippie-expand-try-functions-list
     '(try-expand-dabbrev
       try-expand-dabbrev-all-buffers
       try-expand-dabbrev-from-kill
       try-complete-file-name-partially
       try-complete-file-name
       try-expand-all-abbrevs
       try-expand-list
       try-expand-line
       try-complete-lisp-symbol-partially
       try-complete-lisp-symbol)))
#+end_src

** =company= - UI for selecting completions
=company= is a general-purpose completion frontend, showing a popup of completion
options.

#+begin_src emacs-lisp
  (use-package company
    :hook (after-init . global-company-mode)

    :general
    (:keymaps '(prog-mode-map text-mode-map)
     [remap completion-at-point] #'company-manual-begin
     [remap complete-symbol] #'company-manual-begin)
    (:states '(insert normal emacs) :keymaps 'company-active-map
     "S-<return>" #'company-complete
     "<return>" #'company-complete-selection)
    (:keymaps 'comint-mode-map [remap indent-for-tab-command] #'company-manual-begin)

    :preface
    (general-unbind :keymaps 'company-active-map "C-w" "C-h")

    :custom
    (company-idle-delay 0.3)
    (company-minimum-prefix-length 3)
    (company-tooltip-align-annotations t)
    (company-require-match nil)

    :config
    (require 'company-tng))
#+end_src

=evil-collection-company= seems to be messing with the =<return>= binding, so I need
to manually apply it again.

#+begin_src emacs-lisp
  (use-package company
    :after evil-collection
    :custom
    (company-tooltip-minimum-width 40)
    :config
    (defun config-company--set-company-vars ()
      (define-key company-active-map (kbd "RET") #'company-complete-selection))

    (add-hook 'company-mode-hook #'config-company--set-company-vars))
#+end_src

*** =company-posframe= - use a child frame for completions
#+begin_src emacs-lisp
  (use-package company-posframe
    :after company
    :demand t
    :config
    (company-posframe-mode +1))
#+end_src

* Themeing

** =volatile-highlights= - Highlight pasted text

*** Load at compile-time so macro expansions are available
#+begin_src emacs-lisp
  (cl-eval-when (compile)
    (require 'volatile-highlights))
#+end_src

*** Configure the package
#+begin_src emacs-lisp
  (use-package volatile-highlights
    :hook
    (prog-mode . (lambda () (require 'volatile-highlights)))
    (text-mode . (lambda () (require 'volatile-highlights)))
    :config
    (volatile-highlights-mode))
#+end_src

*** Highlight text pasted by =evil= operations
#+begin_src emacs-lisp
  (use-package volatile-highlights
    :after (evil)
    :demand t
    :config
    (vhl/define-extension 'evil
                          'evil-move
                          'evil-paste-after
                          'evil-paste-before
                          'evil-paste-pop)
    (vhl/install-extension 'evil)
    (vhl/load-extension 'evil))
#+end_src

** =highlight-thing= - Highlight the symbol at point
#+begin_src emacs-lisp
  (use-package highlight-thing
    :hook (prog-mode . highlight-thing-mode)
    :custom
    (highlight-thing-what-thing 'symbol)
    (highlight-thing-delay-seconds 0.1)
    (highlight-thing-limit-to-defun nil)
    (highlight-thing-case-sensitive-p t)
    :config
    (set-face-attribute 'highlight-thing nil :inherit 'highlight))
#+end_src

*** Suppress =highlight-thing= when hovering over certain kinds of symbols
#+begin_src emacs-lisp
  (use-package highlight-thing
    :config
    (defun config-highlight-thing--should-highlight-p (res)
      (unless (bound-and-true-p lsp-ui-mode)
        (when res
          (let ((excluded-faces '(font-lock-string-face
                                  font-lock-keyword-face
                                  font-lock-comment-face
                                  font-lock-preprocessor-face
                                  font-lock-builtin-face))
                (faces (seq-mapcat #'face-ancestors (face-at-point nil t))))
            (null (seq-intersection faces excluded-faces))))))

    (advice-add 'highlight-thing-should-highlight-p :filter-return
                #'config-highlight-thing--should-highlight-p))
#+end_src

** =page-break-lines= - Show page breaks characters as a horizontal rule
#+begin_src emacs-lisp
  (use-package page-break-lines
    :hook (after-init . global-page-break-lines-mode)
    :custom
    (page-break-lines-modes '(prog-mode org-agenda-mode latex-mode help-mode)))
#+end_src

** =paren-face= - Apply a specific face to parens
 #+begin_src emacs-lisp
   (use-package paren-face
     :hook (after-init . global-paren-face-mode)
     :custom
     (paren-face-regexp (rx (any "{}();,")))
     :config
     (set-face-attribute 'parenthesis nil
                         :inherit 'font-lock-comment-face
                         :weight 'light
                         :italic nil
                         :background nil)

     (add-to-list 'paren-face-modes 'js-mode)
     (add-to-list 'paren-face-modes 'lisp-data-mode)
     (add-to-list 'paren-face-modes 'typescript-mode)
     (add-to-list 'paren-face-modes 'yaml-mode)
     (font-lock-add-keywords 'js-mode `((,(rx (any ":")) 0 'parenthesis)))
     (font-lock-add-keywords 'typescript-mode `((,(rx (any ":")) 0 'parenthesis))))
 #+end_src

*** Use a specific subset of parens in Clojure
#+begin_src emacs-lisp
  (defun config-set-clojure-paren-face ()
    (setq-local paren-face-regexp (rx (any "(),"))))

  (add-hook 'clojure-mode-hook #'config-set-clojure-paren-face)
  (font-lock-add-keywords 'clojure-mode `((,(rx (group "#") (or "{" "(")) 1 'font-lock-variable-name-face)))
#+end_src

** =hl-todo= - Highlight TODOs in comments
#+begin_src emacs-lisp
  (use-package hl-todo
    :hook ((prog-mode . hl-todo-mode)
           (text-mode . enable-hl-todo-unless-org-buffer))
    :preface
    (defun enable-hl-todo-unless-org-buffer ()
      (unless (derived-mode-p 'org-mode)
        (hl-todo-mode)))
    :custom
    (hl-todo-keyword-faces
     (seq-map (lambda (it) (cons it 'hl-todo))
              '("TODO"
                "NEXT"
                "HACK"
                "FIXME"
                "KLUDGE"
                "PATCH"
                "NOTE"))))
#+end_src

** =which-key= - Show keys after a delay on input
#+begin_src emacs-lisp
  (use-package which-key
    :hook (after-init . which-key-mode)
    :custom
    (which-key-sort-uppercase-first nil)
    (which-key-idle-delay 0.4))
#+end_src

** =default-text-scale= - Commands for changing text scale for all buffers simultaneously
#+begin_src emacs-lisp
  (use-package default-text-scale
    :custom
    (default-text-scale-amount 30))
#+end_src

** =fira-code-mode= - Adds ligatures to fira-code
#+begin_src emacs-lisp
  (use-package fira-code-mode
    :hook (prog-mode text-mode))
#+end_src

* File & Buffer management

** =bufler= - Better buffer list
#+begin_src emacs-lisp
  (use-package bufler
    :commands (bufler bufler-list)
    :config
    (evil-set-initial-state 'bufler-list-mode 'motion)
    (dolist (mode '(org-agenda-mode flycheck-error-message-mode magit-status-mode))
      (add-to-list 'bufler-filter-buffer-modes mode))
    :general
    ("C-x C-b" 'bufler-list)
    (:states '(motion) :keymaps 'bufler-list-mode-map
     "1" 'magit-section-show-level-1
     "2" 'magit-section-show-level-2
     "3" 'magit-section-show-level-3
     "4" 'magit-section-show-level-4
     "<" 'beginning-of-buffer
     "<backtab>" 'magit-section-cycle-global
     "q" 'quit-window
     ">" 'end-of-buffer
     "?" 'hydra:bufler/body
     "C-<tab>" 'magit-section-cycle
     "DEL" 'scroll-down-command
     "F" 'bufler-list-group-make-frame
     "M-1" 'magit-section-show-level-1-all
     "M-2" 'magit-section-show-level-2-all
     "M-3" 'magit-section-show-level-3-all
     "M-4" 'magit-section-show-level-4-all
     "M-<tab>" 'magit-section-cycle
     "M-n" 'magit-section-forward-sibling
     "M-p" 'magit-section-backward-sibling
     "N" 'bufler-list-buffer-name-workspace
     "RET" 'bufler-list-buffer-switch
     "TAB" 'magit-section-toggle
     "^" 'magit-section-up
     "f" 'bufler-list-group-frame
     "g r" 'bufler
     "d" 'bufler-list-buffer-kill
     "n" 'magit-section-forward
     "p" 'magit-section-backward
     "q" 'quit-window
     "s" 'bufler-list-buffer-save))
#+end_src

** =dired= - Filesystem browsing
=dired= is the builtin filesystem browser for Emacs.
#+begin_src emacs-lisp
  (use-package dired
    :hook (dired-mode . dired-hide-details-mode)
    :general
    (:states 'normal :keymaps 'dired-mode-map
     "$" #'end-of-line
     "i" nil
     "i i" 'dired-insert-subdir
     "i q" 'dired-kill-subdir
     "TAB" 'dired-hide-subdir)
    :custom
    (dired-listing-switches "-alhv")
    (dired-dwim-target t)
    (dired-auto-revert-buffer t)
    (dired-hide-details-hide-symlink-targets nil)
    (dired-omit-files (rx bol "."))
    :config
    (add-hook 'dired-mode-hook #'hl-line-mode)
    (put 'dired-find-alternate-file 'disabled nil))
#+end_src

*** Set leader keys
#+begin_src emacs-lisp
  (mode-leader-set-key :keymaps 'dired-mode-map
    "?" '(dired-hide-details-mode :wk "toggle details")
    "." '(dired-omit-mode :wk "toggle hidden")
    "e" '(wdired-change-to-wdired-mode :wk "wdired")
    "s" '(dired-sort-toggle-or-edit :wk "toggle sort")

    "f" 'dired
    "F" '(dired-other-window :wk "dired (other window)")

    "m" '(nil :wk "mark")
    "m a" '(dired-mark-unmarked-files :wk "unmarked")
    "m c" '(dired-change-marks :wk "change")
    "m r" '(dired-mark-files-regexp :wk "by regexp")
    "m l" '(dired-mark-symlinks :wk "symlinks")
    "m d" '(dired-mark-directories :wk "directories")
    "U" '(dired-unmark-all-marks :wk "unmark all")

    "!" '(dired-do-shell-command :wk "shell command...")

    "d" '(nil :wk "execute (marked)")
    "d c" '(dired-do-copy :wk "copy")
    "d D" '(dired-do-delete :wk "delete")
    "d h" '(dired-do-hardlink :wk "hardlink")
    "d s" '(dired-do-relsymlink :wk "symlink (relative)")
    "d S" '(dired-do-symlink :wk "symlink (absolute)")
    "d /" '(dired-do-search :wk "search"))
#+end_src

*** Put directories first in sort order
#+begin_src emacs-lisp
  (use-package dired
    :config
    (defun config-dired--sort-directories-first (&rest _)
      "Sort dired listings with directories first."
      (save-excursion
        (let (buffer-read-only)
          (forward-line 2) ;; beyond dir. header
          (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
        (set-buffer-modified-p nil)))

    (advice-add 'dired-readin :after #'config-dired--sort-directories-first))
#+end_src

*** Rename files by editing =dired= buffer
=wdired= is a mode that allows you to rename files and directories by editing the
=dired= buffer itself.

#+begin_src emacs-lisp
  (use-package wdired
    :general
    (:states 'normal
     :keymaps 'wdired-mode-map "^" #'evil-first-non-blank
     :keymaps 'dired-mode-map "C-c C-e" #'wdired-change-to-wdired-mode))
#+end_src

*** Toggle visibility of hidden files
Use =dired-x= to toggle visibility of 'hidden' files (i.e. files starting with a
dot).

#+begin_src emacs-lisp
  (use-package dired-x
    :demand t
    :after dired
    :hook (dired-mode . dired-omit-mode)
    :general
    (:states 'normal :keymaps 'dired-mode-map "h" #'dired-omit-mode)
    :custom
    (dired-omit-files (rx bol (or "." "__pycache__")))
    (dired-omit-verbose nil)
    (dired-clean-up-buffers-too t))
#+end_src

** =projectile= - Project and repo-level commands
=projectile= provides commands for working with projects, and a useful utility
function to find the root directory of the project.

Emacs now comes with =project.el=, but it provides a subset of the functionality
of =projectile=. Use =projectile= until the builtin functionality is more complete.

#+begin_src emacs-lisp
  (use-package projectile
    :hook (after-init . projectile-mode)
    :custom
    (projectile-project-search-path paths-project-directories)
    (projectile-switch-project-action (lambda () (dired default-directory)))
    (projectile-enable-caching t)
    (projectile-create-missing-test-files t)
    (projectile-globally-ignored-files '("TAGS" ".DS_Store"))
    (projectile-globally-ignored-file-suffixes
     '("meta"
       "gz"
       "zip"
       "tar"
       "tgz"
       "elc"
       "eln"))
    (projectile-globally-ignored-directories
     '("coverage"
       ".bzr"
       ".eunit"
       ".fslckout"
       ".g8"
       ".git"
       ".hg"
       ".svn"
       "dist"
       "jars"
       "node_modules"
       "vendor"
       "target")))
#+end_src

*** Exclude Nix store from known projects
#+begin_src emacs-lisp
  (use-package projectile
    :preface
    (defun config-projectile-ignored-project-function (path)
      (string-prefix-p "/nix/store/" path))
    :custom
    (projectile-ignored-project-function #'config-projectile-ignored-project-function))
#+end_src

* Git

** =magit= - interactive commands for working with git
#+begin_src emacs-lisp
  (use-package magit
    :general
    (:keymaps 'transient-base-map
     "<escape>" #'transient-quit-one)
    (:states 'normal :keymaps 'magit-refs-mode-map
     "." #'magit-branch-and-checkout)
    (:states '(motion normalm) :keymaps '(magit-section-mode-map magit-status-mode-map)
     [remap evil-next-line] 'next-line
     [remap evil-previous-line] 'previous-line
     [remap evil-next-visual-line] 'next-line
     [remap evil-previous-visual-line] 'previous-line)
    :custom
    (magit-repository-directories (--map (cons it 1) paths-project-directories))
    (magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
    (magit-log-section-commit-count 0))
#+end_src

*** Reveal the entire org buffer when blaming or visiting from a diff
#+begin_src emacs-lisp
  (use-package magit
    :after (org)
    :config
    (defun config-git--reveal-org-buffer ()
      (when (derived-mode-p 'org-mode)
        (org-reveal t)))

    (add-hook 'magit-diff-visit-file-hook 'config-git--reveal-org-buffer)
    (add-hook 'magit-blame-mode-hook #'config-git--reveal-org-buffer))
#+end_src

*** GPG verification
Hack =magit='s commit info to show output of a GPG signature check.
#+begin_src emacs-lisp
  (use-package magit-gpg
    :after (magit)
    :demand t
    :commands (magit-gpg-insert-revision-gpg)
    :preface
    (autoload 'magit-add-section-hook "magit")
    (autoload 'magit-insert-revision-headers "magit")
    :config
    (magit-add-section-hook 'magit-revision-sections-hook
                            #'magit-gpg-insert-revision-gpg
                            #'magit-insert-revision-headers
                            t))
#+end_src

*** Improve magit performance on macOS
See: https://github.com/magit/magit/commit/26e064e1d78acb4d4d422a0a5743609612863caa
#+begin_src emacs-lisp
  (when (equal system-type 'darwin)
    (setq magit-git-executable (expand-file-name "~/.nix-profile/bin/git")))
#+end_src

*** Compatibility with selectrum
#+begin_src emacs-lisp
  (use-package magit
    :after (selectrum)
    (setq magit-completing-read-function #'selectrum-completing-read))
#+end_src

*** =magit-delta= -- use the =delta= program to add syntax-highlighting to hunks
#+begin_src emacs-lisp
  (use-package magit-delta
    :hook (magit-mode . magit-delta-mode))
#+end_src

**** Conditionally disable to avoid slowdowns on large diffs
See: [[https://github.com/dandavison/magit-delta/issues/9#issuecomment-795435781][Slowness relative to regular magit · Issue #9 · dandavison/magit-delta · GitHub]]

#+begin_src emacs-lisp
  (use-package magit-delta
    :preface
    (defconst config-magit-delta-max-buffer-length 50000)

    (defun config-magit-delta-inhibit-for-large-diffs (fn &rest args)
      (if (<= (point-max) config-magit-delta-max-buffer-length)
          (apply fn args)
        (magit-delta-mode -1)))

    (defun config-magit-delta-maybe-reenable-for-refresh (&rest _args)
      (when (and (not magit-delta-mode)
                 (<= (point-max) config-magit-delta-max-buffer-length))
        (magit-delta-mode +1)))

    :config
    (advice-add 'magit-delta-call-delta-and-convert-ansi-escape-sequences :around #'config-magit-delta-inhibit-for-large-diffs)
    (add-hook 'magit-post-refresh-hook #'config-magit-delta-maybe-reenable-for-refresh))
#+end_src

** =forge= - teaches =magit= how to work with pull requests and issues
:LOGBOOK:
- Note taken on [2021-08-07 Sat 15:27] \\
  Temporarily disabled while yaml dependency has build issues on macOS
:END:
#+begin_src emacs-lisp
  (use-package forge
    :after magit
    :demand t
    :config
    (remove-hook 'magit-status-sections-hook 'forge-insert-issues)
    (add-hook 'magit-status-sections-hook 'forge-insert-requested-reviews 90)
    (add-hook 'magit-status-sections-hook 'forge-insert-assigned-issues 90))
#+end_src

** =git-auto-commit-mode= - Commit files on save
#+begin_src emacs-lisp
  (use-package git-auto-commit-mode
    :delight " auto-commit"
    :hook (pass-mode . git-auto-commit-mode)
    :custom
    (gac-debounce-interval 10)
    (gac-silent-message-p t)
    (gac-automatically-push-p t)
    (gac-automatically-add-new-files-p t))
#+end_src

** =vc-annotate= - Step through file history
#+begin_src emacs-lisp
  (use-package vc-annotate
    :general
    (:states 'normal :keymaps 'vc-annotate-mode-map
     "<return>" 'vc-annotate-find-revision-at-line
     "<tab>" 'vc-annotate-goto-line
     "n" 'vc-annotate-next-revision
     "f" 'vc-annotate-next-revision
     "l" 'vc-annotate-show-log-revision-at-line
     "p" 'vc-annotate-prev-revision
     "b" 'vc-annotate-prev-revision
     "d" 'vc-annotate-show-diff-revision-at-line
     "D" 'vc-annotate-show-changeset-diff-revision-at-line
     "." 'vc-annotate-working-revision))
#+end_src

** =git-commit-mode= - Commit messages authoring mode
#+begin_src emacs-lisp
  (use-package git-commit-mode
    :init
    (defun configure-git-commit-mode ()
      (setq-local fill-column 72))

    (add-hook 'git-commit-mode-hook 'configure-git-commit-mode))
#+end_src

*** =git-commit-ticket-prefix= - Add ticket number to commit messaging
#+begin_src emacs-lisp
  (use-package git-commit-ticket-prefix
    :general (:keymaps 'git-commit-mode-map "C-c C-a"
              'git-commit-ticket-prefix-insert-ticket-number))
#+end_src

** =browse-at-remote= - Browse file at remote
=browse-at-remote= provides commands for opening the current buffer in the source
repo, or copying the remote URL to the clipboard.

#+begin_src emacs-lisp
  (use-package browse-at-remote
    :general
    ("C-x v o" 'browse-at-remote
     "C-x v y" 'browse-at-remote-kill)
    :custom
    (browse-at-remote-add-line-number-if-no-region-selected nil))
#+end_src

*** Provide better feedback by writing to =*Messages*=
#+begin_src emacs-lisp
  (use-package browse-at-remote
    :config
    (defun config-browse-at-remote--message-kill (&rest _)
      (let ((message-log-max))
        (message "Copied to kill ring: %s" (substring-no-properties (car kill-ring)))))

    (advice-add 'browse-at-remote-kill :after 'config-browse-at-remote--message-kill))
#+end_src

*** Default to =master= if there's no push remote set
#+begin_src emacs-lisp
  (defun config-browse-at-remote--master-as-default (fn local-branch &rest args)
    (condition-case _
        (apply fn local-branch args)
      (error
       (cons (car (browse-at-remote--get-remotes))
             (seq-find (lambda (it) (seq-contains-p '("master" "main") it))
                       (vc-git-branches))))))

  (advice-add 'browse-at-remote--get-remote-branch :around #'config-browse-at-remote--master-as-default)
#+end_src

** =git-gutter= & =git-gutter-fringe= - Show git status in fringe
Source: [[https://ianyepan.github.io/posts/emacs-git-gutter/][Git Gutter in Emacs | Ian Y.E. Pan]]

#+begin_src emacs-lisp
  (use-package git-gutter
    :hook
    (text-mode . git-gutter-mode)
    (prog-mode . git-gutter-mode)
    :custom
    (git-gutter:update-interval 0.02)
    :config
    (require 'git-gutter-fringe))
#+end_src

*** Use the fringe for drawing hunk indicators

#+begin_src emacs-lisp
  (use-package git-gutter-fringe
    :config
    (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+end_src

*** Prevent git-gutter clobbering transclusion indicators in the fringe

#+begin_src emacs-lisp
  (use-package git-gutter-fringe
    :preface
    (defun config-custom-git-gutter-fringe-fn (diffinfos)
      "Insert fringe bitmaps for the diffs in DIFFINFOS."
      (when git-gutter-fr:bitmap-references
        (git-gutter:clear-gutter))
      (save-excursion
        (goto-char (point-min))
        (cl-loop with curline = 1
                 for info in diffinfos
                 for start-line = (git-gutter-hunk-start-line info)
                 for end-line = (git-gutter-hunk-end-line info)
                 for type = (git-gutter-hunk-type info)
                 do
                 (let (beg end)
                   (forward-line (- start-line curline))
                   (setq beg (point))
                   (if (eq type 'deleted)
                       (progn
                         (setq end beg))
                     (forward-line (- end-line start-line))
                     (setq end (point)))
                   (unless
                       (save-excursion
                         (goto-char beg)
                         (org-transclusion-within-transclusion-p))
                     (let* ((sign (git-gutter-fr:select-sign type))
                            (face (git-gutter-fr:select-face type))
                            (reference (fringe-helper-insert-region
                                        beg end sign git-gutter-fr:side face)))
                       (overlay-put reference 'git-gutter t)
                       (dolist (ov (overlays-in beg (1+ end)))
                         (when (eq (overlay-get ov 'fringe-helper-parent) reference)
                           (overlay-put ov 'git-gutter t)))
                       (push reference git-gutter-fr:bitmap-references)))
                   (setq curline end-line)))))
    :config
    (advice-add 'git-gutter-fr:view-diff-infos :override #'config-custom-git-gutter-fringe-fn))
#+end_src

* Programming languages & text-modes

** =xref= - Finding to definitions and references
#+begin_src emacs-lisp
  (use-package xref
    :general
    (:keymaps '(prog-mode-map ielm-map) :states '(normal visual insert)
     "M-." 'xref-find-definitions))
#+end_src

** =flycheck= - Syntax Checking & Linting
=Flycheck= integrates with external tools to show indications of errors and
warnings in the buffer as you edit.

See: [[https://www.flycheck.org/en/latest/][flycheck.org]]

#+begin_src emacs-lisp
  (use-package flycheck
    :hook
    (after-init . global-flycheck-mode)
    (prog-mode . flycheck-mode-on-safe)

    :general
    (:keymaps
     'flycheck-mode-map
     "M-n" #'flycheck-next-error
     "M-p" #'flycheck-previous-error
     "M-j" #'flycheck-next-error
     "M-k" #'flycheck-previous-error)

    (:states 'motion
     :keymaps 'flycheck-error-list-mode-map
     "j" #'flycheck-error-list-next-error
     "k" #'flycheck-error-list-previous-error
     "RET" #'flycheck-error-list-goto-error
     "n" #'flycheck-error-list-next-error
     "p" #'flycheck-error-list-previous-error
     "q" #'quit-window)

    :custom
    (flycheck-display-errors-delay 0.1)
    (flycheck-emacs-lisp-load-path 'inherit)
    (flycheck-python-pycompile-executable "python")
    (flycheck-global-modes '(not org-mode text-mode org-agenda-mode cider-repl-mode)))
#+end_src

*** =flycheck-org-lint= - Linting for org-mode buffers           :disabled:
#+begin_src emacs-lisp
  (use-package flycheck-org-lint
    :after flycheck
    :demand t
    :config
    (add-to-list 'flycheck-checkers 'org-lint))
#+end_src

*** Customise the modeline indicator
#+begin_src emacs-lisp
  (use-package flycheck
    :config
    (defun flycheck-custom-mode-line-status-text (&optional status)
      (pcase (or status flycheck-last-status-change)
        (`no-checker " Checks[-]")
        (`errored " Checks[ERROR]")
        (`finished
         (let-alist (flycheck-count-errors flycheck-current-errors)
           (cond
            ((and .error .warning)
             (format " ✖ (%s error%s, %s warn%s)"
                     .error
                     (if (equal .error 1) "" "s")
                     .warning
                     (if (equal .warning 1) "" "s")))
            (.error
             (format " ✖ (%s error%s)" .error (if (equal .error 1) "" "s")))

            (.warning
             (format " ! (%s warning%s)" .warning (if (equal .warning 1) "" "s")))
            (t
             " ✔"))))
        (`interrupted " ? (interrupted)")
        (`suspicious " ? (suspicious)")
        (_
         "")))
    :custom
    (flycheck-mode-line '(:eval (flycheck-custom-mode-line-status-text))))
#+end_src

*** Projectile integration                                       :disabled:
Automatically re-check all buffers belonging to a project on save. This ensures
diagnostics do not go stale.

#+begin_src emacs-lisp
  (use-package flycheck
    :after (projectile)
    :config
    (defun config-flycheck--check-all-project-buffers ()
      (when (and (bound-and-true-p projectile-mode) (projectile-project-p))
        (projectile-process-current-project-buffers
         (lambda (buf)
           (with-current-buffer buf
             (when (bound-and-true-p flycheck-mode)
               ;; HACK: Inhibit checks for elisp, otherwise flycheck will
               ;; spawn a bunch of thrashing Emacs processes.
               (unless (derived-mode-p 'emacs-lisp-mode)
                 (flycheck-buffer))))))))

    (add-hook 'after-save-hook #'config-flycheck--check-all-project-buffers))
#+end_src

*** Conditionally inhibit =Flycheck=
Don't use =Flycheck= in certain situations, such as for files inside =node_modules=,
during =ediff= merges, etc.

#+begin_src emacs-lisp
  (use-package flycheck
    :config
    (defun config-flycheck--maybe-inhibit (result)
      (unless (or (equal (buffer-name) "*ediff-merge*")
                  (string-suffix-p ".dir-locals.el" (buffer-file-name))
                  (string-match-p (rx bol "*Pp ") (buffer-name))
                  (string-match-p (rx "/node_modules/") default-directory))
        result))

    (advice-add 'flycheck-may-enable-mode :filter-return #'config-flycheck--maybe-inhibit))
#+end_src

** =smartparens= - Structured expression editing
Use =smartparens= to keep parens and braces paired and manipulate expressions in a
structured way.

See: [[https://github.com/Fuco1/smartparens][Fuco1/smartparens]]

*** Set general variables
#+begin_src emacs-lisp
  (use-package smartparens
    :hook
    (prog-mode . smartparens-strict-mode)
    (text-mode . smartparens-strict-mode)

    :general
    (:keymaps 'smartparens-strict-mode-map
     [remap c-electric-backspace] #'sp-backward-delete-char)
    (:states 'insert
     ")" #'sp-up-sexp)
    (:states 'normal
     "D" #'sp-kill-hybrid-sexp)

    :custom
    (sp-show-pair-delay 0.2)
    (sp-show-pair-from-inside t)
    (sp-cancel-autoskip-on-backward-movement nil)
    (sp-highlight-pair-overlay nil)
    (sp-highlight-wrap-overlay nil)
    (sp-highlight-wrap-tag-overlay nil)
    (sp-navigate-close-if-unbalanced t)
    (sp-message-width nil)

    :config
    (require 'smartparens-config)
    (smartparens-global-strict-mode +1)
    (show-smartparens-global-mode +1))
#+end_src

*** Load macros and functions at compile time so I can use them in this config
#+begin_src emacs-lisp
  (cl-eval-when (compile)
    (require 'smartparens))

  (autoload 'sp-pair "smartparens")
  (autoload 'sp-local-pair "smartparens")
#+end_src

*** Define utility functions
#+begin_src emacs-lisp
  (autoload 'sp-get-pair "smartparens")
  (autoload 'sp--get-opening-regexp "smartparens")
  (autoload 'sp--get-closing-regexp "smartparens")

  (defun config-smartparens-add-space-before-sexp-insertion (id action _context)
    (when (eq action 'insert)
      (save-excursion
        (backward-char (length id))
        (cond
         ((and (eq (preceding-char) ?$)
               (equal id "{")))

         ((eq (char-syntax (preceding-char)) ?w)
          (just-one-space))

         ((and (looking-back (sp--get-closing-regexp) (line-beginning-position))
               (not (eq (char-syntax (preceding-char)) ?')))
          (just-one-space))))))

  (defun config-smartparens-add-space-after-sexp-insertion (id action _context)
    (when (eq action 'insert)
      (save-excursion
        (forward-char (sp-get-pair id :cl-l))
        (when (or (eq (char-syntax (following-char)) ?w)
                  (looking-at (sp--get-opening-regexp)))
          (insert " ")))))
#+end_src

*** Define the pairs to use by default in all modes
#+begin_src emacs-lisp
  (use-package smartparens
    :config
    (sp-pair "`" "`"
             :bind "M-`")
    (sp-pair "{" "}"
             :bind "M-{"
             :pre-handlers '(config-smartparens-add-space-before-sexp-insertion)
             :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "[" "]"
             :bind "M-["
             :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "(" ")"
             :bind "M-("
             :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
    (sp-pair "\"" "\""
             :bind "M-\""
             :pre-handlers '(:add (config-smartparens-add-space-before-sexp-insertion))))
#+end_src

*** Delete enclosing whitespace as necessary on backspace
#+begin_src emacs-lisp
  (use-package smartparens
    :functions (sp-get-enclosing-sexp)
    :config
    (defun config-smartparens-delete-horizontal-space-for-delete (f &rest args)
      "Perform context-sensitive whitespace cleanups when deleting.

  For performance, only consider a subset of the buffer."
      (save-restriction
        (unless (derived-mode-p 'emacs-lisp-mode)
          (apply #'narrow-to-region (bounds-of-surrounding-lines 500 500)))

        (-let* ((line-before-pt (buffer-substring (line-beginning-position) (point)))
                (line-after-pt (buffer-substring (point) (line-end-position)))

                ((&plist :beg beg :end end :op op :cl cl) (sp-get-enclosing-sexp))
                (inside-start (when op (+ beg (length op))))
                (inside-end   (when op (- end (length cl))))
                (inside       (when op
                                (concat (buffer-substring inside-start (point))
                                        (buffer-substring (point) inside-end)))))
          (cond
           ;; Collapse horizontal space in empty pairs.
           ;;
           ;; [  |  ] -> [|]
           ;;
           ((when op (string-match-p (rx bos (+ space) eos) inside))
            (delete-region inside-start inside-end))

           ;; Delete contents for multiline pairs that were just inserted, e.g. braces.
           ;;
           ;; {
           ;;   |
           ;; }
           ;;
           ;; ->
           ;;
           ;; {|}
           ((when op (string-match-p (rx bos (* space) "\n" (* space) "\n" (* space) eos) inside))
            (delete-region inside-start inside-end))

           ;; Delete back from end of the line.
           ;;
           ;;
           ;; foo |
           ;; ->
           ;; foo|

           ;; foo      |
           ;; ->
           ;; foo |
           ((string-empty-p line-after-pt)
            (if (string-match-p (rx space space eos) line-before-pt)
                (while (looking-back (rx space space) (line-beginning-position))
                  (delete-char -1))
              (funcall f args)))

           ;; Don't aggressively delete whitespace if there's a comment
           ;; following pt.
           ;;
           ;;
           ;; foo |  // bar
           ;;
           ;; ->
           ;;
           ;; foo|  // bar
           ;;
           ((string-match-p (rx (* nonl) (syntax comment-start)) line-after-pt)
            (funcall f args))

           ;; Collapse surrounding space, but preserve padding inside pairs.
           ;;
           ;; foo | bar -> foo|bar
           ;;
           ;; foo | }   -> foo| }
           ;;
           ((and (string-match-p (rx (or bol (not space)) space eos) line-before-pt)
                 (string-match-p (rx bos space (or eol (not space))) line-after-pt))
            (let ((backward-only? (when inside (string-match-p (rx bos space) inside))))
              (delete-horizontal-space backward-only?)))

           ;; Delete if there is a single preceding space.
           ;;
           ;; foo |bar -> foo|bar
           ;;
           ;; but not:
           ;;
           ;; foo| bar -> foo|bar
           ;;
           ((and (string-match-p (rx (or bol (not space)) space eos) line-before-pt)
                 (string-match-p (rx bos (not space)) line-after-pt))
            (delete-char -1))

           ;; Delete surrounding whitespace beyond a certain length.
           ;;
           ;; foo    |bar      -> foo |bar
           ;; foo    |    bar  -> foo | bar
           ((string-match-p (rx (+ space) eos) line-before-pt)
            (let ((has-space? (eq (char-after) ? )))
              (skip-chars-forward " ")
              (while (looking-back (rx space space) (line-beginning-position))
                (delete-char -1))
              (when has-space?
                (insert " ")
                (forward-char -1))))

           (t
            (funcall f args))))))

    (advice-add 'sp-backward-delete-char :around #'config-smartparens-delete-horizontal-space-for-delete))
#+end_src

*** Lisps
#+begin_src emacs-lisp
  (use-package smartparens
    :config
    (sp-with-modes (cons 'lisp-data-mode sp-lisp-modes)
      (sp-local-pair "(" nil
                     :pre-handlers '(config-smartparens-add-space-before-sexp-insertion)
                     :post-handlers '(config-smartparens-add-space-after-sexp-insertion))
      (sp-local-pair "[" nil
                     :pre-handlers '(config-smartparens-add-space-before-sexp-insertion)
                     :post-handlers '(config-smartparens-add-space-after-sexp-insertion))
      (sp-local-pair "\"" nil
                     :pre-handlers '(config-smartparens-add-space-before-sexp-insertion)
                     :post-handlers '(config-smartparens-add-space-after-sexp-insertion))
      (sp-local-pair "{" nil
                     :pre-handlers '(config-smartparens-add-space-before-sexp-insertion)
                     :post-handlers '(config-smartparens-add-space-after-sexp-insertion))))
#+end_src

*** Don't pad curly-braces in markdown, org, and latex
#+begin_src emacs-lisp
  (use-package smartparens
    :config
    (sp-with-modes '(org-mode markdown-mode gfm-mode latex-mode)
      (sp-local-pair "{" "}" :pre-handlers nil)))
#+end_src

*** Make checkbox insertion smarter for org-mode and markdown
#+begin_src emacs-lisp
  (use-package smartparens
    :config
    (autoload 'org-in-block-p "org")

    (defun config-smartparens--format-checkitem (_id action context)
      (when (and (eq action 'insert)
                 (if (derived-mode-p 'org-mode)
                     (not (org-in-block-p org-list-forbidden-blocks))
                   t)
                 (string-match-p (rx bos (* space) "-" (* space)
                                     (? "[" (* space) (? "]" (* space)))
                                     (* space)
                                     eos)
                                 (buffer-substring (line-beginning-position)
                                                   (point))))
        (atomic-change-group
          (just-one-space)
          (search-backward "[" (line-beginning-position))
          (just-one-space)
          (search-forward "]" (line-end-position))
          (just-one-space))))

    (sp-with-modes '(org-mode markdown-mode gfm-mode)
      (sp-local-pair "[" "]" :post-handlers '(config-smartparens--format-checkitem))))
#+end_src

*** Remove broken python indentation hack
#+begin_src emacs-lisp
  (use-package smartparens-python
    :config
    (advice-remove 'python-indent-dedent-line-backspace
                   'ad-Advice-python-indent-dedent-line-backspace))
#+end_src

** =elisp-mode= - Emacs Lisp
#+begin_src emacs-lisp
  (use-package elisp-mode
    :general
    (:keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
     "C-c C-c" #'eval-defun
     "C-c C-b" #'eval-buffer)
    (:states 'visual
     :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
     "C-c C-c" #'eval-region))
#+end_src

*** Set leader keys
#+begin_src emacs-lisp
  (mode-leader-set-key :keymaps 'emacs-lisp-mode-map
    "e" '(nil :wk "eval")
    "eb" '(eval-buffer :wk "eval buf")
    "ee" '(eval-expression :wk "eval expr")

    "d" '(nil :wk "debug")
    "df" '(debug-on-entry :wk "function...")
    "dc" '(nil :wk "cancel... (function)")
    "dv" '(debug-on-variable-change :wk "variable...")
    "dV" '(cancel-debug-on-variable-change :wk "cancel... (variable)")

    "t" 'ert)
#+end_src

*** =debug= - Emacs Lisp debugger

**** Set leader keys
#+begin_src emacs-lisp
  (mode-leader-set-key :keymaps 'debugger-mode-map
    "," '(debugger-step-through :wk "step")
    "b" '(debugger-frame :wk "frame")
    "c" '(debugger-continue :wk "continue")
    "j" '(debugger-jump :wk "jump")
    "u" '(debugger-frame-clear :wk "clear frame")

    "e" '(debugger-eval-expression :wk "eval...")
    "R" '(debugger-record-expression :wk "record...")
    "r" '(debugger-return-value :wk "return...")

    "l" '(debugger-list-functions :wk "list functions")
    "v" '(debugger-toggle-locals :wk "toggle locals"))
#+end_src

*** =elisp-slime-nav= - Code navigation                          :disabled:
Use =elisp-slime-nav= to go to definition in Emacs Lisp.
#+begin_src emacs-lisp
  (use-package elisp-slime-nav
    :hook (emacs-lisp-mode . elisp-slime-nav-mode)
    :general
    (:keymaps 'elisp-slime-nav-mode-map :states 'normal
     "M-." #'elisp-slime-nav-find-elisp-thing-at-point))
#+end_src

*** =helpful= - Better help buffer for Elisp
#+begin_src emacs-lisp
  (use-package helpful
    :hook ((emacs-lisp-mode . config--use-helpful-for-evil-lookup)
           (helpful-mode . config--use-helpful-for-evil-lookup)
           (ielm-mode . config--use-helpful-for-evil-lookup))
    :preface
    (defun config--use-helpful-for-evil-lookup ()
      (setq-local evil-lookup-func 'helpful-at-point)))
#+end_src

*** =ielm= - Emacs Lisp REPL
#+begin_src emacs-lisp
  (use-package ielm
    :hook (ielm-mode . hs-minor-mode)
    :general
    (:keymaps 'ielm-map
     "C-c C-k" 'quit-window))
#+end_src

**** Pop back and forth between IELM and Elisp buffers with ~C-c C-z~
#+begin_src emacs-lisp
  (use-package ielm
    :general
    (:keymaps 'emacs-lisp-mode-map "C-c C-z" #'ielm)
    (:keymaps 'ielm-map
     "C-c C-z" #'config-elisp-pop-to-elisp-buffer)
    :preface
    (defun config-elisp-pop-to-elisp-buffer ()
      (interactive)
      (if-let* ((buf (seq-find (lambda (buf)
                                 (with-current-buffer buf
                                   (derived-mode-p 'emacs-lisp-mode)))
                               (buffer-list))))
          (pop-to-buffer buf)
        (user-error "No Emacs Lisp buffers"))))
#+end_src

**** Teach xref to work correctly in IELM buffers
#+begin_src emacs-lisp
  (use-package ielm
    :hook (ielm-mode . config-ielm-xref-setup)
    :preface
    (defun config-ielm-xref-setup ()
      (setq-local xref-backend-functions '(elisp--xref-backend t))))
#+end_src

*** =pp= - S-Expression Pretty-printing
#+begin_src emacs-lisp
  (use-package pp
    :general
    (:keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map ielm-mode-map)
     :states '(motion normal insert)
     "C-c C-<return>" 'pp-eval-last-sexp
     "C-c <return>" 'pp-eval-last-sexp
     "C-c C-e" 'pp-macroexpand-last-sexp))
#+end_src

*** Improve indent function
Teach the Emacs Lisp indentation function to indent plists nicely.
#+begin_src emacs-lisp
  (use-package lisp-mode
    :preface
    (progn
      (defvar calculate-lisp-indent-last-sexp)

      (defun config-elisp--better-lisp-indent-function (indent-point state)
        (let ((normal-indent (current-column))
              (orig-point (point)))
          (goto-char (1+ (elt state 1)))
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond
           ;; car of form doesn't seem to be a symbol, or is a keyword
           ((and (elt state 2)
                 (or (not (looking-at "\\sw\\|\\s_"))
                     (looking-at ":")))
            (unless (> (save-excursion (forward-line 1) (point))
                       calculate-lisp-indent-last-sexp)
              (goto-char calculate-lisp-indent-last-sexp)
              (beginning-of-line)
              (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t))

            ;; Indent under the list or under the first sexp on the same
            ;; line as calculate-lisp-indent-last-sexp.  Note that first
            ;; thing on that line has to be complete sexp since we are
            ;; inside the innermost containing sexp.
            (backward-prefix-chars)
            (current-column))
           ((and (save-excursion
                   (goto-char indent-point)
                   (skip-syntax-forward " ")
                   (not (looking-at ":")))
                 (save-excursion
                   (goto-char orig-point)
                   (looking-at ":")))
            (save-excursion
              (goto-char (+ 2 (elt state 1)))
              (current-column)))
           (t
            (let ((function (buffer-substring (point)
                                              (progn (forward-sexp 1) (point))))
                  method)
              (setq method (or (function-get (intern-soft function)
                                             'lisp-indent-function)
                               (get (intern-soft function) 'lisp-indent-hook)))
              (cond ((or (eq method 'defun)
                         (and (null method)
                              (> (length function) 3)
                              (string-match "\\`def" function)))
                     (lisp-indent-defform state indent-point))
                    ((integerp method)
                     (lisp-indent-specform method state
                                           indent-point normal-indent))
                    (method
                     (funcall method indent-point state)))))))))
    :custom
    (lisp-indent-function #'config-elisp--better-lisp-indent-function))
#+end_src

*** Emacs lisp syntax checking

**** =checkdoc= - linting for Elisp docstrings
#+begin_src emacs-lisp
  (use-package checkdoc
    :after (:all flycheck elisp-mode)
    :demand t
    :custom
    (checkdoc-force-docstrings-flag nil)
    (checkdoc-arguments-in-order-flag nil))
#+end_src

**** =flycheck-package= - checker for =package.el= conventions
#+begin_src emacs-lisp
  (use-package flycheck-package
    :after (:all flycheck elisp-mode)
    :demand t
    :config
    (flycheck-package-setup))
#+end_src

**** Disable these checkers in org src blocks
#+begin_src emacs-lisp
  (defun disable-flycheck-checkers-for-org-src-block ()
    (push 'emacs-lisp-package flycheck-disabled-checkers)
    (push 'emacs-lisp-checkdoc flycheck-disabled-checkers))

  (add-hook 'org-src-mode-hook 'disable-flycheck-checkers-for-org-src-block)
#+end_src

** =prettify-symbols-mode= - Pretty lambdas in Lisp modes
#+begin_src emacs-lisp
  (use-package prettify-symbols-mode
    :hook
    (emacs-lisp-mode . prettify-symbols-mode)
    (prettify-symbols-mode . prettify-symbols-setup)
    :preface
    (defun prettify-symbols-setup ()
      (cond
       ((derived-mode-p 'emacs-lisp-mode 'lisp-mode 'scheme-mode)
        (setq-local prettify-symbols-alist '(("lambda" . #x3bb)))))))
#+end_src

** =typescript-mode= - TypeScript language support
=typescript-mode= adds a major mode with syntax highlighting for TypeScript
files.

#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode
    ("\\.tsx?\\'" . typescript-mode)
    ("\\.ts\\.snap\\'" . typescript-mode)
    :custom
    (typescript-indent-level 2))
#+end_src

** =nix-mode= Configure support for the Nix language
#+begin_src emacs-lisp
  (use-package nix-mode
    :custom
    (nix-indent-function 'nix-indent-line))
#+end_src

** =yaml-mode= - YAML editing support
#+begin_src emacs-lisp
  (defun disable-autofill ()
    (auto-fill-mode -1))

  (use-package yaml-mode
    :general
    (:states '(normal insert) :keymaps 'yaml-mode-map
     [backtab] 'yaml-indent-line)
    :config
    (add-hook 'yaml-mode-hook #'disable-autofill))
#+end_src

*** =origami= - code folding
#+begin_src emacs-lisp
  (use-package origami
    :hook (yaml-mode . origami-mode)
    :general
    (:states 'normal :keymaps 'origami-mode-map
     "TAB" 'origami-recursively-toggle-node
     "S-<tab>" 'origami-toggle-all-nodes))
#+end_src

** =json-mode= - JSON editing support
#+begin_src emacs-lisp
  (use-package json-mode
    :commands (json-mode)
    :mode ("\\.json\\'" . json-mode)
    :custom
    (json-reformat:indent-width 2))
#+end_src

** =highlight-indent-guides= - show indentation level indicators
#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :hook
    (yaml-mode . highlight-indent-guides-mode)
    (json-mode . highlight-indent-guides-mode))
#+end_src

** =markdown-mode= - Markdown file support
#+begin_src emacs-lisp
  (use-package markdown-mode
    :hook
    (markdown-mode . visual-line-mode)

    :general
    (:states 'normal :keymaps 'markdown-mode-map
     "TAB" #'markdown-cycle
     "RET" #'markdown-follow-thing-at-point)
    (:keymaps 'markdown-mode-map
     "C-c C-l" #'markdown-insert-link
     "C-c C-i" #'markdown-insert-image
     "C-c C-f" #'markdown-insert-footnote
     "C-c C--" #'markdown-insert-hr
     "C-c C-e" #'markdown-export
     "C-c C-o" #'markdown-preview
     "C-c p" #'markdown-live-preview-mode
     "C-<return>" #'markdown-insert-header-dwim
     "M-<left>" #'markdown-promote
     "M-<right>" #'markdown-demote
     "M-<up>" #'markdown-move-subtree-up
     "M-<down>" #'markdown-move-subtree-down)

    :custom
    (markdown-asymmetric-header t)
    (markdown-command "multimarkdown")
    (markdown-fontify-code-blocks-natively t)
    (markdown-hide-urls t))
#+end_src

#+begin_src emacs-lisp
  (mode-leader-set-key :keymaps '(gfm-mode-map markdown-mode-map)
    "i" '(nil :wk "insert")
    "i h" '(markdown-insert-header-dwim :wk "header")
    "i c" '(markdown-insert-gfm-code-block :wk "code block...")
    "i i" '(markdown-insert-image :wk "image")
    "i f" '(markdown-insert-footnote :wk "footnote")
    "i l" '(markdown-insert-link :wk "link")
    "i w" '(markdown-insert-wiki-link :wk "wiki link")
    "i -" '(markdown-insert-hr :wk "hr")

    "m" '(nil :wk "markup")
    "m b" '(markdown-insert-bold :wk "bold")
    "m i" '(markdown-insert-italic :wk "italic")
    "m k" '(markdown-insert-kbd :wk "kbd")
    "m q" '(markdown-insert-blockquote :wk "blockquote")
    "m s" '(markdown-insert-strike-through :wk "strike-through")

    "o" '(markdown-preview :wk "preview")
    "p" '(markdown-live-preview-mode :wk "preview (live)")
    "e" '(markdown-export :wk "export"))
#+end_src

** =ledger-mode= - Ledger accounting software interface
#+begin_src emacs-lisp
  (use-package ledger-mode
    :general

    (:keymaps 'ledger-report-mode-map
     "C-c C-c" #'ledger-report
     "q" #'kill-buffer-and-window)

    (:keymaps 'ledger-mode-map
     "C-c C-c" #'ledger-report
     "M-RET" #'ledger-toggle-current-transaction)

    :custom
    (ledger-report-use-header-line nil)
    (ledger-post-account-alignment-column 2)
    (ledger-fontify-xact-state-overrides nil))
#+end_src

*** Highlight negative numbers in red
#+begin_src emacs-lisp
  (use-package ledger-mode
    :preface
    (defface ledger-report-negative-amount
      `((t (:foreground "red")))
      "Face for negative amounts in ledger reports."
      :group 'ledger-faces)

    :config
    (font-lock-add-keywords
     'ledger-report-mode
     `((,(rx "$" (* space) "-" (+ digit) (* (any digit ",")) (? "." (+ digit))) . 'ledger-report-negative-amount)
       (,(rx (+ digit) "-" (= 3 alpha) "-" (+ digit)) . 'ledger-font-posting-date-face)))

    (add-hook 'ledger-report-mode-hook 'font-lock-fontify-buffer))
#+end_src

*** Changing transaction timestamps
Use =C-c C-.= to change the timestamp of the transaction at point.
#+begin_src emacs-lisp
  (use-package ledger-mode
    :general
    (:keymaps 'ledger-mode-map
     "C-c C-." #'config-ledger-set-xact-timestamp)
    :preface
    (defun config-ledger-set-xact-timestamp ()
      (interactive)
      (when-let* ((ctx (ledger-xact-context))
                  (value (ledger-context-field-value ctx 'date))
                  (start (ledger-context-field-position ctx 'date))
                  (end (ledger-context-field-end-position ctx 'date))
                  (updated (ledger-read-date "Transaction date: ")))
        (if (string= value updated)
            (user-error "Date unchanged")
          (save-excursion
            (goto-char start)
            (delete-region start end)
            (insert updated))
          (let ((message-log-max))
            (message "Date changed: %s -> %s" value updated))))))
#+end_src

*** Format ledger buffer
Define a command to format a ledger buffer.
#+begin_src emacs-lisp
  (use-package ledger-mode
    :general (:keymaps 'ledger-mode-map "M-q" #'ledger-format-buffer)

    :functions (ledger-mode-clean-buffer)
    :preface
    (defvar ledger-post-amount-alignment-column 52)

    (defun ledger-format--align-price-assertion ()
      (when (string-match-p (rx (+ space) "=" (* space) (not (any digit)))
                            (buffer-substring (line-beginning-position)
                                              (line-end-position)))
        (unwind-protect
            (progn
              (goto-char (line-beginning-position))
              (search-forward "=")
              (goto-char (match-beginning 0))
              (indent-to (1+ ledger-post-amount-alignment-column))
              (skip-chars-forward " =")
              (just-one-space))
          (goto-char (line-end-position)))))

    (defun ledger-format-buffer ()
      "Reformat the buffer."
      (interactive "*")
      (let ((pos (point)))
        (ignore-errors
          (ledger-mode-clean-buffer))
        (goto-char (point-min))
        (while (search-forward-regexp (rx (>= 2 space) "=") nil t)
          (ledger-format--align-price-assertion))
        (goto-char pos))))
#+end_src

*** =flycheck-ledger= - Flycheck support for ledger buffers
#+begin_src emacs-lisp
  (use-package flycheck-ledger
    :after (:all flycheck ledger-mode)
    :demand t)
#+end_src

** =autctex= - Tex & Latex editing
Use =auctex= as the Tex and Latex editing mode.
=auctex= is disgusting and clobbers the builtin Tex modes. To load it lazily,
intercept attempts to load Tex files and make sure =auctex= is loaded first.

#+begin_src emacs-lisp
  (defun config-latex--lazy-load-auctex ()
    (when (string-match-p (rx "." (or "latex" "tex") string-end)
                          (buffer-name))
      (require 'tex-site)))

  (add-hook 'find-file-hook #'config-latex--lazy-load-auctex)
#+end_src

#+begin_src emacs-lisp
  (use-package tex
    :preface
    (defvar-local TeX-syntactic-comments t)
    :custom
    (TeX-command (getenv "NIX_EMACS_TEX_PROGRAM"))
    (TeX-auto-save t)
    (TeX-parse-self t)
    (TeX-source-correlate-start-server nil)
    ;; Use Emacs pdf-tools as viewer.
    (TeX-view-program-selection '((output-pdf "PDF Tools")))
    (TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view))))
#+end_src

#+begin_src emacs-lisp
  (use-package latex
    :custom
    (LaTeX-command (getenv "NIX_EMACS_TEX_PROGRAM"))
    ;; Don't insert line-break at inline math.
    (LaTeX-fill-break-at-separators nil)
    :config
    (add-hook 'LaTeX-mode-hook 'flyspell-mode)
    (add-hook 'LaTeX-mode-hook 'TeX-fold-mode)
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
    (add-hook 'LaTeX-mode-hook 'TeX-PDF-mode))
#+end_src

*** Smarter autofill function
Teach the autofill function in Latex buffers not to fill in certain contexts.
#+begin_src emacs-lisp
  (use-package latex
    :functions (LaTeX-current-environment)
    :config
    (defvar config-latex-no-indent-envs '("equation" "equation*" "align" "align*" "tabular" "tikzpicture"))

    (defun config-latex--autofill ()
      ;; Check whether the pointer is currently inside one of the
      ;; environments described in `config-latex-no-indent-envs' and if so, inhibits
      ;; the automatic filling of the current paragraph.
      (let ((env)
            (should-fill t)
            (level 0))
        (while (and should-fill (not (equal env "document")))
          (cl-incf level)
          (setq env (LaTeX-current-environment level))
          (setq should-fill (not (member env config-latex-no-indent-envs))))

        (when should-fill
          (do-auto-fill))))

    (defun config-latex--configure-autofill ()
      (auto-fill-mode +1)
      (setq-local auto-fill-function #'config-latex--autofill))

    (add-hook 'LaTeX-mode-hook 'config-latex--configure-autofill))
#+end_src

*** Build command
=C-c C-c= builds the current buffer with =tectonic=.
#+begin_src emacs-lisp
  (use-package latex
    :general
    (:keymaps 'LaTeX-mode-map
     "C-c C-b" #'config-latex-build)
    :preface
    (autoload 'TeX-command "tex-buf")
    (autoload 'TeX-master-file "tex")
    (autoload 'TeX-save-document "tex-buf")

    (defvar TeX-save-query)

    (defun config-latex-build ()
      (interactive)
      (progn
        (let ((TeX-save-query nil))
          (TeX-save-document (TeX-master-file)))
        (TeX-command (getenv "NIX_EMACS_TEX_PROGRAM") 'TeX-master-file -1))))
#+end_src

*** Environment folding
=tex-fold= enables folding of macros and environments. It's part of =auctex=.
#+begin_src emacs-lisp
  (use-package tex-fold
    :after tex
    :demand t)
#+end_src

*** Code completion
#+begin_src emacs-lisp
  (use-package company-auctex
    :after (:all tex company)
    :demand t
    :config (company-auctex-init))
#+end_src

*** Show preview on save
#+begin_src emacs-lisp
  (use-package latex-preview-pane
    :general (:keymaps 'LaTeX-mode-map "C-c p" #'latex-preview-pane))
#+end_src

** =graphql= - GraphQL schema definition language editing support

*** Teach dumb-jump about GraphQL files
#+begin_src emacs-lisp
  (use-package graphql-mode
    :after dumb-jump
    :config
    (add-to-list 'dumb-jump-language-file-exts '(:language "graphql" :ext "graphql" :agtype nil :rgtype nil))
    (add-to-list 'dumb-jump-language-file-exts '(:language "graphql" :ext "gql" :agtype nil :rgtype nil))

    (add-to-list 'dumb-jump-find-rules
                 '(:type "type" :supports ("ag" "grep" "rg") :language "graphql"
                   :regex "(input|type|union)\\s+JJJ\\b"))
    (add-to-list 'dumb-jump-find-rules
                 '(:type "enum"
                   :supports ("ag" "grep" "rg") :language "graphql"
                   :regex "enum\\s+JJJ\\b"))
    (add-to-list 'dumb-jump-find-rules
                 '(:type "scalar"
                   :supports ("ag" "grep" "rg") :language "graphql"
                   :regex "scalar\\s+JJJ\\b")))
#+end_src

** =js= - Editing support for JavaScript
#+begin_src emacs-lisp
  (use-package js
    :mode ("\\.[cm]?jsx?\\'" . js-mode)
    :custom
    (js-indent-level 2)
    (js-switch-indent-offset 2)
    (js-js-tmpdir (f-join paths-cache-directory "js")))
#+end_src

** =plantuml-mode= - Editing support for PlantUML diagrams
#+begin_src emacs-lisp
  (use-package plantuml-mode
    :general
    (:keymaps 'plantuml-mode-map
     "C-c C-b" 'recompile)

    :custom
    (plantuml-default-exec-mode 'jar)
    (plantuml-indent-level 2)
    (plantuml-jar-path (getenv "NIX_EMACS_PLANTUML_JAR"))

    :config
    (modify-syntax-entry ?_ "w" plantuml-mode-syntax-table))
#+end_src

*** Flycheck support
#+begin_src emacs-lisp
  (use-package flycheck-plantuml
    :after (:all flycheck plantuml-mode)
    :demand t
    :config (flycheck-plantuml-setup))
#+end_src

*** Highlight arrows and important keywords
#+begin_src emacs-lisp
  (use-package plantuml-mode
    :config
    (defconst config-plantuml--participant-binder-rx
      `(and word-start (+? (syntax word)) word-end))

    (defconst config-plantuml--arrows-rx
      (let* ((direction '(or "up" "u" "down" "d" "left" "l" "right" "r"))
             (directives '(and "[" (*? nonl) "]"))
             (lines '(+ "-"))
             (dots '(+ ".")))
        ;; HACK: Make sure we have at least 2 characters in an arrow to avoid
        ;; nonsense.
        `(or  "---"
              "..."
              (and "<" ,lines)
              (and "<" ,dots)
              (and ,lines ">")
              (and ,dots ">")
              (and "<" ,lines ">")
              (and "<" ,dots ">")
              (and (? "<")
                   (or (and ,lines (? ,directives) (? ,direction) ,lines)
                       (and ,dots (? ,directives) (? ,direction) ,dots))
                   (? ">")))))

    (font-lock-add-keywords
     'plantuml-mode
     `((,(rx bol (* space) (group (or "@startuml" "@enduml")))
        (0 'font-lock-preprocessor-face))

       (,(rx bol (* space) (group "title") symbol-end)
        (1 'font-lock-preprocessor-face))

       (,(rx bol (* space) (group "note"))
        (1 'font-lock-keyword-face)
        (,(rx (+ space) (group (or "left" "right" "bottom" "top") (+ space) (group "of")))
         nil nil
         (1 'font-lock-keyword-face)
         (2 'font-lock-keyword-face))
        (,(rx (+ space) (group (+ (syntax word))) eol)
         nil nil
         (1 'font-lock-variable-name-face)))

       (,(rx bol (* space) (group "end" (+ space) "note"))
        (1 'font-lock-keyword-face))

       (,(rx bol (* space) (group "!include" (* word)))
        (0 font-lock-keyword-face)
        (,(rx (+ nonl)) nil nil (0 'font-lock-string-face)))

       (,(rx bol (* space) (group "!startsub"))
        (0 'font-lock-preprocessor-face)
        (,(rx (+ nonl)) nil nil (0 'font-lock-function-name-face)))

       (,(rx bol (* space) (group "!endsub")) (0 'font-lock-preprocessor-face))

       ;; Naive macro highlighting

       (,(rx bol (* space) (group upper (* (syntax word))) (* space) "("
             (? (group (+ (syntax word)))))
        (1 'font-lock-type-face)
        (2 'font-lock-variable-name-face))

       ;; Groupings

       (,(rx bol (* space) (group (or "package" "node" "folder" "frame" "cloud" "database"))
             symbol-end)
        (1 'font-lock-keyword-face)
        (,(rx symbol-start (group "as") (+ space) (group (+ (syntax word)) symbol-end))
         nil nil
         (1 'font-lock-keyword-face)
         (2 'font-lock-variable-name-face)))

       ;; Sequence diagrams

       (,(rx bol (* space) (group (or "actor" "boundary" "control"
                                      "entity" "database" "collections"))
             (? (+ space)
                (group (+ (syntax word)))
                symbol-end))
        (1 'font-lock-keyword-face)
        (2 'font-lock-variable-name-face))


       ;; Improved arrows syntax highlighting

       (,(rx-to-string `(and bol
                             (* space) (group ,config-plantuml--participant-binder-rx)
                             (* space) (group ,config-plantuml--arrows-rx)
                             (* space) (group ,config-plantuml--participant-binder-rx))
                       t)
        (1 'font-lock-variable-name-face)
        (2 'font-lock-keyword-face)
        (3 'font-lock-variable-name-face)
        (,(rx (group ":") (* space) (group (* nonl)))
         nil nil
         (1 'font-lock-keyword-face)
         (2 'font-lock-string-face)))

       ;; Creole text formatting: https://plantuml.com/creole

       (,(rx (not "~") (group "**") (group (+? any)) (group "**"))
        (1 'parenthesis)
        (2 'bold)
        (3 'parenthesis))

       (,(rx (not "~") (group "//") (group (+? any)) (group "//"))
        (1 'parenthesis)
        (2 'italic)
        (3 'parenthesis))

       (,(rx (not "~") (group "\"\"") (group (+? any)) (group "\"\""))
        (1 'parenthesis)
        (2 'org-code)
        (3 'parenthesis))

       (,(rx (not "~") (group "--") (group (+? any)) (group "--"))
        (1 'parenthesis)
        (2 '(:strike-through t))
        (3 'parenthesis))

       (,(rx (not "~") (group "__") (group (+? any)) (group "__"))
        (1 'parenthesis)
        (2 'underline)
        (3 'parenthesis))

       (,(rx (not "~") (group "~~") (group (+? any)) (group "~~"))
        (1 'parenthesis)
        (2 '(:underline (:style wave)))
        (3 'parenthesis))

       (,(rx bol (* space) (group (+ "#")) (+ (not (any "*"))))
        (1 'org-list-dt))

       (,(rx bol (* space) (group "*") (+ (not (any "*"))))
        (1 'org-list-dt)))))
#+end_src

** =terraform-mode= & =hcl-mode= - Editing support for Terraform

*** Format HCL buffers on save
#+begin_src emacs-lisp
  (use-package hcl-mode
    :after format-all
    :config
    ;; Dynamically eval to avoid macroexpansion error
    (eval
     '(define-format-all-formatter terragrunt-fmt
        (:executable "terragrunt")
        (:install (macos "brew install terragrunt"))
        (:languages "Terragrunt")
        (:features)
        (:format (format-all--buffer-easy executable "fmt" "-no-color" "-"))))

    (add-to-list 'format-all-default-formatters 'terragrunt-fmt))
#+end_src

** =css-mode= - CSS editing support
#+begin_src emacs-lisp
  (use-package css-mode
    :defer t
    :custom
    (css-indent-offset 2))
#+end_src

** =hexl-mode= - Hex editing
=hexl= is Emacs' built-in hex editor.
#+begin_src emacs-lisp
  (use-package hexl
    :general
    (:states 'motion :keymaps 'hexl-mode-map
     "]]" #'hexl-end-of-1k-page
     "[[" #'hexl-beginning-of-1k-page
     "h" #'hexl-backward-char
     "l" #'hexl-forward-char
     "j" #'hexl-next-line
     "k" #'hexl-previous-line
     "$" #'hexl-end-of-line
     "^" #'hexl-beginning-of-line
     "0" #'hexl-beginning-of-line))
#+end_src

** =conf-mode= - Configuration files
Configure =conf-mode= for use with more kinds of config files.
#+begin_src emacs-lisp
  (use-package conf-mode
    :mode
    ("\\.env" . conf-mode)
    ("\\.kll\\'" . conf-mode))
#+end_src

** =clojure-mode=

*** Set up major-mode leader keybindings
#+begin_src emacs-lisp
  (mode-leader-set-key :keymaps 'clojure-mode-map
    "j" '(cider-jack-in :wk "jack in")
    "M" '(cider-run :wk "run main")
    "a" '(cider-apropos :wk "apropos")
    ":" '(cider-read-and-eval :wk "eval")

    "e" '(nil :wk "eval...")
    "es" '(cider-eval-sexp-at-point :wk "eval sexp at pt")
    "eS" '(cider-eval-sexp-at-point-in-context :wk "eval sexp at pt (bindings)")
    "eb" '(cider-eval-buffer :wk "eval buffer")
    "ed" '(cider-eval-defun-at-point :wk "eval defun")
    "en" '(cider-eval-ns-form :wk "eval ns form")
    "ep" '(cider-eval-print-last-sexp :wk "eval and print to buffer")

    "f" '(nil :wk "find...")
    "ff" '(cider-find-dwim :wk "find dwim")
    "fF" '(cider-find-dwim-other-window :wk "find dwim (other window)")
    "fk" '(cider-find-keyword :wk "find keyword")
    "fn" '(cider-find-ns :wk "find ns")
    "fr" '(cider-find-resource :wk "find resource")
    "fv" '(cider-find-var :wk "find var")

    "p" '(cider-classpath :wk "list classpath")

    "R" '(cider-restart :wk "restart cider")
    "Q" '(cider-quit :wk "quit cider")

    "s" '(cider-scratch :wk "scratch buffer")

    "t" '(nil :wk "test...")
    "ta" '(cider-auto-test-mode :wk "toggle auto-test ns")
    "tf" '(cider-test-rerun-failed-tests :wk "test failed")
    "tl" '(cider-test-run-loaded-tests :wk "test loaded")
    "tp" '(cider-test-run-project-tests :wk "test project")
    "tr" '(cider-test-rerun-test :wk "re-run last")
    "tt" '(cider-test-run-test :wk "test at point"))
#+end_src

*** Fix mysteriously shadowed binding
#+begin_src emacs-lisp
  (use-package smartparens
    :general
    (:keymaps '(clojure-mode-map cider-repl-mode-map) :states 'insert
     "DEL" 'sp-backward-delete-char))
#+end_src

*** =cider= - interactive programming environment for Clojure
#+begin_src emacs-lisp
  (use-package cider
    :general
    (:states '(normal insert) :keymaps 'cider-mode-map
     "M-." 'cider-find-dwim)
    :custom
    (cider-repl-display-help-banner nil)
    (cider-allow-jack-in-without-project t))
#+end_src

* Applications

** =pass= - Frontend to Unix ~password-store~
#+begin_src emacs-lisp
  (use-package pass
    :commands (pass)
    :after (password-store)

    :general
    (:states '(normal) :keymaps 'pass-view-mode-map "q" #'kill-this-buffer)
    (:states '(normal) :keymaps 'pass-mode-map
     "u" #'pass-copy-username
     "U" #'pass-copy-url
     "J" #'pass-goto-entry
     "y" #'pass-copy-password
     "f" #'pass-copy-field
     "q" #'kill-this-buffer)

    :custom
    (pass-username-field "email"))
#+end_src

** =pdf-tools= - PDF reader
#+begin_src emacs-lisp
  (use-package pdf-tools
    :mode ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
    :general (:states '(motion normal) :keymaps 'pdf-view-mode-map
              "t" #'pdf-view-midnight-minor-mode
              "n" #'pdf-view-next-page
              "N" #'pdf-view-previous-page
              "p" #'pdf-view-previous-page)
    :hook
    (pdf-view-mode . pdf-view-midnight-minor-mode)

    :custom
    (pdf-view-display-size 'fit-page)

    :init
    (use-package pdf-history
      :commands (pdf-history-minor-mode))
    (use-package pdf-occur
      :commands (pdf-occur-global-minor-mode))

    :config
    (require 'pdf-annot)
    (require 'pdf-sync)
    (require 'pdf-links)
    (require 'pdf-outline)
    (require 'pdf-history)
    (require 'pdf-cache)
    (require 'pdf-view)

    ;; Redefine a few macros as functions to work around byte compilation errors.
    (defun pdf-view-current-page (&optional window)
      (image-mode-window-get 'page window))

    (defun pdf-view-current-overlay (&optional window)
      (image-mode-window-get 'overlay window))

    (pdf-tools-install))
#+end_src

** =mu4e= - Mail user agent
Use the system's =mu4e= installation for mail management. I use the
systemd/launchd to run mbsync and indexing, so mu4e doesn't trigger fetching
itself.

#+begin_src emacs-lisp
  (add-to-list 'load-path (getenv "NIX_EMACS_MU_LISP_DIR"))

  (use-package mu4e
    :commands (mu4e mu4e-compose-new)
    :custom
    (mu4e-mu-binary (getenv "NIX_EMACS_MU_BINARY"))
    (mu4e-attachment-dir (f-expand "~/Downloads"))
    (mu4e-headers-fields '((:human-date . 10)
                           (:flags . 6)
                           (:from . 22)
                           (:subject)))
    (mu4e-context-policy 'pick-first)
    (mu4e-compose-context-policy 'ask-if-none)
    (message-kill-buffer-on-exit t)
    (mu4e-view-use-gnus t)
    (mu4e-use-fancy-chars t)
    (mu4e-headers-include-related nil)
    (mu4e-headers-attach-mark '("a" . "📎"))
    (mu4e-headers-unread-mark '("u" . "●"))
    (mu4e-headers-seen-mark '(" " . " "))
    (mu4e-hide-index-messages t)
    (mu4e-headers-skip-duplicates t)
    (mu4e-index-lazy-check t)
    (mu4e-confirm-quit t)
    (mu4e-view-prefer-html t)
    (mu4e-view-show-images t)
    (mu4e-view-show-addresses t)
    (mu4e-headers-date-format "%Y-%m-%d %k:%M")
    (mu4e-completing-read-function #'completing-read)
    (sendmail-program "msmtp")
    (message-send-mail-function #'message-send-mail-with-sendmail)
    (mu4e-change-filenames-when-moving t)

    ;; Update every 30 seconds.
    (mu4e-update-interval 30)

    ;; Ensure I'm never prompted for the buffer coding system when sending mail.
    (sendmail-coding-system 'utf-8)

    ;; Send email with long lines and format=flowed.
    (mu4e-compose-format-flowed t)
    (fill-flowed-encode-column 998)

    ;; Custom rendering of HTML messages
    (mu4e-html2text-command #'config-mail--shr-buffer))
#+end_src

*** Always use =mu4e= for mail composition
#+begin_src emacs-lisp
  (global-set-key [remap compose-mail] #'mu4e-compose-new)
#+end_src

*** Auto-load the mu4e org link type
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (autoload 'mu4e-org-open "mu4e-org")
    (autoload 'mu4e-org-store-link "mu4e-org")

    (org-link-set-parameters "mu4e"
                             :follow #'mu4e-org-open
                             :store  #'mu4e-org-store-link))
#+end_src

*** Wrap lines in an intuitive way while viewing and editing.
#+begin_src emacs-lisp
  (use-package mu4e
    :config
    ;; Use word wrap instead of auto-fill.
    (add-hook 'mu4e-compose-mode-hook #'turn-off-auto-fill)
    (add-hook 'mu4e-compose-mode-hook (lambda () (setq word-wrap t)))

    ;; Wrap lines when viewing.
    (add-hook 'mu4e-view-mode-hook #'visual-line-mode))
#+end_src

*** Define commands for viewing messages in a browser
Either with =eww= or the default system browser.
#+begin_src emacs-lisp
  (use-package mu4e
    :config
    ;; View html message in eww. `av` in view to activate
    (add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t))
#+end_src

*** Define a smart refile action for ~r~
Marks messages as 'read' and moves them into the appropriate folder.
#+begin_src emacs-lisp
  (use-package mu4e
    :config
    (defun config-mail--message-from-me-p (msg)
      (equal (mu4e-get-sent-folder msg) (mu4e-message-field msg :maildir)))

    (setf (alist-get 'refile mu4e-marks)
          '(:char ("r" . "▶")
            :prompt "refile"
            :dyn-target (lambda (target msg)
                          (if (config-mail--message-from-me-p msg)
                              (mu4e-get-sent-folder msg)
                            (mu4e-get-refile-folder msg)))
            :action (lambda (docid msg target)
                      (unless (config-mail--message-from-me-p msg)
                        (mu4e~proc-move docid (mu4e~mark-check-target target) "+S-u-N"))))))
#+end_src

*** Insert signatures before quoted content, as in other mail user agents
#+begin_src emacs-lisp
  (use-package mu4e
    :custom
    (message-forward-before-signature nil)
    (message-citation-line-function #'message-insert-formatted-citation-line)
    (message-citation-line-format "On %a, %b %d %Y, %f wrote:\n")

    :config
    (defun mu4e--insert-signature-before-quoted-message ()
      (unless (member mu4e-compose-type '(edit resend))
        (save-excursion
          (save-restriction
            (widen)
            (cond
             ((eq mu4e-compose-type 'new)
              (message-goto-body)
              (kill-region (point) (point-max)))
             ((message-goto-signature)
              (forward-line -2)
              (delete-region (point) (point-max))))

            (message-goto-body)
            (insert "\n")
            (narrow-to-region (point-min) (point))

            (let ((message-signature t)
                  (mu4e-compose-signature t)
                  (mu4e-compose-signature-auto-include t))
              (message-insert-signature))

            (when (member mu4e-compose-type '(forward reply))
              (goto-char (point-max))
              (insert "\n"))))))

    (add-hook 'mu4e-compose-mode-hook #'mu4e--insert-signature-before-quoted-message))
#+end_src

*** Don't quit mu4e, just bury the buffer
#+begin_src emacs-lisp
  (global-set-key [remap mu4e-quit] #'bury-buffer)
#+end_src

*** Teach =org-mode= how to store links to messages in =mu4e=
#+begin_src emacs-lisp
  (use-package org-mu4e
    :after (:any org mu4e))
#+end_src

*** Display newline symbols in the buffer when a hard newline would be used
Normally newlines are reflowed automatically.
#+begin_src emacs-lisp
  (use-package messages-are-flowing
    :commands (messages-are-flowing--mark-hard-newlines)
    :init
    (defun setup-hard-newlines ()
      (use-hard-newlines nil 'always)
      (add-hook 'after-change-functions 'messages-are-flowing--mark-hard-newlines nil t))
    :hook (message-mode . setup-hard-newlines))
#+end_src

* ✍🏻 =org-mode= - Org document format & editing support

** Set general org-mode variables
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-directory paths-org-directory)
    (org-default-notes-file (f-join paths-org-directory "notes.org"))
    (org-bookmark-names-plist nil)
    (org-imenu-depth 4)
    (org-indirect-buffer-display 'current-window)
    (org-link-elisp-confirm-function 'y-or-n-p)
    (org-image-actual-width nil)
    (org-return-follows-link t)
    (org-use-property-inheritance t)
    (org-ellipsis " …")
    (org-indent-mode-turns-on-hiding-stars t)

    :config
    (add-hook 'org-mode-hook #'auto-fill-mode)
    (add-hook 'org-mode-hook #'abbrev-mode)
    (add-hook 'org-mode-hook #'auto-revert-mode)
    (add-hook 'org-mode-hook #'visual-line-mode)

    :general
    ("C-c a" 'org-agenda
     "C-c s" 'org-search-view
     "C-c t" 'org-todo-list
     "C-c /" 'org-tags-view)
    (:states '(insert) :keymaps 'org-mode-map
     "<tab>" (general-predicate-dispatch 'org-cycle
               (yas--templates-for-key-at-point) 'yas-expand))
    (:states '(emacs normal) :keymaps 'org-mode-map
     "<backtab>" 'org-global-cycle
     "<tab>" 'org-cycle
     "C-c c" 'org-columns
     "C-c d" 'org-dynamic-block-insert-dblock
     "C-c n" 'org-next-link
     "C-c p" 'org-previous-link
     "M-n" 'org-metadown
     "M-p" 'org-metaup
     "RET" 'org-open-at-point)
    (:states '(normal motion insert emacs) :keymaps 'org-mode-map
     "M-+" 'org-table-insert-column
     "M--" 'org-table-delete-column
     "C-c C-." 'org-time-stamp-inactive
     "C-c ." 'org-time-stamp
     "C-c o" 'org-table-toggle-coordinate-overlays))
#+end_src

** Set up major-mode leader keybindings
#+begin_src emacs-lisp
  ;; https://stackoverflow.com/a/28031539
  (defun config-org-focus-entry ()
    "Show only the entry at point, keeping other entries closed."
    (interactive)
    (if (save-excursion (end-of-line) (outline-invisible-p))
        (progn (org-show-entry) (org-show-children))
      (outline-back-to-heading)
      (unless (and (bolp) (org-on-heading-p))
        (org-up-heading-safe)
        (hide-subtree)
        (user-error "Boundary reached"))
      (org-overview)
      (org-reveal t)
      (org-show-entry)
      (org-show-children)))


  (mode-leader-set-key :keymaps 'org-mode-map
    "A" '(org-archive-subtree :wk "archive")
    "/" '(org-sparse-tree :wk "sparse tree...")
    "#" '(org-decrypt-entries :wk "decrypt entries")
    "RET" '(org-indent-mode :wk "toggle indentation")
    "r" (list (general-predicate-dispatch 'org-refile
                (bound-and-true-p org-capture-mode) 'org-capture-refile)
              :wk "refile")
    "f" '(config-org-focus-entry :wk "focus entry")

    "u" '(nil :wk "org-roam-ui")
    "u f" '(org-roam-ui-follow-mode :wk "toggle follow")
    "u o" '(org-roam-ui-open :wk "open in browser")
    "u z" '(org-roam-ui-node-zoom :wk "zoom")
    "u l" '(org-roam-ui-node-local :wk "local")

    "c" '(org-clock-display :wk "clock overlays")
    "g" '(org-id-get-create :wk "get/create heading ID")

    "x" '(org-cut-subtree :wk "cut")
    "y" '(org-copy-subtree :wk "copy")
    "p" '(org-paste-subtree :wk "past")
    "n" '(org-num-mode :wk "show heading numbers")
    "o" '(org-tree-to-indirect-buffer :wk "tree to indirect buf")
    "t" '(org-show-todo-tree :wk "todo tree")

    "e" '(nil :wk "babel")
    "e b" '(org-babel-execute-buffer :wk "execute buffer")
    "e c" '(org-babel-tangle-clean :wk "clean")

    "e e" (list (general-predicate-dispatch 'org-babel-execute-subtree
             (org-in-src-block-p) 'org-babel-execute-src-block)
           :wk "execute")
    "e i" '(org-babel-view-src-block-info :wk "src info")

    "e x" '(org-babel-demarcate-block :wk "split block")
    "e v" '(org-babel-mark-block :wk "mark block"))
#+end_src

** Allow ID lookups to work in task files
#+begin_src emacs-lisp
  (use-package org-id
    :config
    (dolist (file (f-files (f-join paths-org-directory "tasks")))
      (add-to-list 'org-id-files file)))

  (use-package org-id
    :after org-roam
    :config
    (dolist (file (f-files org-roam-directory nil t))
      (add-to-list 'org-id-files file)))
#+end_src

** Turn priorities into an on/off flag
I customise priorities so that headlines are either 'prioritised' an show a
cookie or 'cleared', which indicates no special priority.

#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-priority-start-cycle-with-default t)
    (org-highest-priority ?A)
    (org-lowest-priority ?B)
    (org-default-priority ?B))
#+end_src

** Tweak flyspell verification function
#+begin_src emacs-lisp
  (defun config-org-ignore-formulae (result)
    (when result
      (not (equal 'org-formula (get-text-property (point) 'face)))))

  (advice-add #'org-mode-flyspell-verify :filter-return #'config-org-ignore-formulae)
#+end_src

** =org-funcs= - org functions used throughout config
#+begin_src emacs-lisp
  (use-package org-funcs
    :commands
    org-funcs-agenda-dwim
    org-funcs-todo-list
    org-funcs-read-url
    :general
    (:keymaps 'org-mode-map :states '(normal insert emacs)
     "C-c !" 'org-funcs-toggle-priority
     "C-c l" 'org-funcs-insert-url-as-link)
    (:keymaps 'org-agenda-mode-map :states 'motion
     "C-c !" 'org-funcs-agenda-toggle-priority))
#+end_src

** =evil-org= - Improve Evil integration with org-mode
#+begin_src emacs-lisp
  (use-package evil-org
    :hook (org-mode . evil-org-mode)
    :custom
    (evil-org-key-theme '(additional
                          return
                          calendar
                          navigation
                          textobjects
                          todo)))
#+end_src

** =org-capture= - Customise basic capture templates
#+begin_src emacs-lisp
  (use-package org-capture
    :after org-funcs
    :config
    (org-funcs-update-capture-templates '(("c" "Clocking")
                                          ("cn" "Note for currently clocked heading"
                                           plain
                                           (clock)
                                           (function org-funcs-capture-note-to-clocked-heading)
                                           :immediate-finish t))))
#+end_src

** =org-format= - Format document on save
=org-format= provides some commands to clean up the whitespace around
org headings.

#+begin_src emacs-lisp
  (use-package org-format
    :hook (org-mode . org-format-on-save-mode))
#+end_src

** Evil state improvements
Automatically enter insert state when inserting new headings or using
=org-capture=.

#+begin_src emacs-lisp
  (use-package org
    :after evil

    :config
    (defun org-enter-evil-insert-state-for-capture (&rest _)
      (when (and (called-interactively-p nil)
                 (bound-and-true-p org-capture-mode))
        (evil-insert-state)))

    (defun org-enter-evil-insert-state (&rest _)
      (when (called-interactively-p nil)
        (evil-insert-state)))

    (add-hook 'org-log-buffer-setup-hook #'evil-insert-state)
    (advice-add 'org-capture :after #'org-enter-evil-insert-state-for-capture)
    (advice-add 'org-insert-heading :after #'org-enter-evil-insert-state)
    (advice-add 'org-insert-heading-respect-content :after #'org-enter-evil-insert-state)
    (advice-add 'org-insert-todo-heading-respect-content :after #'org-enter-evil-insert-state)
    (advice-add 'org-insert-todo-heading :after #'org-enter-evil-insert-state))
#+end_src

** Visual settings
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-hidden-keywords '(title author))
    (org-cycle-separator-lines 0)
    (org-hide-emphasis-markers t)
    (org-startup-with-latex-preview nil)
    (org-startup-folded 'showall)
    (org-startup-shrink-all-tables t)
    (org-startup-with-inline-images t))
#+end_src

*** Styles
#+begin_src emacs-lisp
  (defconst config-org-style 'sparse)
  (cl-assert (member config-org-style '(compact
                                        sparse)))
#+end_src

**** Style: Compact
#+begin_src emacs-lisp
  (use-package org
    :if (equal config-org-style 'compact)
    :custom
    (org-startup-indented nil))
#+end_src

#+begin_src emacs-lisp
  (use-package org-format
    :if (equal config-org-style 'compact)
    :custom
    (org-format-blank-lines-before-first-heading 1)
    (org-format-blank-lines-before-subheadings 0)
    (org-format-blank-lines-before-level-1-headings 1))
#+end_src

**** Style: Sparse & Indented
#+begin_src emacs-lisp
  (use-package org-format
    :if (equal config-org-style 'sparse)
    :custom
    (org-startup-indented t)
    (org-format-blank-lines-before-first-heading 1)
    (org-format-blank-lines-before-subheadings 1)
    (org-format-blank-lines-before-level-1-headings 1))
#+end_src

**** =org-superstar= - Improve display of headlines
#+begin_src emacs-lisp
  (use-package org-superstar
    :hook (org-mode . org-superstar-mode)
    :custom
    (org-superstar-headline-bullets-list '(?*))
    (org-superstar-leading-bullet ?\s)
    (org-superstar-special-todo-items t)
    (org-superstar-todo-bullet-alist '(("TODO" . #x25cb) ; ○
                                       ("WAIT" . #x25cb) ; ○
                                       ("CANCELLED" . #x25cf) ; ●
                                       ("DONE" . #x25cf))) ; ●
    :config
    (setf (alist-get 45 org-superstar-item-bullet-alist) #x2022)) ; •
#+end_src

*** Use bullet characters for list items
#+begin_src emacs-lisp
  (use-package org
    :config
    (font-lock-add-keywords 'org-mode
                            `((,(rx bol (* space) (group "-") (+ space))
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•")))))))
#+end_src

*** Don't show secondary selection when running ~org-show-todo-tree~
#+begin_src emacs-lisp
  (advice-add #'org-highlight-new-match :override #'ignore)
#+end_src

** Attachments
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-attach-auto-tag nil)
    (org-attach-id-dir (f-join paths-org-directory "data")))
#+end_src

*** Automatically commit attachments to git

#+begin_src emacs-lisp
  (use-package org-attach
    :demand t
    :after org
    :config (require 'org-attach-git)
    :custom
    (org-attach-use-inheritance t))
#+end_src

** Automatically save buffers
Save org buffers automatically after certain operations.
#+begin_src emacs-lisp
  (use-package org
    :config
    (defun org-ad-save-buffers (&rest _)
      (org-save-all-org-buffers))

    (advice-add 'org-archive-subtree :after #'org-ad-save-buffers)
    (advice-add 'org-refile :after #'org-ad-save-buffers))
#+end_src

** Document formatting style
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-M-RET-may-split-line nil)
    (org-adapt-indentation nil)
    (org-blank-before-new-entry '((heading . t) (plain-list-item . auto)))
    (org-catch-invisible-edits 'smart)
    (org-footnote-auto-adjust t)
    (org-insert-heading-respect-content t)
    (org-loop-over-headlines-in-active-region 'start-level))
#+end_src

** Load =org-export= packages
#+begin_src emacs-lisp
  (use-package ox-gfm
    :after org)

  (use-package ox-slack
    :after org)

  (use-package htmlize
    :defer t)
#+end_src

** Todos, checkboxes and statistics
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-checkbox-hierarchical-statistics t)
    (org-checkbox-hierarchical-statistics t)
    (org-enforce-todo-dependencies t)
    (org-hierarchical-todo-statistics nil)
    (org-todo-keywords '((type "TODO(t)" "WAIT(w)" "|" "DONE(d)" "CANCELLED(c@)"))))
#+end_src

Completing all child TODOs will change the parent TODO to DONE.

#+begin_src emacs-lisp
  (use-package org
    :config
    (defun org-set-done-when-all-children-completed (_n-done n-todo)
      (let (org-log-done org-log-states) ; turn off logging
        (org-todo (if (zerop n-todo) "DONE" "TODO"))))

    (add-hook 'org-after-todo-statistics-hook #'org-set-done-when-all-children-completed))
#+end_src

** Refiling
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-outline-path-complete-in-steps nil)
    (org-refile-allow-creating-parent-nodes 'confirm)
    (org-refile-use-outline-path 'file))
#+end_src

Limit refile depth and restrict to specific candidates.

#+begin_src emacs-lisp
  (use-package org
    :config
    (defun org-funcs-refile-candidates ()
      (f-files (f-join org-directory "tasks")
               (lambda (it)
                 (f-ext-p it "org"))))

    (defun org-funcs-refile-verify-function ()
      (let ((keyword (nth 2 (org-heading-components))))
        (not (member keyword org-done-keywords))))

    :custom
    (org-refile-targets '((nil . (:maxlevel . 10)) (org-funcs-refile-candidates . (:maxlevel . 3))))
    (org-refile-target-verify-function 'org-funcs-refile-verify-function))
#+end_src

** Automatically remove deleted files from agenda
#+begin_src emacs-lisp
  (use-package org
    :config
    (defun config-org--always-remove-missing-agenda-files (file)
      (unless (file-exists-p file)
        (org-remove-file file)
        (throw 'nextfile t)))

    (advice-add 'org-check-agenda-file :override #'config-org--always-remove-missing-agenda-files))
#+end_src

** Logging & clocking
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-clock-history-length 20)
    (org-clock-in-resume t)
    (org-clock-into-drawer t)
    (org-clock-out-remove-zero-time-clocks t)
    (org-clock-persist t)
    (org-clock-persist-query-resume nil)
    (org-clock-report-include-clocking-task t)
    (org-clock-mode-line-total 'today)
    (org-log-done 'time)
    (org-log-into-drawer t)
    (org-log-redeadline 'time)
    (org-log-repeat 'time)
    (org-log-reschedule 'time)
    (org-reverse-note-order nil)
    :config
    (org-clock-persistence-insinuate))
#+end_src

Exit minibuffer before adding notes.

#+begin_src emacs-lisp
  (use-package org
    :config
    (defun org-ad-exit-minibuffer (&rest _)
      (when (minibufferp (window-buffer (selected-window)))
        (other-window 1)))

    (advice-add 'org-add-log-note :before #'org-ad-exit-minibuffer))
#+end_src

** =org-archive= - Archiving support for org-mode content
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-archive-location (concat (f-join org-directory "archive.org") "::datetree/"))
    (org-archive-subtree-add-inherited-tags t))
#+end_src

*** Apply either an =@work= or =@personal= context when archiving    :disabled:
#+begin_src emacs-lisp
  (use-package org
    :config
    (defun org-apply-tags-before-archive (&rest _)
      ;; Ensure we have a context before archiving.
      (when (seq-empty-p (org-get-tags))
        (pcase-exhaustive (read-char-choice "Set context: [w]ork  [p]ersonal" '(?w ?p))
          (?w (org-toggle-tag (timekeep-work-tag) 'on))
          (?p nil))))

    (advice-add 'org-archive-subtree :before 'org-apply-tags-before-archive))
#+end_src

** Export
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-export-backends '(ascii html latex odt slack gfm))
    (org-export-with-toc nil)
    (org-html-html5-fancy t)
    (org-html-postamble nil)
    (org-export-exclude-tags '("noexport" "ignore"))
    (org-export-coding-system 'utf-8))
#+end_src

** =org-babel= & =org-src= - Source code support and code blocks
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-src-fontify-natively t)
    (org-src-window-setup 'current-window))
#+end_src

*** Defer language loading as late as possible
#+begin_src emacs-lisp
  (use-package ob
    :custom
    (org-confirm-babel-evaluate nil)
    (org-babel-load-languages '((emacs-lisp . t)
                                (clojure . t)
                                (dot . t)
                                (gnuplot . t)
                                (sql . t)
                                (python . t)
                                (http . t)
                                (calc . t)
                                (shell . t)))
    (org-babel-default-header-args:emacs-lisp '((:lexical . "yes")))
    (org-babel-clojure-backend 'cider)
    (org-babel-python-command (executable-find "python3")))
#+end_src

*** Show images in outputs (useful for GNUplot, etc).
#+begin_src emacs-lisp
  (use-package org
    :config
    (add-hook 'org-babel-after-execute-hook 'org-display-inline-images t))
#+end_src

*** Prevent trailing whitespace from being created in src blocks.
#+begin_src emacs-lisp
  (use-package org
    :config
    (defun org-ad-suppress-final-newline ()
      (setq-local require-final-newline nil))

    (defun org-ad-delete-trailing-space-on-src-block-exit (&rest _)
      (delete-trailing-whitespace))

    (add-hook 'org-src-mode-hook 'org-ad-suppress-final-newline)
    (advice-add 'org-edit-src-exit :before 'org-ad-delete-trailing-space-on-src-block-exit))
#+end_src

** Latex

*** Use Tectonic as org-mode's primary LaTeX compiler
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-latex-compiler (getenv "NIX_EMACS_TEX_PROGRAM"))
    (org-latex-compilers (list (getenv "NIX_EMACS_TEX_PROGRAM")))
    (org-latex-pdf-process (list (concat (getenv "NIX_EMACS_TEX_PROGRAM") " -Z shell-escape --outdir=%o %f"))))
#+end_src

*** Make latex previews look good on high-DPI screens
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-latex-create-formula-image-program 'dvisvgm)
    :config
    (plist-put org-format-latex-options :scale 1.7))
#+end_src

*** Make ~C-c C-c~ toggle LaTeX fragment preview for editing
#+begin_src emacs-lisp
  (use-package org
    :config
    (defun config-org-at-latex-fragment-p ()
      (let ((datum (org-element-context)))
        (and (memq (org-element-type datum) '(latex-environment latex-fragment)))))

    (defun config-org-at-latex-preview-p ()
      (seq-find
       (lambda (ov)
         (eq (overlay-get ov 'org-overlay-type) 'org-latex-overlay))
       (overlays-at (point))))

    (defun config-org-maybe-toggle-latex-fragment ()
      (when (or (config-org-at-latex-preview-p) (config-org-at-latex-fragment-p))
        (org-latex-preview)))

    (add-hook 'org-ctrl-c-ctrl-c-hook #'config-org-maybe-toggle-latex-fragment))
#+end_src

*** Set some default LaTeX packages
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-highlight-latex-and-related '(native script entities))
    :config
    (add-to-list 'org-latex-default-packages-alist '("colorlinks=true" "hyperref" nil)))
#+end_src

*** Don't apply =org-block= face to latex snippets
#+begin_src emacs-lisp
  (use-package org-src
    :after org
    :demand t
    :config
    (add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t))))
#+end_src

*** Make latex fragments adapt to colour theme changes
#+begin_src emacs-lisp
  (use-package org-latex-themed-previews
    :after org
    :demand t
    :custom
    (org-preview-latex-image-directory (f-join paths-cache-directory "org" "latex-previews"))
    :config
    (org-latex-themed-previews-mode +1))
#+end_src

*** =org-fragtog= - Automatically toggle fragment at point
#+begin_src emacs-lisp
  (use-package org-fragtog
    :hook (org-mode . org-fragtog-mode))
#+end_src

** =org-crypt= - Encrypted file content
#+begin_src emacs-lisp
  (use-package org-crypt
    :after org
    :custom
    (org-tags-exclude-from-inheritance '("crypt"))
    (org-crypt-disable-auto-save 'encypt)
    :config
    (with-eval-after-load 'ox
      (push "crypt" org-export-exclude-tags))
    (org-crypt-use-before-save-magic))
#+end_src

** Define context-sensitive key commands
#+begin_src emacs-lisp
  (use-package org
    :general
    (:states '(normal insert) :keymaps 'org-mode-map

     "C-c C-k"
     (general-predicate-dispatch 'org-cut-subtree
       (bound-and-true-p org-capture-mode) 'org-capture-kill
       (string-prefix-p "*Org" (buffer-name)) 'org-kill-note-or-show-branches)

     "C-c RET"
     (general-predicate-dispatch 'org-insert-todo-heading
       (org-at-table-p) 'org-table-hline-and-move)))
#+end_src

** Support mixed text direction in documents
Allow each paragraph to have a different text direction. This is useful for
mixed-direction documents which include English with Arabic, Farsi, etc.

#+begin_src emacs-lisp
  (use-package org
    :config
    (defun org-set-local-vars-and-hooks ()
      (setq-local bidi-paragraph-direction nil))

    (add-hook 'org-mode-hook #'org-set-local-vars-and-hooks))
#+end_src

** Always open directories in Emacs via dired
Ensure we use dired rather than the Finder on macOS.
#+begin_src emacs-lisp
  (use-package org
    :config
    (add-to-list 'org-file-apps '(directory . emacs)))
#+end_src

** =org-agenda= - Calendaring and configurable todo lists
#+begin_src emacs-lisp
  (use-package org-agenda
    :after org
    :custom
    (org-agenda-files (f-join org-directory "org-agenda-files"))
    (org-stuck-projects '("" nil nil ""))
    (org-agenda-todo-ignore-scheduled t)
    (org-agenda-hide-tags-regexp (rx (or "noexport" "someday")))
    (org-agenda-include-diary nil)
    (org-agenda-insert-diary-extract-time t)
    (org-agenda-search-view-always-boolean t)
    (org-agenda-show-all-dates nil)
    (org-agenda-show-inherited-tags nil)
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
    (org-agenda-skip-scheduled-if-done t)
    (org-agenda-span 'day)
    (org-agenda-start-on-weekday nil)
    (org-agenda-window-setup 'only-window)
    (org-agenda-dim-blocked-tasks 'invisible)
    (org-agenda-sorting-strategy '((agenda time-up category-up priority-down todo-state-up)
                                   (todo priority-down category-up scheduled-up)
                                   (tags priority-down category-up)
                                   (search category-up)))
    (org-agenda-clockreport-parameter-plist '(:link t :maxlevel 3 :fileskip0 t))
    (org-agenda-tags-column -100)
    (org-agenda-text-search-extra-files (list (f-join org-directory "archive.org")))
    (org-agenda-use-time-grid nil)

    :general
    (:keymaps 'org-agenda-mode-map :states 'motion
     "/" 'org-agenda-filter
     "?" 'org-agenda-filter-by-tag
     "B" 'org-agenda-bulk-action
     "v" 'org-agenda-view-mode-dispatch
     "t" 'org-agenda-todo
     "J" 'org-agenda-goto-date
     "j" 'org-agenda-next-line
     "k" 'org-agenda-previous-line
     "f" 'org-agenda-later
     "b" 'org-agenda-earlier
     "M-j" 'org-agenda-next-item
     "M-k" 'org-agenda-previous-item
     "M-h" 'org-agenda-earlier
     "M-l" 'org-agenda-later
     "gd" 'org-agenda-toggle-time-grid
     "gr" 'org-agenda-redo
     "M-RET" 'org-agenda-show-and-scroll-up
     "C-f" 'evil-scroll-page-down
     "C-b" 'evil-scroll-page-up
     [remap save-buffer] 'org-save-all-org-buffers
     ;; Restore bindings for search buffers
     "+" 'org-agenda-manipulate-query-add
     "`" 'org-agenda-manipulate-query-add-re
     "-" 'org-agenda-manipulate-query-subtract
     "_" 'org-agenda-manipulate-query-subtract-re))
#+end_src

#+begin_src emacs-lisp
  (mode-leader-set-key :keymaps 'org-agenda-mode-map
    "a" '(org-agenda-archive :wk "archive")
    "r" '(org-agenda-refile :wk "refile"))
#+end_src

*** Define agenda views
Define an agenda view that changes depending on whether I'm clocked in or not
(by invoking =org-funcs-agenda-dwim=). The presence of a running clock means I'm
in a work context.

The todos shown in the agenda are aggressively filtered using skip functions, so
that subtasks are preferred. This is used to model GTD-style /next actions/.
Filtering can be suppressed for a specific tree by setting the =AGENDA_SKIP=
property to =ignore= or =scheduled=.

#+begin_src emacs-lisp
  (use-package org-agenda
    :custom
    (org-agenda-start-with-log-mode '(closed state))
    (org-agenda-span 'day)
    (org-agenda-show-future-repeats nil)
    (org-agenda-ignore-properties '(effort appt))
    (org-agenda-clock-consistency-checks '(:gap-ok-around ("12:20" "12:40" "4:00")
                                           :max-duration "10:00"
                                           :min-duration 0
                                           :max-gap 0))
    (org-agenda-custom-commands
     (let ((views '((tags-todo "TODO=\"TODO\"|+PRIORITY=\"A\""
                               ((org-agenda-overriding-header "Next Actions")
                                (org-agenda-skip-function #'org-funcs-skip-items-already-in-agenda)))
                    (todo "WAIT"
                          ((org-agenda-overriding-header "Delegated")
                           (org-agenda-skip-function #'org-funcs-skip-item-if-timestamp)))
                    (agenda ""
                            ((org-agenda-overriding-header "Today")
                             (org-agenda-use-time-grid t)))
                    (todo "TODO"
                          ((org-agenda-overriding-header "Stuck Projects")
                           (org-agenda-skip-function #'org-project-skip-non-stuck-projects))))))
       `(("p" "personal agenda" ,views
          ((org-agenda-tag-filter-preset '("-someday" "-ignore" "-work" "-outline"))
           (org-agenda-archives-mode t)))
         ("w" "work agenda" ,views
          ((org-agenda-clockreport-mode t)
           (org-agenda-tag-filter-preset (list "-someday" "-ignore" (format "+%s" (timekeep-work-tag))))
           (org-agenda-archives-mode t)))))))
#+end_src

*** Reveal context around item on ~TAB~
#+begin_src emacs-lisp
  (use-package org-agenda
    :config
    (defun config-org--on-show-item-from-agenda ()
      (org-overview)
      (org-reveal)
      (org-show-subtree)
      (org-display-outline-path))

    (add-hook 'org-agenda-after-show-hook #'config-org--on-show-item-from-agenda))
#+end_src

*** Integration with builtin =appt= (appointments)
#+begin_src emacs-lisp
  (use-package org-agenda
    :config
    (add-hook 'org-finalize-agenda-hook 'org-agenda-to-appt))

  (use-package appt
    :custom
    (appt-message-warning-time 60)
    (appt-display-interval 5))
#+end_src

*** Use =page-break-lines= to draw separator
#+begin_src emacs-lisp
  (use-package org-agenda
    :demand t
    :after page-break-lines
    :custom
    (org-agenda-block-separator (char-to-string ?\f))
    :config
    (defun config-org--draw-separator (&rest _)
      (page-break-lines--update-display-tables))

    (advice-add 'org-agenda :after #'config-org--draw-separator)
    (advice-add 'org-agenda-redo :after #'config-org--draw-separator))
#+end_src

*** Make priority inherited
#+begin_src emacs-lisp
  (defun config-org-inherited-priority (s)
    (save-match-data
      (cond
       ((string-match org-priority-regexp s)
        (* 1000 (- org-priority-lowest
                   (org-priority-to-value (match-string 2 s)))))
       ((not (org-up-heading-safe))
        (* 1000 (- org-priority-lowest org-priority-default)))
       (t
        (config-org-inherited-priority (org-get-heading))))))

  (use-package org-agenda
    :custom
    (org-priority-get-priority-function #'config-org-inherited-priority))
#+end_src

*** Search for and update agenda files automatically
Search org files in a couple of blessed locations for open TODOs using [[https://github.com/BurntSushi/ripgrep][ripgrep]].
Populate the agenda with these files.

#+begin_src emacs-lisp
  (let ((process))
    (defun config-org-update-agenda-files-by-rg ()
      (unless (and process (process-live-p process))
        (let ((default-directory org-directory))
          (setq process
                (start-process-shell-command "update-org-agenda-files" nil "rg --files-with-matches '^[*]+ +(TODO|WAIT)' roam tasks -g '!roam/daily' > org-agenda-files"))))))

  (defun config-org-setup-agenda-updates ()
    (when (derived-mode-p 'org-mode)
      (config-org-update-agenda-files-by-rg)))

  (add-hook 'after-save-hook #'config-org-setup-agenda-updates)
#+end_src

** =timekeep= - Better timekeeping handling for org-clock
#+begin_src emacs-lisp
  (use-package timekeep
    :commands
    timekeep-start
    timekeep-stop
    timekeep-find-client-buffer
    timekeep-read-client-name
    :general ("<f12>" (general-predicate-dispatch 'timekeep-start
                        (and (fboundp 'org-clocking-p) (org-clocking-p)) 'timekeep-stop))
    :custom
    (timekeep-cache-file (expand-file-name "timekeep" paths-cache-directory))
    :config
    (timekeep-mode +1)
    (add-hook 'timekeep-agenda-should-update-hook #'org-funcs-agenda-dwim))
#+end_src

** =orgtbl-aggregate= - Add pivot tables to org-mode
#+begin_src emacs-lisp
  (use-package orgtbl-aggregate
    :after (org)
    :demand t)
#+end_src

** =ox-koma-letter= - Export backend for letters via latex
#+begin_src emacs-lisp
  (use-package ox-koma-letter
    :demand t
    :after ox)
#+end_src

** =org-download= - Easily attach images
Attach images to org buffers via GUI drag-and-drop.
#+begin_src emacs-lisp
  (use-package org-download
    :hook (org-mode . org-download-enable)
    :custom
    (org-download-method 'attach)
    (org-download-image-org-width 650)
    :config
    ;; Prevent insertion of download timestamp into buffer.
    (setq org-download-annotate-function (-const ""))
    ;; HACK Redefine to fix throw in org-attach.
    (defun org-download-image (link)
      "Save image at address LINK to `org-download--dir'."
      (interactive "sUrl: ")
      (let* ((link-and-ext (org-download--parse-link link))
             (filename
              (cond ((and (eq major-mode 'org-mode) (eq org-download-method 'attach))
                     (let ((org-download-image-dir (org-attach-dir t))
                           org-download-heading-lvl)
                       (apply #'org-download--fullname link-and-ext)))
                    ((fboundp org-download-method)
                     (funcall org-download-method link))
                    (t
                     (apply #'org-download--fullname link-and-ext)))))
        (setq org-download-path-last-file filename)
        (org-download--image link filename)
        (when (org-download-org-mode-p)
          (when (eq org-download-method 'attach)
            (ignore-errors
              (org-attach-attach filename nil 'none)))
          (org-download-insert-link link filename))
        (when (and (eq org-download-delete-image-after-download t)
                   (not (url-handler-file-remote-p (current-kill 0))))
          (delete-file link delete-by-moving-to-trash)))))
#+end_src

Use =pngpaste= (installed via Homebrew) for inserting screenshots on macOS.

#+begin_src emacs-lisp
  (use-package org-download
    :if (equal system-type 'darwin)
    :custom
    (org-download-screenshot-method "/opt/homebrew/bin/pngpaste %s")
    :general
    (:keymaps 'org-mode-map "s-V" 'org-download-screenshot))
#+end_src

** =org-pretty-table= - use unicode box characters for org tables
#+begin_src emacs-lisp
  (use-package org-pretty-table
    :hook (org-mode . org-pretty-table-mode))
#+end_src

** =org-appear= - automatically reveal hidden org elements at point
This makes it much easier to edit text using emphasis markers correctly.
#+begin_src emacs-lisp
  (use-package org-appear
    :hook (org-mode . org-appear-mode)
    :custom
    (org-appear-autoemphasis t)
    (org-appear-autokeywords t)
    (org-appear-autolinks nil)
    :config
    ;; for proper first-time setup, `org-appear--set-elements'
    ;; needs to be run after other hooks have acted.
    (run-at-time nil nil #'org-appear--set-elements))
#+end_src

** Add a link type for opening manpages
#+begin_src emacs-lisp
  (use-package ol-man
    :after org
    :demand t)
#+end_src

** Add a link type for opening macOS GUI applications
#+begin_src emacs-lisp
  (use-package org
    :config
    (require 'ol)

    (defun org-link-complete-mac-app (&optional arg)
      (cl-labels ((apps-in (dir)
                           (ignore-errors
                             (f-entries dir (lambda (path)
                                              (and (equal (f-ext path) "app")
                                                   (not (string-prefix-p "." (f-filename path)))))))))
        (let ((choices (thread-last (append (apps-in "/Applications")
                                            (apps-in "/System/Applications")
                                            (apps-in "/System/Applications/Utilities")
                                            (apps-in "~/Applications"))
                         (seq-map #'f-base)
                         (seq-uniq)
                         (seq-sort #'string<)))
              (choice (completing-read "Application:" choices)))
          (concat "mac-app:" choice))))

    (defun org-link-follow-mac-app (app-name &optional arg)
      (start-process "open" " open" "open" "-a" app-name))

    (org-link-set-parameters "mac-app"
                             :follow #'org-link-follow-mac-app
                             :complete #'org-link-complete-app))
#+end_src

** Add a link type for playing audio files
#+begin_src emacs-lisp
  (use-package org
    :config
    (require 'cl-lib)
    (require 'dash)
    (require 'ol)
    (require 'vlc-player)

    (defun org-link--parse-audio-link-args (str)
      (cl-labels ((parse-keyword-style (str)
                                       (let ((kvps (split-string str (rx ",") t (rx (any space)))))
                                         (--mapcat (-let [(arg value) (split-string it (rx "=") t (rx (any space)))]
                                                     (pcase arg
                                                       ("start"
                                                        (list :start (string-to-number value)))
                                                       ("end"
                                                        (list :end (string-to-number value)))
                                                       ("length"
                                                        (list :length (string-to-number value)))))
                                                   kvps)))
                  (parse-short-style (str)
                                     (-let [(whole start end length)
                                            (s-match (rx bol
                                                         (* space)
                                                         (group (+ digit) (? "." (+ digit)))
                                                         (? (* space) "-" (* space) (group (+ digit) (? "." (+ digit))))
                                                         (? (* space) "," (* space) (group (+ digit) (? "." (+ digit)))))
                                                     str)]
                                       (list :start (-some->> start (string-to-number))
                                             :end (-some->> end (string-to-number))
                                             :length (-some->> length (string-to-number))))))
        (or (parse-keyword-style str)
            (parse-short-style str))))

    (defun org-link-follow-audio (file-and-args &optional _arg)
      (-let* (((file args) (split-string file-and-args (rx (any ":"))))
              ((parsed-args &as &plist :start :end :length)
               (ignore-errors
                 (org-link--parse-audio-link-args args)))
              (duration (or length
                            (ignore-errors
                              (- end start)))))
        (when (or (and duration (< 10 duration))
                  (null duration))
          (vlc-player))
        (apply #'vlc-player-play-file file parsed-args)))

    (defun org-link-complete-audio-file ()
      (concat "audio:" (abbreviate-file-name (read-file-name "File: "))))

    (org-link-set-parameters "audio"
                             :complete #'org-link-complete-audio-file
                             :follow #'org-link-follow-audio))
#+end_src

** Add a link type for stock tickers
#+begin_src emacs-lisp
  (use-package org
    :config
    (require 'ol)

    (defconst org-link-stock-ticker-rx
      (rx (? "^") (** 1 5 alpha) (? "." (** 1 2 alpha))))

    (defun org-link-follow-stock-ticker (ticker &optional arg)
      (let ((query (url-build-query-string `((t ,ticker)))))
        (browse-url (concat "https://finviz.com/quote.ashx?" query))))

    (defun org-link-complete-stock-ticker ()
      (save-match-data
        (if (thing-at-point-looking-at org-link-stock-ticker-rx)
            (concat "stock:" (upcase (match-string 0)))
          "stock:")))

    (org-link-set-parameters "stock"
                             :complete #'org-link-complete-stock-ticker
                             :follow #'org-link-follow-stock-ticker))
#+end_src

** Add a link type to Elisp libraries
#+begin_src emacs-lisp
  (use-package org
    :config
    (require 'ol)

    (defun org-link-complete-library (&optional arg)
      (concat "library:" (file-name-base (read-library-name))))

    (org-link-set-parameters "library"
                             :follow #'find-library
                             :complete #'org-link-complete-library))
#+end_src

** Keep abbrevs in =org-directory=
#+begin_src emacs-lisp
  (setq abbrev-file-name (f-join paths-org-directory "abbrev.el"))
#+end_src

** =iscroll= - Scroll incrementally over images, instead of jumping
#+begin_src emacs-lisp
  (use-package iscroll
    :hook
    (org-mode . iscroll-mode)
    (markdown-mode . iscroll-mode)
    :general
    (:keymaps 'iscroll-mode-map :states 'normal
     "j" 'iscroll-forward-line
     "k" 'iscroll-previous-line))
#+end_src

** Prevent org-mode from following links in insert state
#+begin_src emacs-lisp
  (use-package org
    :init
    (autoload 'evil-insert-state-p "evil-states")
    (defun config-org-inhibit-org-return-follows-link-for-insert-state (fn &rest args)
      (let ((org-return-follows-link (if (evil-insert-state-p)
                                         nil
                                       org-return-follows-link)))
        (apply fn args)))
    :config
    (advice-add 'org-return :around #'config-org-inhibit-org-return-follows-link-for-insert-state))
#+end_src

* 📓 =org-roam= - Personal wiki & research tooling
#+begin_src emacs-lisp
  (use-package org-roam
    :after org
    :demand t
    :commands
    org-roam-node-find
    org-roam-dailies-goto-today
    org-roam-dailies-capture-today
    org-roam-dailies-goto-yesterday
    org-roam-dailies-goto-date
    org-roam-node-create
    :custom
    (org-roam-directory (f-join paths-org-directory "roam/"))
    (org-roam-v2-ack t)
    (org-roam-verbose nil)
    (org-roam-extract-new-file-path "%<%Y-%m-%d--%H-%M-%S>.org")
    (org-roam-mode-sections '((org-roam-backlinks-section :unique t)
                              (org-roam-reflinks-section)))
    (org-roam-dailies-capture-templates
     '(("d" "default" entry "* %?" :target
        (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d %A>\n#+filetags: :dailies:\n"))))
    :general
    (:states '(insert normal) :keymap 'org-mode-map
     "C-c i" '(org-roam-node-insert :wk "insert org-roam link")
     "C-c TAB" (general-predicate-dispatch 'org-roam-node-insert
                 (org-at-table-p) 'org-ctrl-c-tab))
    :config
    (org-roam-db-autosync-enable))
#+end_src

** Set leader keys
#+begin_src emacs-lisp
  (defun display-backlinks ()
    "Refresh and show the org-roam buffer."
    (interactive)
    (when-let* ((buf (get-buffer org-roam-buffer)))
      (with-current-buffer buf
        (org-roam-buffer-refresh)))
    (org-roam-buffer-toggle))

  (mode-leader-set-key :keymaps 'org-mode-map
    "<tab>" '(display-backlinks :wk "backlinks")
    "<backtab>" '(org-roam-buffer-display-dedicated :wk "backlinks (dedicated)")
    "<" '(org-roam-dailies-find-previous-note :wk "prev daily")
    ">" '(org-roam-dailies-find-next-note :wk "next daily")
    "J" '(org-roam-dailies-goto-date :wk "goto daily...")

    "E" '(org-funcs-roam-extract-subtree :wk "extract subtree to roam file...")

    "i" '(nil :wk "transclusion")
    "i a" '(org-transclusion-add :wk "add")
    "i e" '(org-transclusion-live-sync-start :wk "edit")
    "i o" '(org-transclusion-move-to-source :wk "goto source")
    "i A" '(org-transclusion-add-all :wk "add all")
    "i i" '(org-transclusion-make-from-link :wk "make from link...")
    "i x" '(org-transclusion-remove :wk "remove")
    "i X" '(org-transclusion-remove :wk "remove all")

    "l" '(nil :wk "alias")
    "l a" '(org-roam-alias-add :wk "add alias")
    "l x" '(org-roam-alias-remove :wk "remove alias")

    "k" '(nil :wk "tags")
    "k a" '(org-roam-tag-add :wk "add tag")
    "k x" '(org-roam-tag-remove :wk "remove tag"))

  (mode-leader-set-key :keymaps 'org-roam-mode-map :states '(motion normal)
    "<tab>" '(quit-window :wk "hide")
    "<backtab>" '(org-roam-buffer-display-dedicated :wk "backlinks (dedicated)"))
#+end_src

** Use title for buffer notes identification
#+begin_src emacs-lisp
  (defun config-org-roam-set-buffer-identification ()
    (unless org-inhibit-startup
      (when (and (buffer-file-name) (f-descendant-of-p (buffer-file-name)
                                                       org-roam-directory))
        (when-let* ((title
                     (ignore-errors
                       (save-excursion
                         (goto-char (point-min))
                         (org-roam-node-title (org-roam-node-at-point))))))
          (setq-local mode-line-buffer-identification
                      (propertize title 'face 'mode-line-highlight
                                  'help-echo (buffer-file-name)))))))

  (add-hook 'org-mode-hook #'config-org-roam-set-buffer-identification)
#+end_src

** Open my index file and notes review buffer
#+begin_src emacs-lisp
  (defun initial-buffers ()
    (interactive)
    (let ((inhibit-redisplay t)
          (buf))
      (org-roam-node-visit (org-roam-node-from-id org-roam-index-node-id))
      (setq buf (current-buffer))
      (goto-char (point-min))
      (delete-other-windows)
      (org-roam-review)
      (set-window-dedicated-p (selected-window) t)
      (display-buffer buf)
      buf))

  (setq initial-buffer-choice #'initial-buffers)
#+end_src

** =org-roam-gc= - Automatically clean up empty dailies
#+begin_src emacs-lisp
  (use-package org-roam-gc
    :after org-roam
    :demand t
    :config
    (run-with-idle-timer 2 nil 'org-roam-gc))
#+end_src

** =org-roam-review= - spaced-repetition implementation for org-roam notes
#+begin_src emacs-lisp
  (defun config-org-roam-maybe-set-seedling ()
    (when (string-match-p "/notes/" default-directory)
      (org-roam-review-set-seedling)))

  (use-package org-roam-review
    :hook
    (org-mode . org-roam-note-cache-mode)
    (org-roam-capture-new-node . config-org-roam-maybe-set-seedling)
    :custom
    (org-roam-note-cache-file (f-join paths-cache-directory "org-roam-review"))
    (org-roam-note-ignored-tags '("project" "client"))
    (org-roam-review-show-instructions-p nil)
    (org-roam-review-tags-ignored-for-review-buffer '("dailies" "outline" "author" "accounts" "flat"))
    :general
    (:states '(normal) :keymaps 'org-roam-review-mode-map
     "/" 'org-roam-review-modify-tags
     "TAB" 'magit-section-cycle
     "g r" 'org-roam-review-refresh
     [remap evil-next-line] 'evil-next-visual-line
     [remap evil-previous-line] 'evil-previous-visual-line)
    (:keymaps 'org-mode-map
     "C-c r r" '(org-roam-review-accept :wk "accept")
     "C-c r u" '(org-roam-review-bury :wk "bury")
     "C-c r x" '(org-roam-review-set-excluded :wk "set excluded")
     "C-c r a" '(org-roam-review-set-author :wk "set author")
     "C-c r b" '(org-roam-review-set-budding :wk "set budding")
     "C-c r s" '(org-roam-review-set-seedling :wk "set seedling")
     "C-c r e" '(org-roam-review-set-evergreen :wk "set evergreen")))
#+end_src

** Allow lookups to roam nodes from non-roam org files
#+begin_src emacs-lisp
  (use-package org-roam
    :after org-id
    :config
    (dolist (node (org-roam-node-list))
      (org-id-add-location (org-roam-node-id node)
                           (org-roam-node-file node)))

    (defun config-org-roam--ensure-ids ()
      (add-hook 'after-save-hook
                (lambda ()
                  (when-let* ((id (org-entry-get-with-inheritance "ID"))
                              (file (buffer-file-name)))
                    (org-id-add-location id file)))
                nil t))

    (add-hook 'org-mode-hook #'config-org-roam--ensure-ids))
#+end_src

** Apply a created date property to new nodes
#+begin_src emacs-lisp
  (defun config-org-roam-set-created-timestamp ()
    (org-with-wide-buffer
     (unless (org-entry-get (point) "CREATED")
       (org-set-property "CREATED" (format-time-string (org-time-stamp-format t t))))))

  (add-hook 'org-roam-capture-new-node-hook #'config-org-roam-set-created-timestamp)
#+end_src

** =org-roam-ui= - Web browser interface to org-roam
#+begin_src emacs-lisp
  (use-package org-roam-ui
    :after org-roam
    :custom
    (org-roam-ui-sync-theme t)
    (org-roam-ui-follow t)
    (org-roam-ui-update-on-save t)
    (org-roam-ui-open-on-start t))
#+end_src

*** Keep org-roam-ui in sync as themes change
#+begin_src emacs-lisp
  (use-package org-roam-ui
    :config
    (defun config-update-org-roam-ui-theme (&rest _)
      (when (and (bound-and-true-p org-roam-ui-ws-socket)
                 (websocket-openp org-roam-ui-ws-socket))
        (org-roam-ui-sync-theme)))

    (add-hook 'after-load-theme-functions #'config-update-org-roam-ui-theme))
#+end_src

** =org-transclusion= - share trees across org files
#+begin_src emacs-lisp
  (defun org-transclusion-open-same-window ()
    "Open the transclusion at point"
    (interactive)
    (cond
     ((not (bound-and-true-p org-transclusion-mode))
      (user-error "org-transclusion-mode not active"))
     ((org-transclusion-within-transclusion-p)
      (xref-push-marker-stack)
      (org-transclusion-open-source t))
     (t
      (user-error "Not at a transclusion"))))

  (use-package org-transclusion
    :hook (org-mode . org-transclusion-mode)
    :custom
    (org-transclusion-exclude-elements '(property-drawer keyword))
    :general
    (:keymaps 'org-mode-map :states '(normal)
     "M-." 'org-transclusion-open-same-window)
    (:keymaps 'org-transclusion-map
     "C-c C-e" 'org-transclusion-live-sync-start)
    (:keymaps 'org-transclusion-live-sync-map
     "C-c C-e" 'org-transclusion-live-sync-exit
     [remap save-buffer] 'org-transclusion-live-sync-exit)
    (:keymaps 'org-transclusion-map :states '(motion normal)
     "TAB" 'org-cycle
     [remap evil-org->] 'org-transclusion-demote-subtree
     [remap evil-org-<] 'org-transclusion-promote-subtree)
    :config
    (define-fringe-bitmap 'org-transclusion-fringe-bitmap [224] nil nil '(center repeated)))
#+end_src

*** Don't transclude if org-inhibit-startup is set
#+begin_src emacs-lisp
  (defun config-disable-transclusion-when-inhibited-startup-on (fn &rest args)
    (unless org-inhibit-startup
      (apply fn args)))

  (advice-add 'org-transclusion-add :around #'config-disable-transclusion-when-inhibited-startup-on)
#+end_src

*** =evil-org= compatibility
We want to use =org-transclusion= commands instead of the evil ones where
appropriate. Iterate through the evil-org-mode keymap and apply advice to each
top-level function we find.

There's probably a saner way to do this.

#+begin_src emacs-lisp
  (defun org-transclusion-local-map-passthrough (fn &rest args)
    (if-let* ((local-fn (and (equal (get-text-property (point) 'local-map) org-transclusion-map)
                             (lookup-key org-transclusion-map (char-to-string last-input-event)))))
        (call-interactively local-fn)
      (apply fn args)))

  (use-package org-transclusion
    :after evil-org
    :config
    (dolist (state '(motion normal))
      (let* ((keymap (alist-get 'evil-org-mode (evil-state-minor-mode-keymaps state)))
             (bindings (seq-filter (lambda (it) (and (consp it)
                                                (characterp (car it))
                                                (functionp (cdr it))))
                                   keymap))
             (commands (seq-map #'cdr bindings)))
        (dolist (command commands)
          (advice-add command :around #'org-transclusion-local-map-passthrough)))))
#+end_src

*** Improve transclusion handling with structural editing commands.
When using structural editing commands, I don't want to have to think about whether a headline is a transclusion or not.
#+begin_src emacs-lisp
  (defun config-org-transclusion-strip-subtree (&rest _)
    (when (require 'org-transclusion nil t)
      (org-with-wide-buffer
       (org-narrow-to-subtree)
       (org-transclusion-remove-all t))))

  (defun config-org-transclusion-restore-subtree (&optional _ cut &rest _)
    (when (require 'org-transclusion nil t)
      (unless cut
        (org-with-wide-buffer
         (org-narrow-to-subtree)
         (org-transclusion-add-all t)))))

  (advice-add 'org-copy-subtree :before #'config-org-transclusion-strip-subtree)
  (advice-add 'org-copy-subtree :after #'config-org-transclusion-restore-subtree)
  (advice-add 'org-paste-subtree :after #'config-org-transclusion-restore-subtree)
#+end_src

*** =org-indent= compatibility
Note that the out-of-the-box implementation doesn't appear to work, so set up
the advice manually.

#+begin_src emacs-lisp
  (use-package org-transclusion-indent-mode
    :after org-transclusion
    :demand t
    :config
    (defun config-org-indent-transclusion-compat (fn &rest args)
      (advice-add #'org-indent-set-line-properties
                  :override
                  #'org-transclusion-indent-set-line-properties-ad)
      (apply fn args)
      (advice-remove #'org-indent-set-line-properties
                     #'org-transclusion-indent-set-line-properties-ad))

    (advice-add #'org-indent-add-properties :around
                #'config-org-indent-transclusion-compat))
#+end_src

Additionally, org-indent is totally borked by the source block fringe. Just get
rid of it.

#+begin_src emacs-lisp
  (advice-add 'org-transclusion-propertize-source :around #'ignore)
#+end_src

*** Trim trailing newlines
#+begin_src emacs-lisp
  (defun config-org-transclusion-trim (_ content &rest _)
    (concat (string-trim content) "\n"))

  (with-eval-after-load 'org-transclusion
    (add-to-list 'org-transclusion-content-format-functions
                 #'config-org-transclusion-trim))
#+end_src

*** Teach M-left and M-right to promote & demote
#+begin_src emacs-lisp
  (defun config-org-at-transclusion-keyword-p ()
    (when-let* ((elm (org-element-at-point)))
      (and (string= "keyword" (org-element-type elm))
           (string= "TRANSCLUDE" (org-element-property :key elm)))))

  (defun config-org-transclusion-promote ()
    (when (require 'org-transclusion nil t)
      (cond
       ((org-transclusion-within-transclusion-p)
        (org-transclusion-promote-subtree))
       ((config-org-at-transclusion-keyword-p)
        (org-transclusion-add)))))

  (defun config-org-transclusion-demote ()
    (when (require 'org-transclusion nil t)
      (cond
       ((org-transclusion-within-transclusion-p)
        (org-transclusion-demote-subtree))
       ((config-org-at-transclusion-keyword-p)
        (org-transclusion-add)))))

  (add-hook 'org-metaleft-hook #'config-org-transclusion-promote)
  (add-hook 'org-metaright-hook #'config-org-transclusion-demote)
#+end_src

*** Teach headline reordering and insertion not to error when transclusions are in subtree
#+begin_src emacs-lisp
  (use-package org-transclusion
    :init
    (defun config-org-transclusion-ad-with-transclusions-off (fn &rest args)
      (org-transclusion-remove-all)
      (prog1 (apply fn args)
        (org-transclusion-add-all)))

    :config
    (advice-add #'org-insert-heading :around #'config-org-transclusion-ad-with-transclusions-off)
    (advice-add #'org-metaup :around #'config-org-transclusion-ad-with-transclusions-off)
    (advice-add #'org-metadown :around #'config-org-transclusion-ad-with-transclusions-off))
#+end_src

*** Teach ~C-c C-c~ to refresh
#+begin_src emacs-lisp
  (defun config-org-transclusion-refresh-at-point ()
    (when (org-transclusion-within-transclusion-p)
      (org-transclusion-refresh)
      (message "Refreshed transclusion.")
      t))

  (add-hook 'org-ctrl-c-ctrl-c-hook #'config-org-transclusion-refresh-at-point)
#+end_src

*** Fix indentation after save, refreshing and live sync
#+begin_src emacs-lisp
  (defun config-org-transclusion-apply-indentation (&rest _)
    (when (org-transclusion-within-transclusion-p)
      (when-let* ((start-marker (get-text-property (point) 'org-transclusion-beg-mkr))
                  (end-marker (get-text-property (point) 'org-transclusion-end-mkr)))
        (org-translusion-indent-add-properties (marker-position start-marker)
                                               (marker-position end-marker)))))

  (advice-add 'org-transclusion-refresh :after #'config-org-transclusion-apply-indentation)
  (advice-add 'org-transclusion-live-sync-exit :after #'config-org-transclusion-apply-indentation)
  (advice-add 'org-transclusion-add :after #'config-org-transclusion-apply-indentation)
#+end_src

** Fix buffer promotion function
=org-roam-promote-entire-buffer= will leave stranded content between the top-level
property drawer and the title. Advise it to fix that.

#+begin_src emacs-lisp
  (defun config-org-roam-cleanup-after-promote-entire-buffer (&rest _)
    (save-match-data
      (org-with-wide-buffer
       (goto-char (point-min))
       (when (org-at-property-drawer-p)
         (org-forward-element))
       (unless (thing-at-point-looking-at (rx bol "#+title"))
         (let* ((start (point))
                (end (progn (search-forward-regexp (rx bol "#+title"))
                            (match-beginning 0)))
                (str (buffer-substring start end)))
           (delete-region start end)
           (while (org-at-keyword-p)
             (org-forward-element))
           (newline)
           (insert str))))))

  (advice-add 'org-roam-promote-entire-buffer :after 'config-org-roam-cleanup-after-promote-entire-buffer)
#+end_src

** =org-roam-search= - a search interface that works better with org-roam
#+begin_src emacs-lisp
  (use-package org-roam-search
    :commands (org-roam-search org-roam-search-view)
    :general
    (:keymaps 'org-roam-mode-map :states '(normal motion)
     "s" 'org-roam-search-view))
#+end_src

** =org-roam-links= - show a graph of links for a node
#+begin_src emacs-lisp
  (use-package org-roam-links
    :commands (org-roam-links-view org-roam-links-backlinks-view))
#+end_src

** Customise preview function
- Exclude transcluded headings
- Avoid display of first subheading as preview
#+begin_src emacs-lisp
  (use-package org-roam
    :init
    (defun config-org-roam-preview-function ()
      (let* ((beg-at-heading-p)
             (beg (progn (org-roam-end-of-meta-data t)
                         (when (org-at-heading-p)
                           (setq beg-at-heading-p t))
                         (point)))
             (end (progn (org-next-visible-heading 1)
                         (point))))
        (if beg-at-heading-p
            ""
          (->> (buffer-substring-no-properties beg end)
               (s-lines)
               (seq-filter (lambda (it)
                             (if (string-match-p (rx bol (* space) "#+transclude:") it)
                                 (string-match-p ":only-contents" it)
                               t)))
               (s-join "\n")
               (string-trim)))))
    :custom
    (org-roam-preview-function #'config-org-roam-preview-function))
#+end_src

** Silence transclusion messages
#+begin_src emacs-lisp
  (advice-add 'org-transclusion-add-all :around #'advice-inhibit-logging)
  (advice-add 'org-transclusion-add-all :after #'advice-clear-minibuffer)
#+end_src

** Open links in the current window
#+begin_src emacs-lisp
  (use-package ol
    :config
    (setf (alist-get 'file org-link-frame-setup) 'find-file))
#+end_src

** Define dynamic block types to extend org-roam
#+begin_src emacs-lisp
  (use-package org-roam-dblocks
    :hook (org-mode . org-roam-dblocks-autoupdate-mode))
#+end_src

** Customise the way nodes are displayed when completing
#+begin_src emacs-lisp
  (use-package org-roam
    :custom
    (org-roam-node-display-template
     (concat "${icon:3} " "${title:*}" (propertize "${slipbox:9}" 'face 'org-tag)))
    :config
    (cl-defmethod org-roam-node-slipbox ((node org-roam-node))
      "Return the TYPE of NODE."
      (condition-case nil
          (let ((slipbox (cadr (reverse (f-split (org-roam-node-file node))))))
            (if (or (equal slipbox "roam")
                    (equal slipbox "notes"))
                ""
              slipbox))
        (error "")))

    (cl-defmethod org-roam-node-icon ((node org-roam-node))
      "Return the TYPE of NODE."
      (condition-case nil
          (when-let* ((maturity (car (seq-intersection org-roam-review-maturity-values (org-roam-node-tags node)))))
            (alist-get maturity org-roam-review-maturity-emoji-alist nil nil #'string=))
        (error ""))))
#+end_src

** =org-cite= - Citations support in org-mode
I use Zotero for capturing to my bibliography file, so Emacs is mostly a
consumer of it.

#+begin_src emacs-lisp
  (use-package org
    :general
    (:keymaps 'org-mode-map "C-c b" 'org-cite-insert)
    :config
    (setq org-cite-global-bibliography (list "~/org/org-roam.bib")))
#+end_src

*** =citar= - Citations management UI
#+begin_src emacs-lisp
  (use-package citar
    :custom
    (org-cite-insert-processor 'citar)
    (org-cite-follow-processor 'citar)
    (org-cite-activate-processor 'citar)
    (citar-bibliography org-cite-global-bibliography)
    (citar-symbol-separator "  ")
    :config
    (require 'all-the-icons)
    (setq citar-symbols
          `((file ,(all-the-icons-faicon "file-o" :face 'all-the-icons-green :v-adjust -0.1) . " ")
            (note ,(all-the-icons-material "speaker_notes" :face 'all-the-icons-blue :v-adjust -0.3) . " ")
            (link ,(all-the-icons-octicon "link" :face 'all-the-icons-orange :v-adjust 0.01) . " "))))
#+end_src

*** TODO Evaluate =embark= & =citar-embark=

* Load Lisp from other locations
#+begin_src emacs-lisp
  (use-package org
    :unless noninteractive
    :config
    (when (file-directory-p paths-org-lisp-directory)
      (load (expand-file-name "init.el" paths-org-lisp-directory) t)))

  (use-package ledger-mode
    :unless noninteractive
    :config
    (when (file-directory-p paths-ledger-lisp-directory)
      (load (expand-file-name "init.el" paths-ledger-lisp-directory) t)))
#+end_src

* File postamble
#+begin_src emacs-lisp
  ;; (provide 'config)
  ;;; config.el ends here
#+end_src
