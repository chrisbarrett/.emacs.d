# -*- eval: (add-hook 'after-save-hook #'tangle-init-files nil t); -*-
#+title: Emacs Configuration
#+author: Chris Barrett
#+property: header-args :results silent
#+property: header-args:emacs-lisp :tangle "config.el"
#+startup: fold

* Early Init
:PROPERTIES:
:header-args:emacs-lisp: :tangle "early-init.el"
:END:

#+begin_src emacs-lisp
  ;;; early-init.el -- Run at the beginning of Emacs startup sequence.  -*- lexical-binding: t; buffer-read-only: t; -*-

  ;;; Commentary:

  ;; This file was generated by org-babel from config.org and should not be edited
  ;; directly.

  ;;; Code:
#+end_src

Set an environment variable so child processes can detect that they're inside
Emacs.

#+begin_src emacs-lisp
  (setenv "INSIDE_EMACS" "true")
#+end_src

Crank up the max size of subprocess output to read. This is needed for language
servers to perform well, since they communicate using large chunks of JSON.

#+begin_src emacs-lisp
  (setq read-process-output-max (* 1024 1024))
#+end_src

** Disable package.el

Disable =package.el=, since it increases startup time and I use
[[https://github.com/nix-community/emacs-overlay][nix-community/emacs-overlay]] to handle package installation.

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

** Garbage collection settings

Garbage collection runs slow down the Emacs startup sequence. Temporarily
increase settings. We will set final values at the end of the startup sequence.

#+begin_src emacs-lisp
  (setq gc-cons-threshold most-positive-fixnum)
  (setq gc-cons-percentage 0.7)
#+end_src

** ELN cache path

Override the ELN cache directory so that it's in an XDG-conformant directory.

#+begin_src emacs-lisp
  (when (boundp 'comp-eln-load-path)
    (let ((cache-dir "~/.cache/emacs/eln-cache/"))
      (mkdir cache-dir t)
      (add-to-list 'comp-eln-load-path cache-dir)))
#+end_src

** Apply early display settings

Enable pixel-wise frame resizing so tiling window managers do the right thing.

#+begin_src emacs-lisp
  (setq frame-resize-pixelwise t)
#+end_src

Disable some window chrome that doesn't make sense in a keyboard-driven UI.

#+begin_src emacs-lisp
  (custom-set-variables '(menu-bar-mode nil)
                        '(tool-bar-mode . nil)
                        '(scroll-bar-mode nil))

  (modify-all-frames-parameters '((vertical-scroll-bars)
                                  (name . "Emacs")))
#+end_src


* File header

#+begin_src emacs-lisp
  ;;; config.el -- User init file for Emacs.  -*- lexical-binding: t; buffer-read-only: t; -*-

  ;;; Commentary:

  ;; This file was generated by org-babel from config.org and should not be edited
  ;; directly.

  ;;; Code:
#+end_src

* Startup

** Tune garbage collection

See: [[https://bling.github.io/blog/2016/01/18/why-are-you-changing-gc-cons-threshold/][Why are you changing gc-cons-threshold?]]

#+begin_src emacs-lisp
  (defvar config-default-gc-threshold 800000)

  (defun config--inhibit-gc ()
    (setq gc-cons-threshold most-positive-fixnum))

  (defun config--enable-gc ()
    (setq gc-cons-threshold config-default-gc-threshold))
#+end_src

Restore GC settings after init sequence has completed.

#+begin_src emacs-lisp
  (add-hook 'after-init-hook #'config--enable-gc)
#+end_src

Prevent GCs during user input in the minibuffer.

#+begin_src emacs-lisp
  (add-hook 'minibuffer-setup-hook #'config--inhibit-gc)
  (add-hook 'minibuffer-exit-hook #'config--enable-gc)
#+end_src

** Set initial theme settings

Set reasonable placeholder foreground and background colours until the theme is
loaded. Use the current GNOME theme to determine whether to use light or dark colours.

#+begin_src emacs-lisp
  (when (eq system-type 'gnu/linux)
    (let ((gtk-theme (with-temp-buffer
                       (ignore-errors
                         (call-process "gsettings" nil t nil
                                       "get" "org.gnome.desktop.interface" "gtk-theme"))
                       (buffer-string))))
      (set-background-color (if (string-match-p "dark" gtk-theme) "#282c34" "#FDF6E3"))
      (set-foreground-color (if (string-match-p "dark" gtk-theme) "#bbc2cf" "#556b72"))))
#+end_src

** Configure =use-package=

=use-package= provides a structured DSL for Lisp package configuration.

See: [[https://github.com/jwiegley/use-package][jwiegley/use-package]]

#+begin_src emacs-lisp
  (with-no-warnings
    (setq use-package-always-defer t)
    (setq use-package-minimum-reported-time 0.05)
    (setq use-package-compute-statistics t)
    (setq use-package-verbose (not noninteractive)))

  (eval-when-compile
    (require 'use-package))
  #+end_src

Enable =general=, which provides a key-binding DSL supported by =use-package=.

See: [[https://github.com/noctuid/general.el][noctuid/general.el]]

#+begin_src emacs-lisp
  (use-package general
    :demand t)
#+end_src

** Load features used often in config

#+begin_src emacs-lisp
  (require 'dash)
  (require 'f)
  (require 'subr-x)
#+end_src

Load =cl= early to avoid warnings caused by reorganised functions in Emacs 27+.

#+begin_src emacs-lisp
  (with-no-warnings
    (require 'cl))
#+end_src

** Configure paths and config layout

#+begin_src emacs-lisp
  (require 'paths (expand-file-name "paths.el" user-emacs-directory))
  (paths-initialise)
#+end_src

Load themes from =.emacs.d/themes=.

#+begin_src emacs-lisp
  (setq custom-theme-directory (concat paths-themes-directory "/"))
#+end_src

*** Configure =no-littering= to use these paths

Customises many packages to create a cleaner =.emacs.d= layout.

See: [[https://github.com/emacscollective/no-littering][emacscollective/no-littering]]

#+begin_src emacs-lisp
  (use-package no-littering
    :demand t
    :custom
    ((no-littering-etc-directory paths-etc-directory)
     (no-littering-var-directory paths-cache-directory)))
#+end_src

Teach =recentf= to use these paths

#+begin_src emacs-lisp
  (use-package recentf
    :after (no-littering)
    :config
    (progn
      (add-to-list 'recentf-exclude no-littering-etc-directory)
      (add-to-list 'recentf-exclude no-littering-var-directory)))
#+end_src

** Load Lisp files from certain other directories

Load host-specific settings, which are not checked into version control.

#+begin_src emacs-lisp
  (when (file-exists-p paths-hostfile)
    (load-file paths-hostfile))
#+end_src

Load lisp in =org= and =ledger= dirs.

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (when (file-directory-p paths-org-lisp-directory)
      (load (expand-file-name "init.el" paths-org-lisp-directory) t)))

  (when (file-directory-p paths-ledger-lisp-directory)
    (load (expand-file-name "init.el" paths-ledger-lisp-directory) t))
#+end_src

* Common advice

#+begin_src emacs-lisp
  (defun advice-ignore-errors (f &rest args)
    (ignore-errors
      (apply f args)))
#+end_src

* Utility functions

#+begin_src emacs-lisp
  (defun face-ancestors (face)
    "List all faces that FACE transitively inherits from."
    (let (result)
      (while (and face (not (equal face 'unspecified)))
        (setq result (cons face result))
        (setq face (face-attribute face :inherit)))
      (nreverse result)))
#+end_src


#+begin_src emacs-lisp
  (defun bounds-of-surrounding-lines (lines-before lines-after)
    (let ((start
           (save-excursion
             (ignore-errors
               (forward-line (- lines-before)))
             (line-beginning-position)))
          (end
           (save-excursion
             (ignore-errors
               (forward-line lines-after))
             (line-end-position))))
      (list start end)))
#+end_src


* Customise builtin features

Set C source directory to use the source files from the Nix build.

#+begin_src emacs-lisp
  (use-package find-func
    :custom
    ((find-function-C-source-directory (getenv "NIX_EMACS_SRC_DIR"))))
#+end_src

Always use one-char =y-or-n-p=.

#+begin_src emacs-lisp
  (defalias #'yes-or-no-p #'y-or-n-p)
#+end_src

Don't use the system trash can.

#+begin_src emacs-lisp
  (setq delete-by-moving-to-trash nil)
#+end_src

Do not truncate the results of =eval-expression= and friends when logging their
output with =message=.

#+begin_src emacs-lisp
  (setq eval-expression-print-length nil)
  (setq eval-expression-print-level nil)
#+end_src

Use 'Emacs', rather than the selected buffer, as the window manager's title for
frames.

#+begin_src emacs-lisp
  (setq frame-title-format "Emacs")
#+end_src

Instantly display current keystrokes in mini buffer

#+begin_src emacs-lisp
 (setq echo-keystrokes 0.02)
#+end_src

Save cookies to a cache file.

#+begin_src emacs-lisp
  (use-package url
    :custom
    ((url-cookie-file (expand-file-name "cookies" paths-cache-directory))))
#+end_src

Prefer more recent Lisp files to outdated ELC files when loading.

#+begin_src emacs-lisp
  (setq load-prefer-newer t)
#+end_src


Do not query the user to accept insecure connections. Just disconnect them.

#+begin_src emacs-lisp
  (use-package nsm
    :custom
    ((nsm-noninteractive t)))
#+end_src

** Enable useful commands

#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'erase-buffer 'disabled nil)
#+end_src

** General file & buffer settings

Always insert a final newline, as per the Unix convention.

#+begin_src emacs-lisp
  (setq require-final-newline t)
#+end_src

Make scripts executable (using =chmod=) after save.

#+begin_src emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+end_src

Set default indentation settings.

#+begin_src emacs-lisp
  (setq-default fill-column 80)
  (setq-default indent-tabs-mode nil)
#+end_src

Don't require two spaces to signal the end of a sentence--I don't use
sentence-based commands that often anyway.

#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src

Don't nag when trying to create a new file or buffer.

#+begin_src emacs-lisp
  (setq confirm-nonexistent-file-or-buffer nil)
#+end_src

Do not show =^M= chars in files containing mixed UNIX and DOS line endings.

#+begin_src emacs-lisp
  (defun config--hide-dos-eol ()
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))

  (add-hook 'after-change-major-mode-hook #'config--hide-dos-eol)
#+end_src

** Whitespace handling

Insert a leading space after comment start for new comment lines.

#+begin_src emacs-lisp
  (autoload 'thing-at-point-looking-at "thingatpt")

  (defun config--comment-insert-space (&rest _)
    (when (and comment-start
               (thing-at-point-looking-at (regexp-quote comment-start)))
      (unless (or (thing-at-point-looking-at (rx (+ space))))
        (just-one-space))))

  (advice-add #'comment-indent-new-line :after #'config--comment-insert-space)
#+end_src

Bind some simple key commands.

#+begin_src emacs-lisp
  (use-package simple
    :general ("M-SPC" #'cycle-spacing))
#+end_src

** File encoding

Use UTF-8 everywhere by default.

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-language-environment 'utf-8)
#+end_src

** Disable unwanted features

Don't show the default startup screen.

#+begin_src emacs-lisp
  (setq initial-scratch-message nil)
  (setq inhibit-startup-message t)
  (setq initial-major-mode 'fundamental-mode)
#+end_src

Disable cursor blinking--I find it distracting.

#+begin_src emacs-lisp
  (blink-cursor-mode -1)
#+end_src

Never show the useless hello file.

#+begin_src emacs-lisp
  (defalias #'view-hello-file #'ignore)
#+end_src


Unset 2-window scrolling shortcuts.

#+begin_src emacs-lisp
  (global-unset-key (kbd "<f2>"))
  (global-unset-key (kbd "S-<f2>"))
#+end_src

Disable audible bell.

#+begin_src emacs-lisp
  (setq ring-bell-function #'ignore)
#+end_src


Don't pollute directories with lockfiles, since I only run one instance of Emacs
and never need to prevent concurrent file access.

#+begin_src emacs-lisp
  (setq create-lockfiles nil)
#+end_src

Don't nag when following symlinks to files under version control.

#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
#+end_src

Don't try to ping things that look like domain names

#+begin_src emacs-lisp
  (use-package ffap
    :custom
    ((ffap-machine-p-known 'reject)))
#+end_src

Disable warnings from obsolete advice system, since these are generally not
actionable.

#+begin_src emacs-lisp
  (setq ad-redefinition-action 'accept)
#+end_src

Don't confirm before killing subprocesses on exit.

#+begin_src emacs-lisp
  (setq confirm-kill-processes nil)

  (defun config--suppress-no-process-prompt (fn &rest args)
    (cl-labels ((process-list () nil))
      (apply fn args)))

  (advice-add #'save-buffers-kill-emacs :around #'config--suppress-no-process-prompt)
#+end_src

** ANSI colour code support

Process ANSI color codes in shell output.

#+begin_src emacs-lisp
  (autoload 'ansi-color-apply-on-region "ansi-color")

  (defun config--display-ansi-codes (buf &rest _)
    (and (bufferp buf)
         (string= (buffer-name buf) "*Shell Command Output*")
         (with-current-buffer buf
           (ansi-color-apply-on-region (point-min) (point-max)))))

  (advice-add #'display-message-or-buffer :before #'config--display-ansi-codes)
#+end_src

** Minibuffer settings

Keep a longer history by default.

#+begin_src emacs-lisp
  (setq history-length 1000)
#+end_src

Hide files with boring extensions from find-file

#+begin_src emacs-lisp
  (defun config--ff-hide-boring-files-in-completion (result)
    "Filter RESULT using `completion-ignored-extensions'."
    (if (and (listp result) (stringp (car result)) (cdr result))
        (let ((matches-boring (rx-to-string `(and (or "."
                                                      ".."
                                                      ".DS_Store"
                                                      "__pycache__/"
                                                      ".cache/"
                                                      ".ensime_cache/"
                                                      ,@completion-ignored-extensions)
                                                  eos))))
          (seq-remove (lambda (it)
                        (and (stringp it) (string-match-p matches-boring it)))
                      result))
      result))

  (advice-add #'completion--file-name-table :filter-return #'config--ff-hide-boring-files-in-completion)
#+end_src

Remove lingering =*completions*= buffer whenever we exit the minibuffer.

#+begin_src emacs-lisp
  (defun config--cleanup-completions-buffer ()
    (when-let* ((buf (get-buffer "*Completions*")))
      (kill-buffer buf)))

  (add-hook 'minibuffer-exit-hook #'config--cleanup-completions-buffer)
#+end_src

** Backup settings

Emacs will automatically keep backups of unsaved files a you edit, which helps
with crash recovery.

#+begin_src emacs-lisp
  (setq make-backup-files nil)
  ;; (setq kept-new-versions 6)
  ;; (setq delete-old-versions t)
  ;; (setq version-control t)
#+end_src

Create autosave files inside the XDG cache directory.

#+begin_src emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,(expand-file-name "auto-save" paths-cache-directory) t)))
#+end_src

** Write custom settings to a separate file

Keep custom settings in a separate file. This keeps =init.el= clean.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))

  (when (file-exists-p custom-file)
    (load custom-file nil t))
#+end_src

** Copy-paste & clipboard settings

Share the Emacs kill ring with the host OS clipboard.

#+begin_src emacs-lisp
  (setq select-enable-clipboard t)
  (setq save-interprogram-paste-before-kill t)
#+end_src

Prevent duplicated entries in the kill ring.

#+begin_src emacs-lisp
  (setq kill-do-not-save-duplicates t)
#+end_src

Clean up whitespace when inserting yanked text.

#+begin_src emacs-lisp
  (defun config--yank-ws-cleanup (&rest _)
    (whitespace-cleanup)
    (delete-trailing-whitespace))

  (advice-add #'insert-for-yank :after #'config--yank-ws-cleanup)
#+end_src

** Smooth scrolling

Anchor the cursor to the top or bottom of the window during scrolling, rather
than paginating through the buffer.

#+begin_src emacs-lisp
  (setq scroll-preserve-screen-position t)
  (setq scroll-conservatively 101)
#+end_src

** Comint

#+begin_src emacs-lisp
  (use-package comint
    :custom
    ((comint-prompt-read-only t)))
#+end_src

** Help

Always focus on help windows.

#+begin_src emacs-lisp
  (setq help-window-select t)
#+end_src

Don't show 'press q to close' message.

#+begin_src emacs-lisp
  (advice-add 'help-window-display-message :override #'ignore)
#+end_src

Customise how help buffers should be displayed.

#+begin_src emacs-lisp
  (add-to-list 'display-buffer-alist
               `(,(rx bos "*Help*" eos)
                 (display-buffer-reuse-window display-buffer-in-side-window)
                 (side            . right)
                 (window-width    . 80)))
#+end_src

=apropos= searches for symbols matching a pattern. Extend it to search more kinds
of symbols.

#+begin_src emacs-lisp
  (use-package apropos
    :custom
    ((apropos-do-all t)))
#+end_src

** State persistence

=saveplace= persists the last location visited in a buffer.

#+begin_src emacs-lisp
  (use-package saveplace
    :demand t
    :config (save-place-mode +1))
#+end_src

=savehist= saves the minibuffer history across sessions.

#+begin_src emacs-lisp
  (use-package savehist
    :demand t
    :config (savehist-mode +1)
    :custom
    ((savehist-additional-variables '(kill-ring
                                      compile-command
                                      search-ring
                                      regexp-search-ring))))
#+end_src

** Bidirectional text editing

Configure Emacs so that each paragraph may have a difference text direction.

#+begin_src emacs-lisp
  (setq-default bidi-paragraph-separate-re "^")
  (setq-default bidi-paragraph-start-re "^")
#+end_src

** =display-buffer= settings

Prevent display-buffer from displaying in new frames.

#+begin_src emacs-lisp
  (defun config--display-buffer-fallback (buffer &rest _)
    (when-let* ((win (split-window-sensibly)))
      (with-selected-window win
        (switch-to-buffer buffer)
        (help-window-setup (selected-window))))
    t)

  (setq display-buffer-fallback-action
        '((display-buffer--maybe-same-window
           display-buffer-reuse-window
           display-buffer-pop-up-window
           display-buffer-in-previous-window
           display-buffer-use-some-window
           config--display-buffer-fallback)))
#+end_src

** Large file support

#+begin_src emacs-lisp
  (defconst config--large-file-allowed-extensions
    '("pdf" "png" "jpg" "jpeg"))

  (defun config--dont-abort-if-allowed-extension (f &rest args)
    (-let [(_size _op filename) args]
      (unless (--any-p (f-ext-p filename it) config--large-file-allowed-extensions)
        (apply f args))))

  (advice-add #'abort-if-file-too-large :around #'config--dont-abort-if-allowed-extension)
#+end_src

** Recent files

Increase the number of saved files.

#+begin_src emacs-lisp
  (with-eval-after-load 'recentf
    (setq recentf-max-saved-items 100))
#+end_src

Teach =recentf= which files to exclude.

#+begin_src emacs-lisp
  (use-package recentf
    :custom
    ((recentf-exclude '(config-recentf--boring-filename-p
                        config-recentf--boring-extension-p
                        file-remote-p
                        config-recentf--sudo-file-p
                        config-recentf--child-of-boring-relative-dir-p
                        config-recentf--child-of-boring-abs-dir-p)))
    :preface
    (progn
      (defun config-recentf--boring-filename-p (f)
        (memq (f-filename f) '("TAGS" ".DS_Store")))

      (defun config-recentf--boring-extension-p (f)
        (seq-intersection (f-ext f) '("gz" "zip" "tar")))

      (defun config-recentf--sudo-file-p (f)
        (string-prefix-p "/sudo:root@" f))

      (defun config-recentf--child-of-boring-relative-dir-p (f)
        (string-match-p (rx "/"
                            (or
                             ".cargo"
                             ".ensime_cache"
                             ".g8"
                             ".git"
                             ".stack-work"
                             "Maildir"
                             "build"
                             "dist"
                             "flow-typed/npm"
                             "target"
                             "vendor"
                             )
                            "/")
                        f))

      (defconst config-recentf--abs-dirs
        (seq-map (lambda (it) (f-slash (file-truename it)))
                 (list "/var/folders/"
                       "/usr/local/Cellar/"
                       "/tmp/"
                       "/nix/store/"
                       paths-cache-directory
                       paths-etc-directory)))

      (defun config-recentf--child-of-boring-abs-dir-p (f)
        (let ((ignore-case (eq system-type 'darwin)))
          (seq-find (lambda (d)
                      (or
                       (string-prefix-p d f ignore-case)
                       (string-prefix-p d (file-truename f) ignore-case)))
                    config-recentf--abs-dirs)))))
#+end_src

** Multilingual input support

Set up LaTeX-style input method and add extra MULE rules for common chars.

#+begin_src emacs-lisp
  (use-package mule
    :custom
    ((default-input-method "TeX"))

    :preface
    (progn
      (defvar quail-current-package)

      (defun config-mule--set-tex-method-vars ()
        (when-let* ((quail-current-package (assoc "TeX" quail-package-alist)))
          (quail-defrule ";" (quail-lookup-key "\\"))
          (quail-define-rules ((append . t))
                              ("\\null" ?∅)
                              ("\\rarr" ?→)
                              ("\\larr" ?←)
                              ("\\lr" ?↔)
                              ("\\lam" ?λ)
                              ("\\Lam" ?Λ)
                              ("\\all" ?∀)
                              ("\\rtack" ?⊢)))))
    :config
    (add-hook 'input-method-activate-hook #'config-mule--set-tex-method-vars))
#+end_src

** auto-revert changed files

Automatically revert buffers if the underlying file changes on disk.

#+begin_src emacs-lisp
  (use-package autorevert
    :hook (after-init . global-auto-revert-mode)
    :custom
    ((auto-revert-verbose nil)))
#+end_src

** Clickable URLs

=goto-addr= turns URLs and mailto links into clickable buttons.

#+begin_src emacs-lisp
  (use-package goto-addr
    :hook (prog-mode . goto-address-prog-mode))
#+end_src

** Built-in HTML rendering

#+begin_src emacs-lisp
  (use-package shr
    :config
    ;; Undefine key that prevents forward-word in evil
    (define-key shr-map (kbd "w") nil))
#+end_src


** Code folding

=hideshow= provides basic code folding. It can sometimes throw annoying errors, so
use advice to ignore these.

#+begin_src emacs-lisp
  (use-package hideshow
    :config
    (progn
      (advice-add 'hs-hide-all :around #'advice-ignore-errors)
      (advice-add 'hs-hide-block :around 'advice-ignore-errors)
      (advice-add 'hs-minor-mode :around #'advice-ignore-errors)
      (advice-add 'hs-show-all :around #'advice-ignore-errors)
      (advice-add 'hs-show-block :around #'advice-ignore-errors)
      (advice-add 'hs-toggle-hiding :around #'advice-ignore-errors)))
#+end_src


** Enable authinfo file support

#+begin_src emacs-lisp
  (use-package auth-source
    :custom ((auth-sources '("~/.authinfo.gpg"))))
#+end_src

** Pixel-wise scrolling

#+begin_src emacs-lisp
  (use-package pixel-scroll
    :demand t
    :config (pixel-scroll-mode +1))
#+end_src

** Manpages

#+begin_src emacs-lisp
  (use-package man
    :general (:keymaps 'Man-mode-map
              "M-n" #'Man-next-section
              "M-p" #'Man-previous-section))
#+end_src

** Spellchecking

#+begin_src emacs-lisp
  (use-package ispell
    :defer t
    :custom
    ((ispell-program-name "aspell")
     (ispell-dictionary "en_GB")
     (ispell-silently-savep t))

    :commands (ispell-check-version
               ispell-find-aspell-dictionaries)
    :config
    (progn
      (ispell-check-version)
      (setq ispell-dictionary-alist (ispell-find-aspell-dictionaries))))
#+end_src

** Info system

Emacs and many packages provide manuals in the =info= format. Configure this
system below.

#+begin_src emacs-lisp
  (use-package info
    :general
    (:states 'normal :keymaps 'Info-mode-map
     "C-n" 'Info-forward-node
     "C-p" 'Info-backward-node))
#+end_src

=info+= adds lots of extra functionality, like bookmarking, etc.

#+begin_src emacs-lisp
  (use-package info+
    :after (info)
    :demand t
    :custom ((Info-fontify-angle-bracketed-flag nil)))
#+end_src

** Image viewing

#+begin_src emacs-lisp
  (use-package image
    :general (:keymaps 'image-mode-map :states '(normal motion)
              "-" #'image-decrease-size
              "+" #'image-increase-size))
#+end_src

** Jumping to common websites

=webjump= provides an interface for quickly performing web searches and jumping to
websites.

#+begin_src emacs-lisp
  (use-package webjump
    :commands (webjump)
    :custom (webjump-sites
             '(("DuckDuckGo" . [simple-query "duckduckgo.com" "duckduckgo.com/?q=" ""])
               ("Google Calendar" . "calendar.google.com")
               ("GMail" . "mail.google.com")
               ("home-manager options" . "https://rycee.gitlab.io/home-manager/options.html")
               ("Emacs Subreddit" . "reddit.com/r/emacs")
               ("NixOS Options" . [simple-query "nixos.org" "nixos.org/nixos/options.html#" ""])
               ("NixOS Packages" . [simple-query "nixos.org" "nixos.org/nixos/packages.html?query=" ""])
               ("Wikipedia" . [simple-query "en.wikipedia.org" "en.wikipedia.org/wiki/" ""]))))
#+end_src

* Better eval-expression

Define an alternative version of =eval-expression= that uses =emacs-lisp-mode= to
provide font-locking, and handles =smartparens= better.

See: [[https://lists.gnu.org/archive/html/help-gnu-emacs/2014-07/msg00135.html][Re: How properly utilize the minibuffer and inactive minibuffer startup]]

#+begin_src emacs-lisp
  (defvar config-eval-expression-map
    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map read-expression-map)
      (define-key map (kbd "<escape>") #'minibuffer-keyboard-quit)
      (define-key map (kbd "C-g") #'minibuffer-keyboard-quit)
      map))

  (defun config-eval-expression--read (prompt &optional initial-contents)
    (let ((minibuffer-completing-symbol t))
      (minibuffer-with-setup-hook
          (lambda ()
            (emacs-lisp-mode)
            (use-local-map config-eval-expression-map)
            (setq font-lock-mode t)
            (funcall font-lock-function 1))
        (read-from-minibuffer prompt initial-contents
                              config-eval-expression-map nil
                              'read-expression-history))))

  (autoload 'pp-display-expression "pp")
  (autoload 'pp-to-string "pp")

  (defun config-eval-expression (expression &optional arg)
    "Like `eval-expression' with nicer input handling.

  - Use `emacs-lisp-mode' to provide font locking and better
    integration with other packages.

  - Use the `pp' library to display the output in a readable form.

  EXPRESSION is a Lisp form to evaluate.

  With optional prefix ARG, insert the results into the buffer at
  point."
    (interactive (list (read (config-eval-expression--read "Eval: "))
                       current-prefix-arg))
    (if arg
        (insert (pp-to-string (eval expression lexical-binding)))
      (pp-display-expression (eval expression lexical-binding)
                             "*Pp Eval Output*")))
#+end_src

Use this command for evaluating expressions in the Lisp debugger too.

#+begin_src emacs-lisp
  (use-package debug
    :config
    (advice-add 'debugger-record-expression
                :around
                (lambda (f exp)
                  (interactive (list (read (config-eval-expression--read "Eval: "))))
                  (funcall f exp))
                '((name . use-config-eval-expression--read))))
#+end_src

* Improve basic editing configuration for all modes

** Code folding

Enable hideshow in all programming buffers.

#+begin_src emacs-lisp
  (use-package hideshow
    :hook (prog-mode . hs-minor-mode))
#+end_src

** Line transposition

Use control key to transpose lines up and down.

#+begin_src emacs-lisp
  (autoload 'org-move-item-down "org-list")
  (autoload 'org-move-item-up "org-list")

  (defun transpose-line-up ()
    "Move the current line up."
    (interactive)
    (if (derived-mode-p 'org-mode)
        (org-move-item-up)

      (transpose-lines 1)
      (forward-line -2)
      (indent-according-to-mode)))

  (defun transpose-line-down ()
    "Move the current line up."
    (interactive)
    (if (derived-mode-p 'org-mode)
        (org-move-item-down)

      (forward-line 1)
      (transpose-lines 1)
      (forward-line -1)
      (indent-according-to-mode)))

  (global-set-key (kbd "C-<up>") #'transpose-line-up)
  (global-set-key (kbd "C-<down>") #'transpose-line-down)
#+end_src


** Useful interactive functions

#+begin_src emacs-lisp
  (defun insert-uuid ()
    "Insert a UUID at point."
    (interactive "*")
    (insert (string-trim (shell-command-to-string "uuidgen"))))
#+end_src

#+begin_src emacs-lisp
  (defun insert-date (str)
    "Read date string STR interactively and insert it at point."
    (interactive (list
                  (if (not current-prefix-arg)
                      (format-time-string "%F")
                    (let ((formats (seq-map #'format-time-string
                                            '("%F"
                                              "%F %R"
                                              "%X"
                                              "%c"))))
                      (completing-read "Format: " formats nil t)))))
    (insert str))
#+end_src

Define a command for reversing the characters in the current region.

#+begin_src emacs-lisp
  (defun config-reverse-characters (beg end)
    "Reverse the characters in the region from BEG to END.
  Interactively, reverse the characters in the current region."
    (interactive "*r")
    (insert
     (reverse
      (delete-and-extract-region
       beg end))))

  (eval-and-compile
    (unless (fboundp 'reverse-characters)
      (defalias 'reverse-characters 'config-reverse-characters)))
#+end_src

** Indentation

Automatically indent when inserting newlines.

#+begin_src emacs-lisp
  (general-define-key :keymaps '(text-mode-map prog-mode-map)
    "RET" #'comment-indent-new-line)
#+end_src

Define a command to indent every line in the buffer. This should really be a
thing out-of-the-box.

#+begin_src emacs-lisp
  (defun indent-buffer ()
    "Indent the entire buffer."
    (interactive "*")
    (save-excursion
      (delete-trailing-whitespace)
      (indent-region (point-min) (point-max) nil)
      (untabify (point-min) (point-max))))
#+end_src

Define a command to perform indentation in a context-sensitive way.

#+begin_src emacs-lisp
  (autoload 'lsp-format-region "lsp-mode")
  (autoload 'lsp-format-buffer "lsp-mode")

  (defun config-indent-dwim (&optional justify)
    "Indent the thing at point.

  Knows how to fill strings and comments, or indent code.

  Optional arg JUSTIFY will justify comments and strings."
    (interactive "*P")
    (-let [(_ _ _ string-p comment-p) (syntax-ppss)]
      (cond
       (string-p
        (let ((progress (make-progress-reporter "Filling paragraph")))
          (fill-paragraph justify)
          (progress-reporter-done progress)))
       (comment-p
        (let ((progress (make-progress-reporter "Filling comment")))
          (fill-comment-paragraph justify)
          (progress-reporter-done progress)))

       ((region-active-p)
        (if (bound-and-true-p lsp-mode)
            (lsp-format-region (region-beginning) (region-end))
          (indent-region (region-beginning) (region-end))))
       (t
        (let ((progress (make-progress-reporter "Indenting buffer")))
          (if (bound-and-true-p lsp-mode)
              (lsp-format-buffer)
            (indent-buffer))
          (progress-reporter-done progress))))))

  (define-key prog-mode-map (kbd "M-q") #'config-indent-dwim)
#+end_src

** Aggressive indentation                                         :disabled:

=aggressive-indent= automatically reindents code during editing.

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :hook (prog-mode . (lambda () (require 'aggressive-indent)))
    :custom
    ((aggressive-indent-excluded-modes
      '(csharp-mode
        diff-auto-refine-mode
        dockerfile-mode
        fstar-mode
        graphviz-dot-mode
        haskell-mode
        haskell-cabal-mode
        idris-mode
        idris-repl-mode
        inf-ruby-mode
        java-mode
        lua-mode
        makefile-gmake-mode
        makefile-mode
        nix-mode
        python-mode
        restclient-mode
        rust-mode
        scala-mode
        sql-mode
        stylus-mode
        terraform-mode
        text-mode
        toml-mode
        yaml-mode)))

    :preface
    (defun turn-off-aggressive-indent-mode ()
      (when (fboundp 'aggressive-indent-mode)
        (aggressive-indent-mode -1)))

    :config
    (progn
      (advice-add 'aggressive-indent--indent-if-changed :around #'advice-ignore-errors)
      (add-hook 'diff-auto-refine-mode-hook #'turn-off-aggressive-indent-mode)
      (global-aggressive-indent-mode +1)))
#+end_src

** Automatic whitespace cleanup

=ws-butler= cleans up trailing whitespace as you edit.

#+begin_src emacs-lisp
  (use-package ws-butler
    :hook ((prog-mode . (lambda () (require 'ws-butler)))
           (text-mode . (lambda () (require 'ws-butler))))
    :config
    (ws-butler-global-mode))
#+end_src

** Paragraph fill

=unfill= provides a command that is the opposite of fill-paragraph.

#+begin_src emacs-lisp
  (use-package unfill
    :commands (unfill-region unfill-paragraph unfill-toggle))
#+end_src

** Alignment

=align= provides useful functions for aligning text.

#+begin_src emacs-lisp
  (use-package align
    :general ("C-x a a" #'align-regexp))
#+end_src

** Comment hiding

=hide-comnt= provides a command for toggling whether comments are visible.

#+begin_src emacs-lisp
  (use-package hide-comnt
    :commands (hide/show-comments-toggle))
#+end_src

** Basic jump-to-definition support

=dump-jump= provides a good fallback for navigating to definitions in the absence
of an LSP or semantic analysis.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :general (:states 'normal :keymaps 'prog-mode-map "M-." #'jump-to-definition)
    :custom
    ((dumb-jump-selector 'ivy)))
#+end_src

** File templates

=autoinsert= provides file templates.

#+begin_src emacs-lisp
  (use-package autoinsert
    :preface
    (defvar auto-insert-alist nil)
    :hook (find-file . auto-insert)
    :custom
    ((auto-insert-query nil)))
#+end_src

Extend =auto-insert= to use the more intuitive =yasnippet= DSL.

#+begin_src emacs-lisp
  (use-package autoinsert-files
    :after (autoinsert)
    :commands (autoinsert-files-populate-templates)
    :preface
    (progn
      ;; Use yasnippet's `snippet-mode' for autoinsert templates
      (autoload 'snippet-mode "yasnippet")

      (defun config-autoinsert--maybe-snippet-mode ()
        (require 'autoinsert)
        (when (string-prefix-p auto-insert-directory (buffer-file-name))
          (snippet-mode))))
    :init
    (add-hook 'find-file-hook #'config-autoinsert--maybe-snippet-mode)
    :config
    (advice-add 'auto-insert :before (lambda (&rest _)
                                       (autoinsert-files-populate-templates))))
#+end_src

** Spellchecking

=flyspell= provides spellchecking.

#+begin_src emacs-lisp
  (use-package flyspell
    :hook
    ((org-mode . flyspell-mode))
    :custom
    ((flyspell-issue-welcome-flag nil)
     (flyspell-default-dictionary "en_GB")))
#+end_src

Prevent =flyspell= from showing suggestions in more contexts.

#+begin_src emacs-lisp
  (use-package flyspell
    :after (org)
    :preface
    (defun config-flyspell--on-org-verify (result)
      (and result
           (not (seq-intersection (face-at-point nil t)
                                  '(org-link verb-header)))))
    :config
    (advice-add 'org-mode-flyspell-verify :filter-return #'config-flyspell--on-org-verify))
#+end_src


** Undo history

This package provides a visual representation of the undo history.

#+begin_src emacs-lisp
  (use-package undo-tree
    :hook (org-mode . undo-tree-mode)
    :general
    ("C-x t" 'undo-tree-visualize)
    (:states 'normal :keymaps 'org-mode-map
     "C-r" 'undo-tree-redo
     "u" 'undo-tree-undo))
#+end_src

* Integration with external tooling

** =direnv= support

Teach Emacs how to load environment variables from [[https://direnv.net/][direnv]].

See: [[https://github.com/wbolster/emacs-direnv][wbolster/emacs-direnv]]

#+begin_src emacs-lisp
  (use-package direnv
    :hook (after-init . direnv-mode)
    :custom
    ((direnv-always-show-summary nil)))
#+end_src

** =editorconfig= support

Teach Emacs to respect editorconfig files.

#+begin_src emacs-lisp
  (use-package editorconfig
    :hook (after-init . editorconfig-mode))
#+end_src

* Basic programming language modes

** Configuration files

Configure =conf-mode= for use with more kinds of config files.

#+begin_src emacs-lisp
  (use-package conf-mode
    :mode
    (("\\.env\\.erb\\'" . conf-mode)
     ("\\.conf\\.erb\\'" . conf-mode)
     ("\\.kll\\'" . conf-mode)))
#+end_src

** Hex editing

=hexl= is Emacs' built-in hex editor.

#+begin_src emacs-lisp
  (use-package hexl
    :general
    (:states 'motion :keymaps 'hexl-mode-map
     "]]" #'hexl-end-of-1k-page
     "[[" #'hexl-beginning-of-1k-page
     "h" #'hexl-backward-char
     "l" #'hexl-forward-char
     "j" #'hexl-next-line
     "k" #'hexl-previous-line
     "$" #'hexl-end-of-line
     "^" #'hexl-beginning-of-line
     "0" #'hexl-beginning-of-line))
#+end_src


* Searching

** Ripgrep (=rg=)

=deadgrep= provides a polished frontend for =ripgrep=.

#+begin_src emacs-lisp
  (use-package deadgrep
    :commands (deadgrep)
    :general (:keymaps 'deadgrep-mode-map "C-c C-w" #'deadgrep-edit-mode)
    :init
    (defalias 'rg #'deadgrep)
    :config
    (setq-default deadgrep--search-type 'regexp))
#+end_src

Use =c= in the =deadgrep= buffer to change the search term.

#+begin_src emacs-lisp
  (use-package deadgrep
    :preface
    (defun config-deadgrep--requery ()
      (interactive)
      (let ((button (save-excursion
                      (goto-char (point-min))
                      (forward-button 1))))
        (button-activate button)))
    :general (:states 'normal :keymaps 'deadgrep-mode-map
              "c" #'config-deadgrep--requery))
#+end_src

Provide feedback in the echo area on entering and exiting =deadgrep-edit-mode=.

#+begin_src emacs-lisp
  (use-package deadgrep
    :preface
    (progn
      (defun config-deadgrep--on-exit-edit-mode (&rest _)
        (when (derived-mode-p 'deadgrep-edit-mode)
          (let ((message-log-max))
            (message "Exiting edit mode."))))

      (defun config-deadgrep--on-enter-edit-mode (&rest _)
        (let ((message-log-max))
          (message "Entering edit mode. Changes will be made to underlying files as you edit."))))
    :config
    (progn
      (advice-add 'deadgrep-mode :before #'config-deadgrep--on-exit-edit-mode)
      (advice-add 'deadgrep-edit-mode :after #'config-deadgrep--on-enter-edit-mode)))
#+end_src

Use =C-c C-e= to enter a =deadgrep= search buffer from =ivy.=

#+begin_src emacs-lisp
  (use-package deadgrep
    :after (ivy)
    :general
    (:keymaps 'counsel-ag-map "C-c C-e" #'deadgrep-from-ivy)
    :preface
    (progn
      (autoload 'ivy-exit-with-action "ivy")

      (defun deadgrep-from-ivy ()
        (interactive)
        (ivy-exit-with-action
         (lambda (&rest _)
           (let ((deadgrep--search-type 'regexp))
             (deadgrep (replace-regexp-in-string (rx (+ space)) ".*?"
                                                 (with-no-warnings ivy-text)))))))))
#+end_src

** Grep

Enable =wgrep=, which provides editable grep buffers.

#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src

* Prompts and UI

** Ivy

=ivy= is a package that provides incremental completion, similar to =helm= or =ido=,
but actively maintained. =flx= is used as the fuzzy-matching indexer backend for
ivy.

#+begin_src emacs-lisp
  (use-package ivy
    :general
    ("C-c C-r" #'ivy-resume
     "C-x b" #'ivy-switch-buffer)

    (:keymaps 'ivy-occur-mode-map
     "C-x C-w" #'ivy-wgrep-change-to-wgrep-mode)

    (:keymaps 'ivy-minibuffer-map
     "C-z" #'ivy-dispatching-done
     "C-l" #'ivy-partial-or-done
     "C-<return>" #'ivy-immediate-done
     "M-<return>" #'ivy-immediate-done
     "<escape>" 'minibuffer-keyboard-quit)

    ;; Browse read-expression histroy with ivy
    (:keymaps 'read-expression-map
     "C-r" #'counsel-minibuffer-history)

    :commands (ivy-completing-read)

    :custom
    ((completing-read-function 'ivy-completing-read)
     (ivy-use-virtual-buffers t)
     (ivy-virtual-abbreviate 'abbreviate)
     (ivy-count-format "(%d/%d) ")
     (ivy-re-builders-alist '((t . ivy--regex-plus)))
     (ivy-magic-slash-non-match-action nil)
     (ivy-height 20)
     (ivy-extra-directories '("."))

     ;; Increase the maximum number of candidates that will be sorted
     ;; using `flx'. The default is 200, which means `flx' is almost
     ;; never used. Setting it too high (e.g. 10000) causes lag. This
     ;; seems to be a good compromise (for example, @PythonNut uses it,
     ;; see [1]).
     ;;
     ;; [1]: https://github.com/PythonNut/emacs-config/blob/c8bff5cce293006ec5cdc39a86982431a758a9a0/modules/config-ivy.el#L68
     (ivy-flx-limit 2000))

    :config
    (progn
      (advice-add 'ivy--queue-exhibit :around #'advice-ignore-errors)
      (ivy-mode)))
#+end_src

*** Hide boring files from completions

Hide =./= and =../= when finding files.

#+begin_src emacs-lisp
  (use-package ivy
    :preface
    (defun config-ivy-with-empty-ivy-extra-directories (f &rest args)
      (let ((ivy-extra-directories nil))
        (apply f args)))
    :config
    (advice-add #'counsel-find-file :around #'config-ivy-with-empty-ivy-extra-directories))
#+end_src

** In-buffer search

=swiper= is a buffer search interface using =ivy=.

#+begin_src emacs-lisp
  (use-package swiper
    :general (:states 'normal "/" 'swiper))
#+end_src

** Improve completion throughout Emacs using Counsel

=counsel= provides replacements for core Emacs commands using =ivy=.

#+begin_src emacs-lisp
  (use-package counsel
    :general
    ("M-x" #'counsel-M-x "C-x C-f" #'counsel-find-file)
    (:keymaps 'counsel-find-file-map
     "C-M-j" #'ivy-immediate-done
     "C-h" #'counsel-up-directory)
    :custom ((counsel-yank-pop-separator (concat "\n" (make-vector 120 ?─) "\n")))
    :config
    (progn
      (put 'counsel-find-symbol 'no-counsel-M-x t)
      (setf (alist-get 'counsel-yank-pop ivy-height-alist) 20)
      (counsel-mode +1)))
#+end_src

** Persistent history

=historian= remembers your choices in completion menus.

#+begin_src emacs-lisp
  (use-package historian
    :after (ivy)
    :demand t
    :config (historian-mode +1))
#+end_src

=ivy-historian= integrates =historian= with =ivy=.

#+begin_src emacs-lisp
  (use-package ivy-historian
    :after (ivy)
    :demand t
    :custom
    ;; Tweak historian weighting settings. These values are chosen
    ;; subjectively to produce good results.
    ((ivy-historian-freq-boost-factor 2000)
     (ivy-historian-recent-boost 2000)
     (ivy-historian-recent-decrement 1000))
    :config
    (ivy-historian-mode 1))
#+end_src

* Ediff

Configure how =ediff= should display windows when started.

#+begin_src emacs-lisp
  (use-package ediff
    :custom
    ((ediff-window-setup-function #'ediff-setup-windows-plain)
     (ediff-split-window-function #'split-window-horizontally)))
#+end_src

Teach =ediff= how to copy contents from both buffers in a three-way merge.

#+begin_src emacs-lisp
  (use-package ediff
    :functions
    (ediff-setup-windows-plain ediff-copy-diff ediff-get-region-contents)
    :preface
    (progn
      (defun ediff-copy-both-to-C ()
        "Copy both ediff buffers in a 3-way merge to the target buffer."
        (interactive)
        (let ((str
               (concat
                (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
          (ediff-copy-diff ediff-current-difference nil 'C nil str)))

      (defun config-ediff--setup-keybinds ()
        (define-key ediff-mode-map (kbd "B") #'ediff-copy-both-to-C)))
    :config
    (add-hook 'ediff-keymap-setup-hook #'config-ediff--setup-keybinds))
#+end_src

Reveal the context around the selected hunk when diffing org buffers.

#+begin_src emacs-lisp
    (use-package ediff
      :preface
      (progn
        (autoload 'org-reveal "org")

        (defun config-ediff--org-reveal-around-difference (&rest _)
          (dolist (buf (list ediff-buffer-A ediff-buffer-B ediff-buffer-C))
            (when (and buf (buffer-live-p buf))
              (with-current-buffer buf
                (when (derived-mode-p 'org-mode)
                  (org-reveal t)))))))
      :config
      (progn
        (advice-add 'ediff-next-difference :after #'config-ediff--org-reveal-around-difference)
        (advice-add 'ediff-previous-difference :after #'config-ediff--org-reveal-around-difference)))
#+end_src

* World clock

=world-time-mode= provides a world clock.

#+begin_src emacs-lisp
  (use-package world-time-mode
    :commands (world-time-list)
    :general
    (:states 'normal :keymaps 'world-time-table-mode-map "q" 'quit-window)
    :custom
    ((display-time-world-list '(("Pacific/Auckland" "NZT")
                                ("America/Los_Angeles" "Pacific Time")
                                ("Europe/Istanbul" "Turkey")
                                ("Asia/Beirut" "Lebanon")
                                ("Europe/Berlin" "Euro Central")
                                ("UTC" "UTC"))))
    :config
    (add-hook 'world-time-table-mode-hook 'hl-line-mode))
#+end_src

* Compilation

#+begin_src emacs-lisp
  (use-package compile
    :custom
    ((compilation-environment '("TERM=screen-256color"))
     (compilation-always-kill t)
     (compilation-ask-about-save nil)
     (compilation-scroll-output 'first-error)))
#+end_src

Colourise compilation output.

#+begin_src emacs-lisp
  (use-package compile
    :preface
    (progn
      (autoload 'ansi-color-apply-on-region "ansi-color")

      (defvar compilation-filter-start)

      (defun config-basic-settings--colorize-compilation-buffer ()
        (let ((inhibit-read-only t))
          (ansi-color-apply-on-region (save-excursion
                                        (goto-char compilation-filter-start)
                                        (line-beginning-position))
                                      (point))))

      (defface compilation-base-face nil
        "Base face for compilation highlights"
        :group 'config-basic-settings))

    :config
    (progn
      (add-hook 'compilation-filter-hook #'config-basic-settings--colorize-compilation-buffer)

      (add-to-list 'display-buffer-alist
                   `(,(rx bos "*compilation*" eos)
                     (display-buffer-reuse-window display-buffer-below-selected)
                     (window-height    . 0.2)))

      ;; Clear default underline text properties applied to compilation highlights.
      (setq compilation-message-face 'compilation-base-face)))
#+end_src

Position compilation buffers.

#+begin_src emacs-lisp
  (use-package compile
    :config
    (add-to-list 'display-buffer-alist
                 `(,(rx bos "*compilation*" eos)
                   (display-buffer-reuse-window display-buffer-below-selected)
                   (window-height    . 0.2))))
#+end_src

Clear default underline text properties applied to compilation highlights.

#+begin_src emacs-lisp
  (use-package compile
    :custom
    ((compilation-message-face 'compilation-base-face)))
#+end_src

* Window management

** Window state history

=winner-mode= saves the window and buffer layout history, allowing you to cycle
forward and back through layout states. This is useful for recovering a layout
after editing actions have changed what windows are shown.

#+begin_src emacs-lisp
  (use-package winner
    :general ("<C-left>" 'winner-undo
              "<C-right>"'winner-redo)
    :hook (after-init . winner-mode)
    :custom
    ((winner-boring-buffers '("*Completions*"
                              "*Compile-Log*"
                              "*inferior-lisp*"
                              "*Fuzzy Completions*"
                              "*Apropos*"
                              "*Help*"
                              "*cvs*"
                              "*Buffer List*"
                              "*Ibuffer*"
                              "*esh command on file*"))))
#+end_src

** Layouts

=rotate= provides handy commands for manipulating the window layout.

#+begin_src emacs-lisp
  (use-package rotate
    :commands (rotate-layout))
#+end_src


* Modal editing & Evil

=evil= provides Vim emulation.

=evil= provides macros that I want to use in =:config= blocks, so teach the
byte-compiler about them to avoid warnings.

#+begin_src emacs-lisp
  (cl-eval-when (compile)
    (require 'evil))
#+end_src

Customise global vars and keybindings.

#+begin_src emacs-lisp
  (use-package evil
    :hook (after-init . evil-mode)
    :preface
    (autoload 'display-warning "warnings")
    :custom
    ((evil-mode-line-format nil)
     (evil-shift-width 2)
     (evil-symbol-word-search t)
     (evil-want-visual-char-semi-exclusive t)
     (evil-want-Y-yank-to-eol t)
     (evil-motion-state-cursor '("plum3" box))
     (evil-visual-state-cursor '("gray" hbar))
     (evil-normal-state-cursor '("IndianRed" box))
     (evil-insert-state-cursor '("chartreuse3" bar))
     (evil-emacs-state-cursor  '("SkyBlue2" (box . t))))
    :general
    (:states 'normal "go" #'browse-url-at-point))
#+end_src

Prevent visual state from updating the clipboard.

#+begin_src emacs-lisp
  (advice-add 'evil-visual-update-x-selection :override #'ignore)
#+end_src

Don't load =evil-keybinds.el=.

#+begin_src emacs-lisp
  (defvar evil-want-keybinding nil)
#+end_src

Use =Q= in normal state to execute the macro bound to =q= register. This is a
convenient way to quickly define a macro, then execute it immediately--just
double-tap =q= to record, then hit =Q= to execute.

#+begin_src emacs-lisp
  (use-package evil
    :general (:states 'normal "Q" #'config-evil--execute-Q-macro)
    :preface
    (defun config-evil--execute-Q-macro (count)
      "Execute the macro bound to the Q register.

  COUNT is the number of repetitions."
      (interactive (list
                    (if current-prefix-arg
                        (if (numberp current-prefix-arg) current-prefix-arg 0)
                      1)))
      (evil-execute-macro count (evil-get-register ?Q t))))
#+end_src

Make motions make more sense in RTL languages.

#+begin_src emacs-lisp
  (use-package evil-bidi
    :after (evil)
    :demand t)
#+end_src

** Customise navigation in help buffers

#+begin_src emacs-lisp
  (use-package evil
    :config
    (evil-define-key 'motion help-mode-map
      (kbd "<escape>") #'quit-window
      (kbd "^") #'help-go-back
      (kbd "gh") #'help-follow-symbol))
#+end_src


** Initial states

Customise which states evil to use for different modes.

#+begin_src emacs-lisp
  (use-package evil
    :config
    (progn
      (evil-set-initial-state 'anaconda-mode-view-mode 'motion)
      (evil-set-initial-state 'diff-mode 'motion)
      (evil-set-initial-state 'ert-simple-view-mode 'motion)
      (evil-set-initial-state 'eshell-mode 'insert)
      (evil-set-initial-state 'flycheck-error-list-mode 'motion)
      (evil-set-initial-state 'grep-mode 'normal)
      (evil-set-initial-state 'haskell-debug-mode 'motion)
      (evil-set-initial-state 'helpful-mode 'motion)
      (evil-set-initial-state 'ibuffer-mode 'motion)
      (evil-set-initial-state 'nix-repl-mode 'insert)
      (evil-set-initial-state 'occur-mode 'normal)
      (evil-set-initial-state 'org-agenda-mode 'motion)
      (evil-set-initial-state 'prodigy-mode 'motion)
      (evil-set-initial-state 'profiler-report-mode 'motion)
      (evil-set-initial-state 'racer-help-mode 'motion)
      (evil-set-initial-state 'tabulated-list-mode 'motion)
      (evil-set-initial-state 'vterm-mode 'emacs)
      (evil-set-initial-state 'wdired-mode 'normal)

      (with-eval-after-load 'replace
        (evil-add-hjkl-bindings occur-mode-map))))
#+end_src

** Archive navigation integration

#+begin_src emacs-lisp
  (use-package evil
    :after (tar-mode)
    :config
    (progn
      (evil-set-initial-state 'tar-mode 'emacs)
      (evil-add-hjkl-bindings tar-mode-map)))
#+end_src

#+begin_src emacs-lisp
  (use-package evil
    :after (arc-mode)
    :general
    (:states 'motion :keymaps 'archive-mode-map
     "q" 'kill-this-buffer
     "o" 'archive-extract-other-window
     "m" 'archive-mark
     "x" 'archive-expunge
     "U" 'archive-unmark-all-files
     "j" 'archive-next-line
     "k" 'archive-previous-line
     "<return>" 'archive-extract)
    :config
    (evil-set-initial-state 'archive-mode 'emacs))
#+end_src

** =compilation= integration

Disable =h= (help) binding in =compilation-mode=, which interferes with evil
navigation.

#+begin_src emacs-lisp
  (use-package evil
    :general (:states 'motion :keymaps 'compilation-mode-map
              "h" #'evil-backward-char))
#+end_src

** =hydra= integration

=evil= breaks cursor settings when combined with hydra. To work around this, never
show the cursor in deselected windows.

#+begin_src emacs-lisp
  (setq-default cursor-in-non-selected-windows nil)
#+end_src

** Spellchecker integration

Add vim-style =:spell= and =:nospell= ex commands.

#+begin_src emacs-lisp
  (use-package evil
    :functions (evil-ex-define-cmd)
    :preface
    (progn
      (defun config-evil-flyspell-on ()
        "Enable flyspell."
        (interactive)
        (turn-on-flyspell))

      (defun config-evil-flyspell-off ()
        "Disable flyspell."
        (interactive)
        (turn-off-flyspell)))
    :config
    (progn
      (evil-ex-define-cmd "nospell" #'config-evil-flyspell-off)
      (evil-ex-define-cmd "spell" #'config-evil-flyspell-on)))
#+end_src

Add more key bindings to work with spell-checker from normal state.

#+begin_src emacs-lisp
  (use-package evil-ispell
    :after evil
    :general (:states 'normal
              "z SPC" #'flyspell-auto-correct-word
              "zU" #'evil-ispell-correct-word
              "zg" #'evil-ispell-mark-word-as-good
              "zG" #'evil-ispell-mark-word-as-locally-good
              "zn" #'evil-ispell-next-spelling-error
              "zp" #'evil-ispell-previous-spelling-error))
#+end_src


** Use escape key as =keyboard-quit=

Make =<escape>= issue =keyboard-quit= in as many situations as possible.

#+begin_src emacs-lisp
  (define-key minibuffer-local-map (kbd "<escape>") #'keyboard-escape-quit)
  (define-key minibuffer-local-ns-map (kbd "<escape>") #'keyboard-escape-quit)
  (define-key minibuffer-local-completion-map (kbd "<escape>") #'keyboard-escape-quit)
  (define-key minibuffer-local-must-match-map (kbd "<escape>") #'keyboard-escape-quit)
  (define-key minibuffer-local-isearch-map (kbd "<escape>") #'keyboard-escape-quit)
#+end_src

** =smartparens= integration

Scanning for matched pairs in org buffers can lead to poor performance when
deleting characters. Advise the evil delete command to just search for matched
pairs within the surrounding few lines.

#+begin_src emacs-lisp
  (use-package evil
    :after (smartparens)
    :preface
    (defun config-evil--sp-delete-and-join-compat (fn &rest args)
      (cond
       ;; Narrow before deleting to improve performance in large org buffers.
       ((and (bound-and-true-p smartparens-strict-mode)
             (derived-mode-p 'org-mode))
        (save-restriction
          (apply #'narrow-to-region (bounds-of-surrounding-lines 5 5))
          (call-interactively 'sp-backward-delete-char)))

       ((bound-and-true-p smartparens-strict-mode)
        (call-interactively 'sp-backward-delete-char))

       (t
        (apply fn args))))
    :config
    (advice-add 'evil-delete-backward-char-and-join :around #'config-evil--sp-delete-and-join-compat))
#+end_src

** =org-mode= integration

Teach =evil= how to navigate using links in org buffers and the agenda.

#+begin_src emacs-lisp
  (use-package link-hint
    :after (evil)
    :config
    (put 'link-hint-org-link :vars '(org-mode org-agenda-mode)))
#+end_src

** Surrounding selections

Teach =evil= how to surround objects with matched pairs.

#+begin_src emacs-lisp
  (use-package evil-surround
    :after (evil)
    :demand t
    :config (global-evil-surround-mode +1)
    :general
    (:states 'visual :keymaps 'evil-surround-mode-map
     "s" #'evil-surround-region
     "S" #'evil-substitute)
    :custom
    ((evil-surround-pairs-alist '((?\( . ("(" . ")"))
                                  (?\[ . ("[" . "]"))
                                  (?\{ . ("{" . "}"))

                                  (?\) . ("(" . ")"))
                                  (?\] . ("[" . "]"))
                                  (?\} . ("{" . "}"))

                                  (?# . ("#{" . "}"))
                                  (?b . ("(" . ")"))
                                  (?B . ("{" . "}"))
                                  (?> . ("<" . ">"))
                                  (?t . evil-surround-read-tag)
                                  (?< . evil-surround-read-tag)
                                  (?f . evil-surround-function)))))
#+end_src

Define an extra =`sym'= pair for =emacs-lisp-mode=.

#+begin_src emacs-lisp
  (use-package evil-surround
    :after (evil)
    :preface
    (defun config-evil--init-evil-surround-pairs ()
      (make-local-variable 'evil-surround-pairs-alist)
      (push '(?\` . ("`" . "'")) evil-surround-pairs-alist))
    :hook
    (emacs-lisp-mode-hook . config-evil--init-evil-surround-pairs))
#+end_src

** Community-maintained bindings

=evil-collection= provides a community-managed set of keybindings for many modes.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after (evil)
    :demand t)
#+end_src

** text motions within function parameter lists

=evil-args= provides text motions within function parameter lists, so you can
manipulate parameters in a structured way.

#+begin_src emacs-lisp
  (use-package evil-args
    :after (evil)
    :general (:keymaps
              'evil-inner-text-objects-map "a" #'evil-inner-arg
              :keymaps
              'evil-outer-text-objects-map "a" #'evil-outer-arg))
#+end_src

** improve matched-pair detection

Teach =%= how to match more kinds of pairs.

#+begin_src emacs-lisp
  (use-package evil-matchit
    :after (evil)
    :demand t
    :config
    (global-evil-matchit-mode +1))
#+end_src

** operate on numbers

Use =+= and =-= to increment and decrement numbers in normal state.

#+begin_src emacs-lisp
  (use-package evil-numbers
    :after (evil)
    :demand t
    :general (:states 'normal
              "+" #'evil-numbers/inc-at-pt
              "-" #'evil-numbers/dec-at-pt))
#+end_src

** improve shift behaviour

Teach =<= and =>= to shift text in a context-sensitive way.

#+begin_src emacs-lisp
  (use-package evil
    :general (:states 'visual
              "<" #'config-evil--shift-left
              ">" #'config-evil--shift-right)
    :preface
    (progn
      (defun config-evil--shift-left (&optional beg end)
        "Shift left, keeping the region active.

  BEG and END are the bounds of the active region."
        (interactive "r")
        (evil-shift-left beg end)
        (evil-normal-state)
        (evil-visual-restore))

      (defun config-evil--shift-right (&optional beg end)
        "Shift right, keeping the region active.

  BEG and END are the bounds of the active region."
        (interactive "r")
        (evil-shift-right beg end)
        (evil-normal-state)
        (evil-visual-restore))))
#+end_src

** iedit integration

=iedit= adds useful mass-renaming functionality. This package provides evil
compatibility.

#+begin_src emacs-lisp
  (use-package evil-iedit-state
    :commands (evil-iedit-state/iedit-mode)
    :config
    (define-obsolete-function-alias 'iedit-cleanup 'iedit-lib-cleanup))
#+end_src


* Text completion engines

** =hippie-expand=

=hippie-expand= is a generic completion engine that works in most buffers without
any special language-level support.

Use =hippie-expand= as the default completion command for evil.

#+begin_src emacs-lisp
  (use-package hippie-exp
    :general ("M-/" 'hippie-expand
              :states 'insert
              [remap evil-complete-previous] 'hippie-expand))
#+end_src


Set the default heuristic for completing symbols.

#+begin_src emacs-lisp
  (use-package hippie-exp
    :custom
    ((hippie-expand-try-functions-list
      '(try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))))
#+end_src

** =company=

=company= is a general-purpose completion frontend, showing a popup of completion
options.

#+begin_src emacs-lisp
  (use-package company
    :hook (after-init . global-company-mode)

    :general
    ([remap completion-at-point] #'company-manual-begin
     [remap complete-symbol] #'company-manual-begin)
    (:states '(insert normal emacs) :keymaps 'company-active-map
     "S-<return>" #'company-complete
     "<return>" #'company-complete-selection)
    (:keymaps 'comint-mode-map [remap indent-for-tab-command] #'company-manual-begin)

    :preface
    (general-unbind :keymaps 'company-active-map "C-w" "C-h")

    :custom
    ((company-idle-delay 0.3)
     (company-minimum-prefix-length 3)
     (company-tooltip-align-annotations t)
     (company-require-match nil))

    :config
    (require 'company-tng))
#+end_src

=evil-collection-company= seems to be messing with the =<return>= binding, so I need
to manually apply it again.

#+begin_src emacs-lisp
  (use-package company
    :after evil-collection
    :preface
    (defun config-company--set-company-vars ()
      (define-key company-active-map (kbd "RET") #'company-complete-selection))
    :config
    (add-hook 'company-mode-hook #'config-company--set-company-vars))
#+end_src

* Filesystem browsing

=dired= is the builtin filesystem browser for Emacs.

#+begin_src emacs-lisp
  (use-package dired
    :general
    (:states 'normal :keymaps 'dired-mode-map "$" #'end-of-line)
    :custom
    ((dired-listing-switches "-alhv")
     (dired-dwim-target t)
     (dired-auto-revert-buffer t)
     (dired-hide-details-hide-symlink-targets nil)
     (dired-omit-files (rx bol (or (+ ".")
                                   (and "__pycache__" eol)))))
    :config
    (progn
      (add-hook 'dired-mode-hook #'hl-line-mode)
      (put 'dired-find-alternate-file 'disabled nil)))
#+end_src

Teach =dired= to put directories first in sort order.

#+begin_src emacs-lisp
  (use-package dired
    :preface
    (defun config-dired--sort-directories-first (&rest _)
      "Sort dired listings with directories first."
      (save-excursion
        (let (buffer-read-only)
          (forward-line 2) ;; beyond dir. header
          (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
        (set-buffer-modified-p nil)))
    :config
    (advice-add 'dired-readin :after #'config-dired--sort-directories-first))
#+end_src

** Rename files by editing =dired= buffer

=wdired= is a mode that allows you to rename files and directories by editing the
=dired= buffer itself.

#+begin_src emacs-lisp
  (use-package wdired
    :general
    (:states 'normal
     :keymaps 'wdired-mode-map "^" #'evil-first-non-blank
     :keymaps 'dired-mode-map "C-c C-e" #'wdired-change-to-wdired-mode))
#+end_src


** Hide file flags

Use =dired+= to hide file flags.

#+begin_src emacs-lisp
  (use-package dired+
    :hook (dired-mode . dired-hide-details-mode)
    :custom
    ((diredp-wrap-around-flag nil))
    :general
    (:states 'normal :keymaps 'dired-mode-map
     "j" #'diredp-next-line
     "k" #'diredp-previous-line))
#+end_src

** Toggle visibility of hidden files

Use =dired-x= to toggle visibility of 'hidden' files (i.e. files starting with a
dot).

#+begin_src emacs-lisp
  (use-package dired-x
    :hook (dired-mode . dired-omit-mode)
    :general
    (:states 'normal :keymaps 'dired-mode-map "h" #'dired-omit-mode)
    :custom
    ((dired-omit-verbose nil)
     (dired-clean-up-buffers-too t)))
#+end_src

* Project and repo-level commands

=projectile= provides commands for working with projects, and a useful utility
function to find the root directory of the project.

Emacs now comes with =project.el=, but it provides a subset of the functionality
of =projectile=. Use =projectile= until the builtin functionality is more complete.

#+begin_src emacs-lisp
  (use-package projectile
    :hook (after-init . projectile-mode)
    :custom
    ((projectile-project-search-path paths-project-directories)
     (projectile-completion-system 'ivy)
     (projectile-switch-project-action #'dired)
     (projectile-enable-caching t)
     (projectile-create-missing-test-files t)
     (projectile-globally-ignored-files
      '(".DS_Store"
        "package-lock.json"))
     (projectile-globally-ignored-file-suffixes
      '("meta"
        "gz"
        "zip"
        "tar"
        "tgz"
        "elc"
        "eln"))
     (projectile-globally-ignored-directories
      '("coverage"
        ".bzr"
        ".ensime_cache"
        ".eunit"
        ".fslckout"
        ".g8"
        ".git"
        ".hg"
        ".idea"
        ".stack-work"
        ".svn"
        "dist"
        "jars"
        "node_modules"
        "flow-typed/npm"
        "vendor"
        "target"))))
#+end_src

** Use ivy for projectile commands

#+begin_src emacs-lisp
  (use-package counsel-projectile
    :after (projectile)
    :preface
    (progn
      (defun config-projectile--extra-opts-on-prefix-args (&optional options)
        (list (if current-prefix-arg
                  (read-string "Rg args: " options)
                options)))

      (defun config-projectile--escaped-symbol-at-point ()
        (regexp-quote (substring-no-properties (or
                                                (when (region-active-p)
                                                  (buffer-substring (region-beginning) (region-end)))
                                                (thing-at-point 'symbol)
                                                "")))))
    :custom
    ((counsel-projectile-rg-initial-input '(config-projectile--escaped-symbol-at-point))
     (counsel-projectile-switch-project-action #'dired))
    :config
    (progn
      (counsel-projectile-mode +1)
      (advice-add #'counsel-projectile-rg :filter-args #'config-projectile--extra-opts-on-prefix-args)))
#+end_src

* Text snippets

* Themeing

** Highlight pasted text

=volatile-highlights= shows highlights in the buffer when regions change.

Load at compile-time so macro expansions are available.

#+begin_src emacs-lisp
  (cl-eval-when (compile)
    (require 'volatile-highlights))
#+end_src

Configure the package.

#+begin_src emacs-lisp
  (use-package volatile-highlights
    :hook ((prog-mode . (lambda () (require 'volatile-highlights)))
           (text-mode . (lambda () (require 'volatile-highlights))))
    :config
    (volatile-highlights-mode))
#+end_src

Teach =volatile-highlights-mode= to highlight text pasted by =evil= operations.

#+begin_src emacs-lisp
  (use-package volatile-highlights
    :after (evil)
    :demand t
    :config
    (progn
      (vhl/define-extension 'evil
                            'evil-move
                            'evil-paste-after
                            'evil-paste-before
                            'evil-paste-pop)
      (vhl/install-extension 'evil)
      (vhl/load-extension 'evil)))
#+end_src

** Highlight the symbol at point

=highlight-thing= highlights the symbol at point.

#+begin_src emacs-lisp
  (use-package highlight-thing
    :hook (prog-mode . highlight-thing-mode)
    :custom
    ((highlight-thing-what-thing 'symbol)
     (highlight-thing-delay-seconds 0.1)
     (highlight-thing-limit-to-defun nil)
     (highlight-thing-case-sensitive-p t))
    :config
    (set-face-attribute 'highlight-thing nil :inherit 'highlight))
#+end_src

Suppress =highlight-thing= when hovering over certain kinds of symbols.

#+begin_src emacs-lisp
  (use-package highlight-thing
    :preface
    (defun config-highlight-thing--should-highlight-p (res)
      (unless (bound-and-true-p lsp-ui-mode)
        (when res
          (let ((excluded-faces '(font-lock-string-face
                                  font-lock-keyword-face
                                  font-lock-comment-face
                                  font-lock-preprocessor-face
                                  font-lock-builtin-face))
                (faces (seq-mapcat #'face-ancestors (face-at-point nil t))))
            (null (seq-intersection faces excluded-faces))))))

    :config
    (advice-add 'highlight-thing-should-highlight-p :filter-return
                #'config-highlight-thing--should-highlight-p))
#+end_src


* Text scaling

=default-text-scale= provides nice commands for changing text scale for all
buffers simultaneously

#+begin_src emacs-lisp
  (use-package default-text-scale
    :commands (default-text-scale-increase
               default-text-scale-decrease
               default-text-scale-reset)
    :custom
    ((default-text-scale-amount 30)))
#+end_src

* Git

** Magit

=Magit= provides an excellent suite of interactive commands for working with git.

#+begin_src emacs-lisp
  (use-package magit
    :commands (magit-status magit-blame magit-branch-and-checkout)

    :general
    (:keymaps 'transient-base-map "<escape>" #'transient-quit-one
     :states 'normal :keymaps 'magit-refs-mode-map "." #'magit-branch-and-checkout)

    :custom
    ((magit-repository-directories (--map (cons it 1) paths-project-directories))
     (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1)
     (magit-log-section-commit-count 0)))
#+end_src

Reveal the entire org buffer when blaming.

#+begin_src emacs-lisp
  (use-package magit
    :after (org)
    :preface
    (progn
      (autoload 'org-reveal "org")

      (defun config-git--reveal-org-buffer ()
        (when (derived-mode-p 'org-mode)
          (org-reveal t))))
    :config
    (add-hook 'magit-blame-mode-hook #'config-git--reveal-org-buffer))
#+end_src

Reconfigure =magit= keybindings to better support =evil=.

#+begin_src emacs-lisp
  (use-package evil-magit
    :after (:and magit evil-common)
    :demand t
    :config (evil-magit-init))
#+end_src

*** GPG verification

Hack =magit='s commit info to show output of a GPG signature check.

#+begin_src emacs-lisp
  (use-package magit-gpg
    :after (magit)
    :demand t
    :commands (magit-gpg-insert-revision-gpg)
    :preface
    (progn
      (autoload 'magit-add-section-hook "magit")
      (autoload 'magit-insert-revision-headers "magit"))
    :config
    (magit-add-section-hook 'magit-revision-sections-hook
                            #'magit-gpg-insert-revision-gpg
                            #'magit-insert-revision-headers
                            t))
#+end_src

** Forge

=forge= teaches =magit= how to work with pull requests and issues.

#+begin_src emacs-lisp
  (use-package forge
    :after magit
    :demand t
    :config
    (progn
      (remove-hook 'magit-status-sections-hook 'forge-insert-issues)
      (add-hook 'magit-status-sections-hook 'forge-insert-requested-reviews 90)
      (add-hook 'magit-status-sections-hook 'forge-insert-assigned-issues 90)))
#+end_src

** Committing on save

=git-auto-commit-mode= provides a mode that automatically commits changes after
saving a buffer.

#+begin_src emacs-lisp
  (use-package git-auto-commit-mode
    :commands (git-auto-commit-mode)
    :hook (pass-mode . git-auto-commit-mode)
    :custom ((gac-debounce-interval 10)
             (gac-automatically-push-p t)
             (gac-automatically-add-new-files-p t)))
#+end_src

** Step through file history

=vc-annotate= lets you interactively step forward and backwards through a
file's git history.

#+begin_src emacs-lisp
  (use-package vc-annotate
    :commands (vc-annotate)
    :general
    (:states 'normal :keymaps 'vc-annotate-mode-map
     "<return>" 'vc-annotate-find-revision-at-line
     "<tab>" 'vc-annotate-goto-line
     "n" 'vc-annotate-next-revision
     "f" 'vc-annotate-next-revision
     "l" 'vc-annotate-show-log-revision-at-line
     "p" 'vc-annotate-prev-revision
     "b" 'vc-annotate-prev-revision
     "d" 'vc-annotate-show-diff-revision-at-line
     "D" 'vc-annotate-show-changeset-diff-revision-at-line
     "." 'vc-annotate-working-revision))
#+end_src

** Commit messages

#+begin_src emacs-lisp
  (use-package git-commit-mode
    :preface
    (defun config-git--configure-git-commit-mode ()
      (setq-local fill-column 72))
    :init
    (add-hook 'git-commit-mode-hook #'config-git--configure-git-commit-mode))
#+end_src

** Browse file at remote

=browse-at-remote= provides commands for opening the current buffer in the source
repo, or copying the remote URL to the clipboard.

#+begin_src emacs-lisp
  (use-package browse-at-remote
    :general
    ("C-x v o" 'browse-at-remote
     "C-x v y" 'browse-at-remote-kill)
    :custom
    ((browse-at-remote-add-line-number-if-no-region-selected nil)))
#+end_src

Provide more feedback when copying the URL to the clipboard.

#+begin_src emacs-lisp
  (use-package browse-at-remote
    :preface
    (defun config-browse-at-remote--message-kill (&rest _)
      (let ((message-log-max))
        (message "Copied to kill ring: %s" (substring-no-properties (car kill-ring)))))
    :config
    (advice-add 'browse-at-remote-kill :after #'config-browse-at-remote--message-kill))
#+end_src

* Syntax Checking & Linting

=Flycheck= integrates with external tools to show indications of errors and
warnings in the buffer as you edit.

See: [[https://www.flycheck.org/en/latest/][flycheck.org]]

#+begin_src emacs-lisp
  (use-package flycheck
    :hook ((after-init . global-flycheck-mode)
           (prog-mode . flycheck-mode-on-safe))

    :general
    (:keymaps
     'flycheck-mode-map
     "M-n" #'flycheck-next-error
     "M-p" #'flycheck-previous-error
     "M-j" #'flycheck-next-error
     "M-k" #'flycheck-previous-error)

    (:states 'motion
     :keymaps 'flycheck-error-list-mode-map
     "j" #'flycheck-error-list-next-error
     "k" #'flycheck-error-list-previous-error
     "RET" #'flycheck-error-list-goto-error
     "n" #'flycheck-error-list-next-error
     "p" #'flycheck-error-list-previous-error
     "q" #'quit-window)

    :custom
    ((flycheck-display-errors-delay 0.1)
     (flycheck-emacs-lisp-load-path 'inherit)
     (flycheck-python-pycompile-executable "python")
     (flycheck-global-modes '(not text-mode
                                  org-mode
                                  org-agenda-mode))))
#+end_src

Show the =Flycheck= error list in a bottom window.

#+begin_src emacs-lisp
  (add-to-list 'display-buffer-alist
               `(,(rx bos "*Flycheck errors*" eos)
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (reusable-frames . visible)
                 (side            . bottom)
                 (slot            . 1)
                 (window-height   . 0.2)))
#+end_src

** Projectile integration

Automatically re-check all buffers belonging to a project on save. This ensures
diagnostics do not go stale.

#+begin_src emacs-lisp
  (use-package flycheck
    :after (projectile)
    :functions (flycheck-buffer)
    :preface
    (progn
      (autoload 'projectile-project-p "projectile")
      (autoload 'projectile-process-current-project-buffers "projectile")

      (defun config-flycheck--check-all-project-buffers ()
        (when (and (bound-and-true-p projectile-mode) (projectile-project-p))
          (projectile-process-current-project-buffers
           (lambda (buf)
             (with-current-buffer buf
               (when (bound-and-true-p flycheck-mode)
                 ;; HACK: Inhibit checks for elisp, otherwise flycheck will
                 ;; spawn a bunch of thrashing Emacs processes.
                 (unless (derived-mode-p 'emacs-lisp-mode)
                   (flycheck-buffer)))))))))
    :config
    (add-hook 'after-save-hook #'config-flycheck--check-all-project-buffers))
#+end_src

** Conditionally inhibit =Flycheck=

Don't use =Flycheck= in certain situations, such as for files inside =node_modules=,
during =ediff= merges, etc.

#+begin_src emacs-lisp
  (use-package flycheck
    :preface
    (defun config-flycheck--maybe-inhibit (result)
      (unless (or (equal (buffer-name) "*ediff-merge*")
                  (string-suffix-p ".dir-locals.el" (buffer-file-name))
                  (string-match-p (rx bol "*Pp ") (buffer-name))
                  (string-match-p (rx "/node_modules/") default-directory))
        result))
    :config
    (advice-add 'flycheck-may-enable-mode :filter-return #'config-flycheck--maybe-inhibit))
#+end_src

* Buffer list

=ibuffer= provides an interactive buffer list that is better than the default.

#+begin_src emacs-lisp
  (use-package ibuffer
    :commands (ibuffer ibuffer-forward-line ibuffer-backward-line)
    :defines (ibuffer-show-empty-filter-groups
              ibuffer-never-show-predicates)
    :general
    ("C-x C-b" #'ibuffer-other-window)
    (:keymaps 'ibuffer-mode-map :states 'motion
     "<return>" #'ibuffer-visit-buffer
     "j" #'ibuffer-forward-line
     "k" #'ibuffer-backward-line)
    :custom
    ((ibuffer-expert t)
     (ibuffer-default-sorting-mode 'major-mode)
     (ibuffer-default-sorting-reversep t)
     (ibuffer-formats '((mark modified " " (mode 1 1) " " (name 35 35 :left :elide) " " filename-and-process)))
     (ibuffer-never-show-predicates
      (list (rx (or "*Messages*"
                    "*magit-"
                    "*git-auto-push*"
                    ".elc"
                    "magit-process"
                    "magit-diff"
                    "magit-revision"
                    "TAGS"
                    "*Backtrace*"
                    "*new*"
                    "*Org"
                    "*Flycheck error messages*"
                    "*Quail Completions*"
                    "*scratch*"
                    "*direnv*"
                    "*calc trail*"
                    "*Help*"))
            #'config-ibuffer--roam-buffer-p)))
    :preface
    (defun config-ibuffer--roam-buffer-p (buf)
      (with-current-buffer buf
        (when (buffer-file-name)
          (string-match-p "/org/roam/" (buffer-file-name)))))

    :config
    (add-hook 'ibuffer-mode-hook #'hl-line-mode))
#+end_src


** Extensions

=ibuf-ext= adds a few extra features to =ibuffer=.

#+begin_src emacs-lisp
  (use-package ibuf-ext
    :hook (ibuffer-mode . ibuffer-auto-mode)
    :custom
    ((ibuffer-show-empty-filter-groups nil)))
#+end_src

** Cosmetic changes

Override some default =ibuffer= columns.

#+begin_src emacs-lisp
  (use-package ibuffer
    :commands (ibuffer-make-column-filename)
    :preface
    (cl-eval-when (compile)
      (require 'ibuffer))
    :config
    (progn
      (define-ibuffer-column name
        (:inline t)
        (let ((string (buffer-name)))
          (if (not (seq-position string ?\n))
              string
            (replace-regexp-in-string
             "\n" (propertize "^J" 'font-lock-face 'escape-glyph) string))))

      (define-ibuffer-column filename-and-process
        (:name "Filename/Process")
        (let ((proc (get-buffer-process buffer))
              (filename (ibuffer-make-column-filename buffer mark)))
          (if proc
              (concat (propertize (format "(%s %s)" proc (process-status proc))
                                  'font-lock-face 'italic)
                      (if (> (length filename) 0)
                          (format " %s" filename)
                        ""))
            (require 'dired+)
            (propertize (abbreviate-file-name filename) 'face 'diredp-symlink))))))
#+end_src

** Grouping by project

=ibuffer-projectile= teaches =ibuffer= how to group files by =projectile= project.

#+begin_src emacs-lisp
  (use-package ibuffer-projectile
    :commands (ibuffer-projectile-set-filter-groups)
    :custom
    ((ibuffer-projectile-prefix ""))

    :preface
    (progn
      (autoload 'ibuffer-do-sort-by-alphabetic "ibuf-ext")
      (autoload 'page-break-lines--update-display-tables "page-break-lines")

      (defun config-ibuffer--setup-buffer ()
        (ibuffer-projectile-set-filter-groups)
        (add-to-list 'ibuffer-filter-groups '("emacs-src" (predicate . (when (buffer-file-name)
                                                                         (string-match-p (rx "/share/emacs") (buffer-file-name))))))

        (unless (eq ibuffer-sorting-mode 'alphabetic)
          (ibuffer-do-sort-by-alphabetic))

        ;; All this buffer modification will have messed up the separator
        ;; fontification, so force the display table to update now.
        (when (bound-and-true-p page-break-lines-mode)
          (page-break-lines--update-display-tables))))
    :init
    (add-hook 'ibuffer-hook #'config-ibuffer--setup-buffer))
#+end_src

* Parentheses

Use =smartparens= to keep parens and braces paired and manipulate expressions in a
structured way.

See: [[https://github.com/Fuco1/smartparens][Fuco1/smartparens]]

#+begin_src emacs-lisp
  (use-package smartparens
    :hook ((prog-mode . smartparens-strict-mode)
           (text-mode . smartparens-strict-mode))

    :general
    (:keymaps 'smartparens-strict-mode-map
     [remap c-electric-backspace] #'sp-backward-delete-char)
    (:states 'insert
     ")" #'sp-up-sexp)
    (:states 'normal
     "D" #'sp-kill-hybrid-sexp)

    :custom
    ((sp-show-pair-delay 0.2)
     (sp-show-pair-from-inside t)
     (sp-cancel-autoskip-on-backward-movement nil)
     (sp-highlight-pair-overlay nil)
     (sp-highlight-wrap-overlay nil)
     (sp-highlight-wrap-tag-overlay nil)
     (sp-navigate-close-if-unbalanced t)
     (sp-message-width nil))

    :config
    (progn
      (require 'smartparens-config)
      (smartparens-global-strict-mode +1)
      (show-smartparens-global-mode +1)))
#+end_src


Load macros and functions at compile time so I can use them in this config.

#+begin_src emacs-lisp
  (cl-eval-when (compile)
    (require 'smartparens))

  (autoload 'sp-pair "smartparens")
  (autoload 'sp-local-pair "smartparens")
#+end_src

** Utility functions

#+begin_src emacs-lisp
  (autoload 'sp-get-pair "smartparens")
  (autoload 'sp--get-opening-regexp "smartparens")
  (autoload 'sp--get-closing-regexp "smartparens")

  (defun config-smartparens-add-space-before-sexp-insertion (id action _context)
    (when (eq action 'insert)
      (save-excursion
        (backward-char (length id))
        (cond
         ((and (eq (preceding-char) ?$)
               (equal id "{")))

         ((eq (char-syntax (preceding-char)) ?w)
          (just-one-space))

         ((and (looking-back (sp--get-closing-regexp) (line-beginning-position))
               (not (eq (char-syntax (preceding-char)) ?')))
          (just-one-space))))))

  (defun config-smartparens-add-space-after-sexp-insertion (id action _context)
    (when (eq action 'insert)
      (save-excursion
        (forward-char (sp-get-pair id :cl-l))
        (when (or (eq (char-syntax (following-char)) ?w)
                  (looking-at (sp--get-opening-regexp)))
          (insert " ")))))
#+end_src

** Global pairs

Define pairs that I want in all language modes.

#+begin_src emacs-lisp
  (use-package smartparens
    :config
    (progn
      (sp-pair "`" "`"
               :bind "M-`")
      (sp-pair "{" "}"
               :bind "M-{"
               :pre-handlers '(config-smartparens-add-space-before-sexp-insertion)
               :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
      (sp-pair "[" "]"
               :bind "M-["
               :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
      (sp-pair "(" ")"
               :bind "M-("
               :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
      (sp-pair "\"" "\""
               :bind "M-\""
               :pre-handlers '(:add (config-smartparens-add-space-before-sexp-insertion)))))
#+end_src

** Delete enclosing whitespace as necessary on backspace

#+begin_src emacs-lisp
  (use-package smartparens
    :functions (sp-get-enclosing-sexp)
    :preface
    (defun config-smartparens-delete-horizontal-space-for-delete (f &rest args)
      "Perform context-sensitive whitespace cleanups when deleting.

  For performance, only consider the 5 lines before and after point."
      (save-restriction
        (apply #'narrow-to-region (bounds-of-surrounding-lines 5 5))

        (-let* ((line-before-pt (buffer-substring (line-beginning-position) (point)))
                (line-after-pt (buffer-substring (point) (line-end-position)))

                ((&plist :beg beg :end end :op op :cl cl) (sp-get-enclosing-sexp))
                (inside-start (when op (+ beg (length op))))
                (inside-end   (when op (- end (length cl))))
                (inside       (when op
                                (concat (buffer-substring inside-start (point))
                                        (buffer-substring (point) inside-end)))))
          (cond
           ;; Collapse horizontal space in empty pairs.
           ;;
           ;; [  |  ] -> [|]
           ;;
           ((when op (string-match-p (rx bos (+ space) eos) inside))
            (delete-region inside-start inside-end))

           ;; Delete contents for multiline pairs that were just inserted, e.g. braces.
           ;;
           ;; {
           ;;   |
           ;; }
           ;;
           ;; ->
           ;;
           ;; {|}
           ((when op (string-match-p (rx bos (* space) "\n" (* space) "\n" (* space) eos) inside))
            (delete-region inside-start inside-end))

           ;; Delete back from end of the line.
           ;;
           ;;
           ;; foo |
           ;; ->
           ;; foo|

           ;; foo      |
           ;; ->
           ;; foo |
           ((string-empty-p line-after-pt)
            (if (string-match-p (rx space space eos) line-before-pt)
                (while (looking-back (rx space space) (line-beginning-position))
                  (delete-char -1))
              (funcall f args)))

           ;; Don't aggressively delete whitespace if there's a comment
           ;; following pt.
           ;;
           ;;
           ;; foo |  // bar
           ;;
           ;; ->
           ;;
           ;; foo|  // bar
           ;;
           ((string-match-p (rx (* nonl) (syntax comment-start)) line-after-pt)
            (funcall f args))

           ;; Collapse surrounding space, but preserve padding inside pairs.
           ;;
           ;; foo | bar -> foo|bar
           ;;
           ;; foo | }   -> foo| }
           ;;
           ((and (string-match-p (rx (or bol (not space)) space eos) line-before-pt)
                 (string-match-p (rx bos space (or eol (not space))) line-after-pt))
            (let ((backward-only? (when inside (string-match-p (rx bos space) inside))))
              (delete-horizontal-space backward-only?)))

           ;; Delete if there is a single preceding space.
           ;;
           ;; foo |bar -> foo|bar
           ;;
           ;; but not:
           ;;
           ;; foo| bar -> foo|bar
           ;;
           ((and (string-match-p (rx (or bol (not space)) space eos) line-before-pt)
                 (string-match-p (rx bos (not space)) line-after-pt))
            (delete-char -1))

           ;; Delete surrounding whitespace beyond a certain length.
           ;;
           ;; foo    |bar      -> foo |bar
           ;; foo    |    bar  -> foo | bar
           ((string-match-p (rx (+ space) eos) line-before-pt)
            (let ((has-space? (eq (char-after) ? )))
              (skip-chars-forward " ")
              (while (looking-back (rx space space) (line-beginning-position))
                (delete-char -1))
              (when has-space?
                (insert " ")
                (forward-char -1))))

           (t
            (funcall f args))))))
    :config
    (advice-add 'sp-backward-delete-char :around #'config-smartparens-delete-horizontal-space-for-delete))
#+end_src


** Emacs lisp

#+begin_src emacs-lisp
  (use-package smartparens
    :config
    (sp-with-modes sp-lisp-modes
      (sp-local-pair "(" nil
                     :pre-handlers '(config-smartparens-add-space-before-sexp-insertion)
                     :post-handlers '(config-smartparens-add-space-after-sexp-insertion))
      (sp-local-pair "[" nil
                     :pre-handlers '(config-smartparens-add-space-before-sexp-insertion)
                     :post-handlers '(config-smartparens-add-space-after-sexp-insertion))
      (sp-local-pair "\"" nil
                     :pre-handlers '(config-smartparens-add-space-before-sexp-insertion)
                     :post-handlers '(config-smartparens-add-space-after-sexp-insertion))
      (sp-local-pair "{" nil
                     :pre-handlers '(config-smartparens-add-space-before-sexp-insertion)
                     :post-handlers '(config-smartparens-add-space-after-sexp-insertion))))
#+end_src

** Markdown & org-mode

Make checkbox insertion a little smarter.

#+begin_src emacs-lisp
  (use-package smartparens
    :preface
    (progn
      (autoload 'org-at-item-p "org-list")

      (defun config-smartparens--format-checkitem (_id action _context)
        (when (and (equal action 'insert)
                   (org-at-item-p))
          (atomic-change-group
            (just-one-space)
            (search-backward "[" (line-beginning-position))
            (just-one-space)
            (search-forward "]" (line-end-position))
            (just-one-space)))))
    :config
    (sp-with-modes '(org-mode markdown-mode gfm-mode)
      (sp-local-pair "[" "]" :post-handlers '(config-smartparens--format-checkitem))))
#+end_src



* Emacs Lisp

#+begin_src emacs-lisp
  (use-package elisp-mode
    :general
    (:keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
     "C-c C-c" #'eval-defun
     "C-c C-b" #'eval-buffer)
    (:states 'visual
     :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
     "C-c C-c" #'eval-region))
#+end_src

** Code navigation

Use =elisp-slime-nav= to go to definition in Emacs Lisp.

#+begin_src emacs-lisp
  (use-package elisp-slime-nav
    :hook (emacs-lisp-mode . elisp-slime-nav-mode)
    :general
    (:keymaps 'emacs-lisp-mode-map :states 'normal
     "M-." #'elisp-slime-nav-find-elisp-thing-at-point))
#+end_src

** Documentation

=helpful= is a more feature-rich alternative to the Emacs Lisp help buffer.

#+begin_src emacs-lisp
  (use-package helpful
    :general
    (:keymaps '(emacs-lisp-mode-map helpful-mode-map) :states '(motion normal)
     "K" 'helpful-at-point))
#+end_src

Display helpful buffers in side windows.

#+begin_src emacs-lisp
  (add-to-list 'display-buffer-alist
               `(,(rx bos "*helpful ")
                 (display-buffer-reuse-window
                  display-buffer-pop-up-window)
                 (reusable-frames . visible)
                 (side            . right)
                 (slot            . 1)
                 (window-width    . 0.5)))
#+end_src

** Inline documentation

=eldoc= shows function parameters in the minibuffer.

#+begin_src emacs-lisp
  (use-package eldoc
    :hook (emacs-lisp-mode . eldoc-mode)
    :custom
    ((eldoc-idle-delay 0.2)))
#+end_src

** Hex colour literals

=rainbow mode= applies colours for hex strings.

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :hook (emacs-lisp-mode . rainbow-mode))
#+end_src

** REPL

=ielm= is the built-in REPL for Emacs Lisp.

#+begin_src emacs-lisp
  (use-package ielm
    :general
    (:keymaps 'emacs-lisp-mode-map "C-c C-z" #'ielm)
    (:keymaps 'inferior-emacs-lisp-mode-map
     "C-c C-z" #'config-elisp-pop-to-elisp-buffer)
    :preface
    (defun config-elisp-pop-to-elisp-buffer ()
      (interactive)
      (if-let* ((buf (seq-find (lambda (buf)
                                 (with-current-buffer buf
                                   (derived-mode-p 'emacs-lisp-mode)))
                               (buffer-list))))
          (pop-to-buffer buf)
        (user-error "No Emacs Lisp buffers")))
    :config
    (add-hook 'inferior-emacs-lisp-mode-hook #'hs-minor-mode))
#+end_src

Display =ielm= in a side window.

#+begin_src emacs-lisp
  (add-to-list 'display-buffer-alist
               `(,(rx bos "*ielm*" eos)
                 (display-buffer-reuse-window display-buffer-in-side-window)
                 (side            . right)
                 (window-width    . 80)))
#+end_src

** Pretty-printing

=pp= provides pretty-printing of lisp forms.

#+begin_src emacs-lisp
  (use-package pp
    :general
    (:keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map inferior-emacs-lisp-mode-map)
     :states '(motion normal insert)
     "C-c C-<return>" 'pp-eval-last-sexp
     "C-c <return>" 'pp-eval-last-sexp
     "C-c e" 'pp-macroexpand-last-sexp
     "C-c C-e" 'pp-macroexpand-last-sexp))
#+end_src

** Improve indent function

Teach the Emacs Lisp indentation function to indent plists nicely.

#+begin_src emacs-lisp
  (use-package lisp-mode
    :preface
    (progn
      (defvar calculate-lisp-indent-last-sexp)

      (defun config-elisp--better-lisp-indent-function (indent-point state)
        (let ((normal-indent (current-column))
              (orig-point (point)))
          (goto-char (1+ (elt state 1)))
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond
           ;; car of form doesn't seem to be a symbol, or is a keyword
           ((and (elt state 2)
                 (or (not (looking-at "\\sw\\|\\s_"))
                     (looking-at ":")))
            (unless (> (save-excursion (forward-line 1) (point))
                       calculate-lisp-indent-last-sexp)
              (goto-char calculate-lisp-indent-last-sexp)
              (beginning-of-line)
              (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t))

            ;; Indent under the list or under the first sexp on the same
            ;; line as calculate-lisp-indent-last-sexp.  Note that first
            ;; thing on that line has to be complete sexp since we are
            ;; inside the innermost containing sexp.
            (backward-prefix-chars)
            (current-column))
           ((and (save-excursion
                   (goto-char indent-point)
                   (skip-syntax-forward " ")
                   (not (looking-at ":")))
                 (save-excursion
                   (goto-char orig-point)
                   (looking-at ":")))
            (save-excursion
              (goto-char (+ 2 (elt state 1)))
              (current-column)))
           (t
            (let ((function (buffer-substring (point)
                                              (progn (forward-sexp 1) (point))))
                  method)
              (setq method (or (function-get (intern-soft function)
                                             'lisp-indent-function)
                               (get (intern-soft function) 'lisp-indent-hook)))
              (cond ((or (eq method 'defun)
                         (and (null method)
                              (> (length function) 3)
                              (string-match "\\`def" function)))
                     (lisp-indent-defform state indent-point))
                    ((integerp method)
                     (lisp-indent-specform method state
                                           indent-point normal-indent))
                    (method
                     (funcall method indent-point state)))))))))
    :custom
    ((lisp-indent-function #'config-elisp--better-lisp-indent-function)))
#+end_src

** Improved syntax checking

=flycheck-package= adds a checker for =package.el= conventions. It is inhibited for
certain types of Elisp files.

#+begin_src emacs-lisp
  (use-package flycheck-package
    :after (:all flycheck elisp-mode)
    :preface
    (defun config-elisp--flycheck-package-predicate ()
      (not (or (bound-and-true-p no-byte-compile)
               (bound-and-true-p org-src-mode)
               (ignore-errors
                 (string-match-p "^test-" (file-name-nondirectory (buffer-file-name)))))))
    :config
    (eval
     '(progn
        (flycheck-package-setup)
        (setf (flycheck-checker-get 'emacs-lisp-package 'predicate)
              #'config-elisp--flycheck-package-predicate))))
#+end_src

=Checkdoc= is used by flycheck for linting Elisp docstrings.

#+begin_src emacs-lisp
  (use-package checkdoc
    :after (flycheck)
    :custom
    ((checkdoc-force-docstrings-flag nil)
     (checkdoc-arguments-in-order-flag nil))
    :config
    (eval
     '(setf (flycheck-checker-get 'emacs-lisp-checkdoc 'predicate)
            #'config-flycheck--elisp-package-flycheck-predicate)))
#+end_src

* Nix

Configure major-mode for Nix language buffers.

#+begin_src emacs-lisp
  (use-package nix-mode
    :mode (("\\.nix\\'" . nix-mode)
           ("\\.nix.in\\'" . nix-mode))
    :custom
    ((nix-indent-function 'nix-indent-line)))
#+end_src

Teach Emacs how to create a Nix language REPL.

#+begin_src emacs-lisp
  (use-package nix-repl
    :commands (nix-repl-show)
    :config
    (add-to-list 'display-buffer-alist
                 `(,(rx bos "*Nix-REPL*" eos)
                   (display-buffer-reuse-window
                    display-buffer-at-bottom)
                   (reusable-frames . visible)
                   (slot            . 1)
                   (window-height   . 0.4))))
#+end_src

* Markdown

Customise markdown file support.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("\\.md\\'" . gfm-mode)
           ("\\.markdown\\'" . markdown-mode))

    :general
    (:states 'normal :keymaps 'markdown-mode-map
     "TAB" #'markdown-cycle
     "RET" #'markdown-follow-thing-at-point)
    (:keymaps 'markdown-mode-map
     "C-c C-l" #'markdown-insert-link
     "C-c C-i" #'markdown-insert-image
     "C-c C-f" #'markdown-insert-footnote
     "C-c C--" #'markdown-insert-hr
     "C-c C-e" #'markdown-export
     "C-c C-o" #'markdown-preview
     "C-c p" #'markdown-live-preview-mode
     "C-<return>" #'markdown-insert-header-dwim
     "M-<left>" #'markdown-promote
     "M-<right>" #'markdown-demote
     "M-<up>" #'markdown-move-subtree-up
     "M-<down>" #'markdown-move-subtree-down)

    :custom
    ((markdown-command "multimarkdown")
     (markdown-fontify-code-blocks-natively t)
     (markdown-hide-urls t)))
#+end_src

* Tex & Latex

Use =auctex= as the Tex and Latex editing mode.

=auctex= is disgusting and clobbers the builtin Tex modes. To load it lazily,
intercept attempts to load Tex files and make sure =auctex= is loaded first.

#+begin_src emacs-lisp
  (defun config-latex--lazy-load-auctex ()
    (when (string-match-p (rx "." (or "latex" "tex") string-end)
                          (buffer-name))
      (require 'tex-site)))

  (add-hook 'find-file-hook #'config-latex--lazy-load-auctex)
#+end_src

#+begin_src emacs-lisp
  (use-package tex
    :preface
    (defvar-local TeX-syntactic-comments t)
    :custom
    ((TeX-command-default (getenv "NIX_EMACS_TEX_PROGRAM"))
     (TeX-auto-save t)
     (TeX-parse-self t)
     (TeX-source-correlate-start-server nil)
     ;; Use Emacs pdf-tools as viewer.
     (TeX-view-program-selection '((output-pdf "PDF Tools")))
     (TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view)))))
#+end_src

#+begin_src emacs-lisp
  (use-package latex
    :custom
    ((LaTeX-command (getenv "NIX_EMACS_TEX_PROGRAM"))
     ;; Don't insert line-break at inline math.
     (LaTeX-fill-break-at-separators nil))
    :config
    (progn
      (add-hook 'LaTeX-mode-hook 'flyspell-mode)
      (add-hook 'LaTeX-mode-hook 'TeX-fold-mode)
      (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
      (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
      (add-hook 'LaTeX-mode-hook 'TeX-PDF-mode)))
#+end_src


** Smarter autofill function

Teach the autofill function in Latex buffers not to fill in certain contexts.

#+begin_src emacs-lisp
  (use-package latex
    :functions (LaTeX-current-environment)
    :preface
    (progn
      (defvar config-latex-no-indent-envs '("equation" "equation*" "align" "align*" "tabular" "tikzpicture"))

      (defun config-latex--autofill ()
        ;; Check whether the pointer is currently inside one of the
        ;; environments described in `config-latex-no-indent-envs' and if so, inhibits
        ;; the automatic filling of the current paragraph.
        (let ((env)
              (should-fill t)
              (level 0))
          (while (and should-fill (not (equal env "document")))
            (cl-incf level)
            (setq env (LaTeX-current-environment level))
            (setq should-fill (not (member env config-latex-no-indent-envs))))

          (when should-fill
            (do-auto-fill))))

      (defun config-latex--configure-autofill ()
        (auto-fill-mode +1)
        (setq-local auto-fill-function #'config-latex--autofill)))
    :config
    (add-hook 'LaTeX-mode-hook 'config-latex--configure-autofill))
#+end_src

** Build command

=C-c C-c= builds the current buffer with =tectonic=.

#+begin_src emacs-lisp
  (use-package latex
    :general
    (:keymaps 'LaTeX-mode-map
     "C-c C-b" #'config-latex-build)
    :preface
    (progn
      (autoload 'TeX-command "tex-buf")
      (autoload 'TeX-master-file "tex")
      (autoload 'TeX-save-document "tex-buf")

      (defvar TeX-save-query)

      (defun config-latex-build ()
        (interactive)
        (progn
          (let ((TeX-save-query nil))
            (TeX-save-document (TeX-master-file)))
          (TeX-command (getenv "NIX_EMACS_TEX_PROGRAM") 'TeX-master-file -1)))))
#+end_src


** Environment folding

=tex-fold= enables folding of macros and environments. It's part of =auctex=.

#+begin_src emacs-lisp
  (use-package tex-fold
    :after tex
    :demand t)
#+end_src

** Code completion

#+begin_src emacs-lisp
  (use-package company-auctex
    :after (:all tex company)
    :demand t
    :config (company-auctex-init))
#+end_src

** Show preview on save

#+begin_src emacs-lisp
  (use-package latex-preview-pane
    :general (:keymaps 'LaTeX-mode-map "C-c p" #'latex-preview-pane))
#+end_src

* Ledger

#+begin_src emacs-lisp
  (use-package ledger-mode
    :mode ("\\.ledger$" . ledger-mode)

    :general

    (:keymaps 'ledger-report-mode-map
     "C-c C-c" #'ledger-report
     "q" #'kill-buffer-and-window)

    (:keymaps 'ledger-mode-map
     "C-c C-c" #'ledger-report
     "M-RET" #'ledger-toggle-current-transaction)

    :custom
    ((ledger-report-use-header-line nil)
     (ledger-post-account-alignment-column 2)
     (ledger-fontify-xact-state-overrides nil)))
#+end_src

Configure how reports are displayed.

#+begin_src emacs-lisp
  (use-package ledger-mode
    :config
    (add-to-list 'display-buffer-alist
                 `(,(rx bos "*Ledger Report*" eos)
                   (display-buffer-reuse-window display-buffer-pop-up-window))))
#+end_src

** Highlight negative numbers in red

#+begin_src emacs-lisp
  (use-package ledger-mode
    :preface
    (defface ledger-report-negative-amount
      `((t (:foreground "red")))
      "Face for negative amounts in ledger reports."
      :group 'ledger-faces)

    :config
    (progn
      (font-lock-add-keywords
       'ledger-report-mode
       `((,(rx "$" (* space) "-" (+ digit) (* (any digit ",")) (? "." (+ digit))) . 'ledger-report-negative-amount)
         (,(rx (+ digit) "-" (= 3 alpha) "-" (+ digit)) . 'ledger-font-posting-date-face)))
      (add-hook 'ledger-report-mode-hook 'font-lock-fontify-buffer)))
#+end_src

** Changing transaction timestamps

Use =C-c C-.= to change the timestamp of the transaction at point.

#+begin_src emacs-lisp
  (use-package ledger-mode
    :general
    (:keymaps 'ledger-mode-map
     "C-c C-." #'config-ledger-set-xact-timestamp)

    :functions (ledger-context-field-end-position
                ledger-context-field-position
                ledger-context-field-value
                ledger-read-date
                ledger-xact-context)
    :preface
    (defun config-ledger-set-xact-timestamp ()
      (interactive)
      (when-let* ((ctx (ledger-xact-context))
                  (value (ledger-context-field-value ctx 'date))
                  (start (ledger-context-field-position ctx 'date))
                  (end (ledger-context-field-end-position ctx 'date))
                  (updated (ledger-read-date "Transaction date: ")))
        (if (string= value updated)
            (user-error "Date unchanged")
          (save-excursion
            (goto-char start)
            (delete-region start end)
            (insert updated))
          (let ((message-log-max))
            (message "Date changed: %s -> %s" value updated))))))
#+end_src

** Format buffer

Define a command to format a ledger buffer.

#+begin_src emacs-lisp
  (use-package ledger-mode
    :general (:keymaps 'ledger-mode-map "M-q" #'ledger-format-buffer)

    :functions (ledger-mode-clean-buffer)
    :preface
    (progn
      (defvar ledger-post-amount-alignment-column 52)

      (defun ledger-format--align-price-assertion ()
        (when (string-match-p (rx (+ space) "=" (* space) (not (any digit)))
                              (buffer-substring (line-beginning-position)
                                                (line-end-position)))
          (unwind-protect
              (progn
                (goto-char (line-beginning-position))
                (search-forward "=")
                (goto-char (match-beginning 0))
                (indent-to (1+ ledger-post-amount-alignment-column))
                (skip-chars-forward " =")
                (just-one-space))
            (goto-char (line-end-position)))))

      (defun ledger-format-buffer ()
        "Reformat the buffer."
        (interactive "*")
        (let ((pos (point)))
          (ignore-errors
            (ledger-mode-clean-buffer))
          (goto-char (point-min))
          (while (search-forward-regexp (rx (>= 2 space) "=") nil t)
            (ledger-format--align-price-assertion))
          (goto-char pos)))))
#+end_src


** Flycheck support

#+begin_src emacs-lisp
  (use-package flycheck-ledger
    :after (:and flycheck ledger-mode)
    :demand t)
#+end_src

* PlantUML

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :mode (("\\.plantuml\\'" . plantuml-mode)
           ("\\.puml\\'" . plantuml-mode))
    :general
    (:keymaps 'plantuml-mode-map
     "C-c C-b" 'recompile)
    :custom
    ((plantuml-default-exec-mode 'jar)
     (plantuml-indent-level 2)
     (plantuml-jar-path (getenv "NIX_EMACS_PLANTUML_JAR")))
    :config
    (modify-syntax-entry ?_ "w" plantuml-mode-syntax-table))
#+end_src

** Flycheck support

#+begin_src emacs-lisp
  (use-package flycheck-plantuml
    :after (:all flycheck plantuml-mode)
    :demand t
    :config (flycheck-plantuml-setup))
#+end_src

** Richer syntax highlighting

Teach Emacs how to highlight arrows and important keywords.

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :preface
    (progn
      (defconst config-plantuml--participant-binder-rx
        `(and word-start (+? (syntax word)) word-end))

      (defconst config-plantuml--arrows-rx
        (let* ((direction '(or "up" "u" "down" "d" "left" "l" "right" "r"))
               (directives '(and "[" (*? nonl) "]"))
               (lines '(+ "-"))
               (dots '(+ ".")))
          ;; HACK: Make sure we have at least 2 characters in an arrow to avoid
          ;; nonsense.
          `(or  "---"
                "..."
                (and "<" ,lines)
                (and "<" ,dots)
                (and ,lines ">")
                (and ,dots ">")
                (and "<" ,lines ">")
                (and "<" ,dots ">")
                (and (? "<")
                     (or (and ,lines (? ,directives) (? ,direction) ,lines)
                         (and ,dots (? ,directives) (? ,direction) ,dots))
                     (? ">"))))))

    :config
    (font-lock-add-keywords
     'plantuml-mode
     `((,(rx bol (* space) (group (or "@startuml" "@enduml")))
        (0 'font-lock-preprocessor-face))

       (,(rx bol (* space) (group "title") symbol-end)
        (1 'font-lock-preprocessor-face))

       (,(rx bol (* space) (group "note"))
        (1 'font-lock-keyword-face)
        (,(rx (+ space) (group (or "left" "right" "bottom" "top") (+ space) (group "of")))
         nil nil
         (1 'font-lock-keyword-face)
         (2 'font-lock-keyword-face))
        (,(rx (+ space) (group (+ (syntax word))) eol)
         nil nil
         (1 'font-lock-variable-name-face)))

       (,(rx bol (* space) (group "end" (+ space) "note"))
        (1 'font-lock-keyword-face))

       (,(rx bol (* space) (group "!include" (* word)))
        (0 font-lock-keyword-face)
        (,(rx (+ nonl)) nil nil (0 'font-lock-string-face)))

       (,(rx bol (* space) (group "!startsub"))
        (0 'font-lock-preprocessor-face)
        (,(rx (+ nonl)) nil nil (0 'font-lock-function-name-face)))

       (,(rx bol (* space) (group "!endsub")) (0 'font-lock-preprocessor-face))

       ;; Naive macro highlighting

       (,(rx bol (* space) (group upper (* (syntax word))) (* space) "("
             (? (group (+ (syntax word)))))
        (1 'font-lock-type-face)
        (2 'font-lock-variable-name-face))

       ;; Groupings

       (,(rx bol (* space) (group (or "package" "node" "folder" "frame" "cloud" "database"))
             symbol-end)
        (1 'font-lock-keyword-face)
        (,(rx symbol-start (group "as") (+ space) (group (+ (syntax word)) symbol-end))
         nil nil
         (1 'font-lock-keyword-face)
         (2 'font-lock-variable-name-face)))

       ;; Sequence diagrams

       (,(rx bol (* space) (group (or "actor" "boundary" "control"
                                      "entity" "database" "collections"))
             (? (+ space)
                (group (+ (syntax word)))
                symbol-end))
        (1 'font-lock-keyword-face)
        (2 'font-lock-variable-name-face))


       ;; Improved arrows syntax highlighting

       (,(rx-to-string `(and bol
                             (* space) (group ,config-plantuml--participant-binder-rx)
                             (* space) (group ,config-plantuml--arrows-rx)
                             (* space) (group ,config-plantuml--participant-binder-rx))
                       t)
        (1 'font-lock-variable-name-face)
        (2 'font-lock-keyword-face)
        (3 'font-lock-variable-name-face)
        (,(rx (group ":") (* space) (group (* nonl)))
         nil nil
         (1 'font-lock-keyword-face)
         (2 'font-lock-string-face)))

       ;; Creole text formatting: https://plantuml.com/creole

       (,(rx (not "~") (group "**") (group (+? any)) (group "**"))
        (1 'parenthesis)
        (2 'bold)
        (3 'parenthesis))

       (,(rx (not "~") (group "//") (group (+? any)) (group "//"))
        (1 'parenthesis)
        (2 'italic)
        (3 'parenthesis))

       (,(rx (not "~") (group "\"\"") (group (+? any)) (group "\"\""))
        (1 'parenthesis)
        (2 'org-code)
        (3 'parenthesis))

       (,(rx (not "~") (group "--") (group (+? any)) (group "--"))
        (1 'parenthesis)
        (2 '(:strike-through t))
        (3 'parenthesis))

       (,(rx (not "~") (group "__") (group (+? any)) (group "__"))
        (1 'parenthesis)
        (2 'underline)
        (3 'parenthesis))

       (,(rx (not "~") (group "~~") (group (+? any)) (group "~~"))
        (1 'parenthesis)
        (2 '(:underline (:style wave)))
        (3 'parenthesis))

       (,(rx bol (* space) (group (+ "#")) (+ (not (any "*"))))
        (1 'org-list-dt))

       (,(rx bol (* space) (group "*") (+ (not (any "*"))))
        (1 'org-list-dt)))))
#+end_src


* File postamble

#+begin_src emacs-lisp
  (defvar total-startup-time nil)

  (add-hook 'after-init-hook (lambda ()
                               (setq total-startup-time (float-time (time-subtract (current-time) (with-no-warnings emacs-start-time))))
                               (message "after-init completed (%.3f seconds total startup time)" total-startup-time)))

  ;; (provide 'config)
  ;;; config.el ends here
#+end_src
